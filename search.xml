<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>about</title>
    <url>/2023/01/01/about/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>yan</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown语法</title>
    <url>/2023/03/26/markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Markdown是一种轻量级的「标记语言」。**<a href="#jump_8">kongkong</a>**</p>
</blockquote>
<h2 id="1-Markdown-com-cn-简介"><a href="#1-Markdown-com-cn-简介" class="headerlink" title="1 Markdown.com.cn 简介"></a>1 Markdown.com.cn 简介</h2><ul>
<li>支持自定义样式的 Markdown 编辑器</li>
<li>支持微信公众号、知乎和稀土掘金</li>
<li>点击右上方对应图标，一键复制到各平台</li>
</ul>
<h2 id="2-Markdown语法教程"><a href="#2-Markdown语法教程" class="headerlink" title="2 Markdown语法教程"></a>2 Markdown语法教程</h2><h3 id="2-1-标题"><a href="#2-1-标题" class="headerlink" title="2.1 标题"></a>2.1 标题</h3><p>不同数量的<code>#</code>可以完成不同的标题，如下：</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>粗体、斜体、粗体和斜体，删除线，需要在文字前后加不同的标记符号。如下：</p>
<p><strong>这个是粗体</strong></p>
<p><em>这个是斜体</em></p>
<p><em><strong>这个是粗体加斜体</strong></em></p>
<p>~这里想用删除线~~</p>
<p>注：如果想给字体换颜色、字体或者居中显示，需要使用内嵌HTML来实现。</p>
<h3 id="2-3-无序列表"><a href="#2-3-无序列表" class="headerlink" title="2.3 无序列表"></a>2.3 无序列表</h3><p>无序列表的使用，在符号<code>-</code>后加空格使用。如下：</p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2</li>
<li>无序列表 3</li>
</ul>
<p>如果要控制列表的层级，则需要在符号<code>-</code>前使用空格。如下：</p>
<ul>
<li>无序列表 1</li>
<li>无序列表 2<ul>
<li>无序列表 2.1</li>
<li>无序列表 2.2</li>
</ul>
</li>
</ul>
<p><strong>由于微信原因，最多支持到二级列表</strong>。</p>
<h3 id="2-4-有序列表"><a href="#2-4-有序列表" class="headerlink" title="2.4 有序列表"></a>2.4 有序列表</h3><p>有序列表的使用，在数字及符号<code>.</code>后加空格后输入内容，如下：</p>
<ol>
<li>有序列表 1</li>
<li>有序列表 2</li>
<li>有序列表 3</li>
</ol>
<h3 id="2-5-引用"><a href="#2-5-引用" class="headerlink" title="2.5 引用"></a>2.5 引用</h3><p>引用的格式是在符号<code>&gt;</code>后面书写文字。如下：</p>
<blockquote>
<p>读一本好书，就是在和高尚的人谈话。 ——歌德</p>
</blockquote>
<blockquote>
<p>雇用制度对工人不利，但工人根本无力摆脱这个制度。 ——阮一峰</p>
</blockquote>
<h3 id="2-7-链接"><a href="#2-7-链接" class="headerlink" title="2.7 链接"></a>2.7 链接</h3><p>微信公众号仅支持公众号文章链接，即域名为<code>https://mp.weixin.qq.com/</code>的合法链接。使用方法如下所示：</p>
<p>对于该论述，欢迎读者查阅之前发过的文章，<a href="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA">你是《未来世界的幸存者》么？</a><br><a id="jump_8"></a></p>
<h3 id="2-8-图片"><a href="#2-8-图片" class="headerlink" title="2.8 图片"></a>2.8 图片</h3><p>插入图片，格式如下：</p>
<p><img src="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" alt="这里写图片描述"></p>
<p>支持 jpg、png、gif、svg 等图片格式，<strong>其中 svg 文件仅可在微信公众平台中使用</strong>，svg 文件示例如下：</p>
<p><img src="https://markdown.com.cn/images/i-am-svg.svg"></p>
<p>支持图片<strong>拖拽和截图粘贴</strong>到编辑器中。</p>
<p>注：支持图片 <em><strong>拖拽和截图粘贴</strong></em> 到编辑器中，仅支持 https 的图片，图片粘贴到微信时会自动上传微信服务器。</p>
<h3 id="2-9-分割线"><a href="#2-9-分割线" class="headerlink" title="2.9 分割线"></a>2.9 分割线</h3><p>可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：</p>
<hr>
<h3 id="2-10-表格"><a href="#2-10-表格" class="headerlink" title="2.10 表格"></a>2.10 表格</h3><p>可以使用冒号来定义表格的对齐方式，如下：</p>
<table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">年龄</th>
<th align="right">工作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">小可爱</td>
<td align="center">18</td>
<td align="right">吃可爱多</td>
</tr>
<tr>
<td align="left">小小勇敢</td>
<td align="center">20</td>
<td align="right">爬棵勇敢树</td>
</tr>
<tr>
<td align="left">小小小机智</td>
<td align="center">22</td>
<td align="right">看一本机智书</td>
</tr>
</tbody></table>
<h2 id="3-特殊语法"><a href="#3-特殊语法" class="headerlink" title="3. 特殊语法"></a>3. 特殊语法</h2><h3 id="3-1-脚注"><a href="#3-1-脚注" class="headerlink" title="3.1 脚注"></a>3.1 脚注</h3><blockquote>
<p>支持平台：微信公众号、知乎。</p>
</blockquote>
<p>脚注与链接的区别如下所示：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">链接：[<span class="string">文字</span>](<span class="link">链接</span>)</span><br><span class="line">脚注：[<span class="string">文字</span>](<span class="link">脚注解释 &quot;脚注名字&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>有人认为在<a href="https://en.wikipedia.org/wiki/Front-end_web_development" title="Front-end web development">大前端时代</a>的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。</p>
<p><a href="%E6%98%AF%E6%8C%87%E6%8E%8C%E6%8F%A1%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%EF%BC%8C%E5%B9%B6%E8%83%BD%E5%88%A9%E7%94%A8%E5%A4%9A%E7%A7%8D%E6%8A%80%E8%83%BD%E7%8B%AC%E7%AB%8B%E5%AE%8C%E6%88%90%E4%BA%A7%E5%93%81%E7%9A%84%E4%BA%BA%E3%80%82" title="什么是全栈工程师">全栈工程师</a>在业务开发流程中起到了至关重要的作用。</p>
<p>脚注内容请拉到最下面观看。</p>
<h3 id="3-2-代码块"><a href="#3-2-代码块" class="headerlink" title="3.2 代码块"></a>3.2 代码块</h3><blockquote>
<p>支持平台：微信代码主题仅支持微信公众号！其他主题无限制。</p>
</blockquote>
<p>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：</p>
<p>Use the <code>printf()</code> function.</p>
<p>在需要高亮的代码块的前一行及后一行使用三个反引号，同时<strong>第一行反引号后面表示代码块所使用的语言</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FileName: HelloWorld.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">  <span class="comment">// Java 入口程序，程序从此入口</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello,World!&quot;</span>); <span class="comment">// 向控制台打印一条语句</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持以下语言种类：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line">clojure，cpp，cs，css</span><br><span class="line">dart，dockerfile, diff</span><br><span class="line">erlang</span><br><span class="line">go，gradle，groovy</span><br><span class="line">haskell</span><br><span class="line">java，javascript，json，julia</span><br><span class="line">kotlin</span><br><span class="line">lisp，lua</span><br><span class="line">makefile，markdown，matlab</span><br><span class="line">objectivec</span><br><span class="line">perl，php，python</span><br><span class="line">r，ruby，rust</span><br><span class="line">scala，shell，sql，swift</span><br><span class="line">tex，typescript</span><br><span class="line">verilog，vhdl</span><br><span class="line">xml</span><br><span class="line">yaml</span><br></pre></td></tr></table></figure>

<p>如果想要更换代码高亮样式，可在上方<strong>代码主题</strong>中挑选。</p>
<p>其中<strong>微信代码主题与微信官方一致</strong>，有以下注意事项：</p>
<ul>
<li>带行号且不换行，代码大小与官方一致</li>
<li>需要在代码块处标志语言，否则无法高亮</li>
<li>粘贴到公众号后，用鼠标点代码块内外一次，完成高亮</li>
</ul>
<p>diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 新增项</span></span><br><span class="line"><span class="deletion">- 删除项</span></span><br></pre></td></tr></table></figure>

<p><strong>其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致</strong></p>
<h3 id="3-3-数学公式"><a href="#3-3-数学公式" class="headerlink" title="3.3 数学公式"></a>3.3 数学公式</h3><blockquote>
<p>支持平台：微信公众号、知乎。</p>
</blockquote>
<p>行内公式使用方法，比如这个化学公式：$\ce{Hg^2+ -&gt;[I-] HgI2 -&gt;[I-] [Hg^{II}I4]^2-}$</p>
<p>块公式使用方法如下：</p>
<p>$$H(D_2) = -\left(\frac{2}{4}\log_2 \frac{2}{4} + \frac{2}{4}\log_2 \frac{2}{4}\right) = 1$$</p>
<p>矩阵：</p>
<p>$$<br>  \begin{pmatrix}<br>  1 &amp; a_1 &amp; a_1^2 &amp; \cdots &amp; a_1^n \<br>  1 &amp; a_2 &amp; a_2^2 &amp; \cdots &amp; a_2^n \<br>  \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>  1 &amp; a_m &amp; a_m^2 &amp; \cdots &amp; a_m^n \<br>  \end{pmatrix}<br>$$</p>
<p>公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。</p>
<p>目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。</p>
<h3 id="3-4-TOC"><a href="#3-4-TOC" class="headerlink" title="3.4 TOC"></a>3.4 TOC</h3><blockquote>
<p>支持平台：微信公众号、知乎。</p>
</blockquote>
<p>TOC 全称为 Table of Content，列出全部标题。</p>
<p>[TOC]</p>
<p>由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。</p>
<h3 id="3-5-注音符号"><a href="#3-5-注音符号" class="headerlink" title="3.5 注音符号"></a>3.5 注音符号</h3><blockquote>
<p>支持平台：微信公众号。</p>
</blockquote>
<p>支持注音符号，用法如下：</p>
<p>Markdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！</p>
<h3 id="3-6-横屏滑动幻灯片"><a href="#3-6-横屏滑动幻灯片" class="headerlink" title="3.6 横屏滑动幻灯片"></a>3.6 横屏滑动幻灯片</h3><blockquote>
<p>支持平台：微信公众号。</p>
</blockquote>
<p>通过<code>&lt;![](url),![](url)&gt;</code>这种语法设置横屏滑动滑动片，具体用法如下：</p>
<p>&lt;<img src="https://markdown.com.cn/images/blue.jpg" alt="蓝1">,<img src="https://markdown.com.cn/images/green.jpg" alt="绿2">,<img src="https://markdown.com.cn.jpg/" alt="红3">&gt;</p>
<h2 id="4-其他语法"><a href="#4-其他语法" class="headerlink" title="4 其他语法"></a>4 其他语法</h2><h3 id="4-1-HTML"><a href="#4-1-HTML" class="headerlink" title="4.1 HTML"></a>4.1 HTML</h3><p>支持原生 HTML 语法，请写内联样式，如下：</p>
<p><span style="display:block;text-align:right;color:orangered;">橙色居右</span><br><span style="display:block;text-align:center;color:orangered;">橙色居中</span></p>
<h3 id="4-2-UML"><a href="#4-2-UML" class="headerlink" title="4.2 UML"></a>4.2 UML</h3><p>不支持，推荐使用开源工具<code>https://draw.io/</code>制作后再导入图片</p>
<p>来源：<a href="https://markdown.com.cn/editor/">https://markdown.com.cn/editor/</a></p>
]]></content>
      <categories>
        <category>备用</category>
      </categories>
      <tags>
        <tag>yan</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/26/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>深度神经网络</title>
    <url>/2023/03/26/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>深度神经网络<br>分析深度学习背后的数学思想</p>
<p><strong>深度神经网络（DNN）</strong>本质上是通过具有多个连接的感知器而形成的，其中感知器是单个神经元。可以将人工神经网络（ANN）视为一个系统，其中包含沿加权路径馈入的一组输入。然后处理这些输入，并产生输出以执行某些任务。</p>
<p>在DNN中，如果所有输入都密集连接到所有输出，则这些层称为密集层</p>
<p>尽管目标是从数据中尽可能多地学习，但是深度学习模型可能会遭受过度拟合的困扰。非线性模型在深度学习模型中也非常重要，尽管该模型将从具有多个隐藏层的内容中学到很多东西，但是将线性形式应用于非线性问题将导致性能下降。</p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O</title>
    <url>/2023/05/14/javase/IO/IO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><hr>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="对象持久化"><a href="#对象持久化" class="headerlink" title="对象持久化"></a>对象持久化</h3><p>在 Java 程序中所创建的对象都保存在内存中，一旦 JVM 停止运行，这些对象都将会消失。因此以下两种情况必须通过序列化实现：</p>
<ol>
<li>需要把对象持久化保存在文件中，在 JVM 重启后能够继续使用。</li>
<li>通过网络传送对象信息，在多个 JVM 间共享对象。</li>
</ol>
<h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p>在类中声明实现 Serializable 接口，表示允许 Java 程序对这个类的对象序列化：JVM 会将对象的成员变量保存为一组字节，这些字节可以再被 JVM 组装成对象。对象序列化只保存的对象的成员变量，且不会关注类中的静态变量。</p>
<ol>
<li><strong>transient 字段</strong>：默认序列化机制就会被忽略。</li>
<li><strong>private 字段</strong>：序列化后不会被保护，任何 JVM 都可读取。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person类的读入读出</span></span><br><span class="line"><span class="comment">//对于 class Person implements Serializable</span></span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;John&quot;</span>, <span class="number">101</span>, Gender.MALE);</span><br><span class="line">        oout.writeObject(person);</span><br><span class="line">        oout.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">oin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newPerson</span> <span class="operator">=</span> oin.readObject(); <span class="comment">// 没有强制转换到Person类型</span></span><br><span class="line">        oin.close();</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="标准输入-输出"><a href="#标准输入-输出" class="headerlink" title="标准输入/输出"></a>标准输入/输出</h2><h3 id="标准输入流-System-in"><a href="#标准输入流-System-in" class="headerlink" title="标准输入流 System.in"></a>标准输入流 System.in</h3><p>读取标准输入设备数据（键盘），每次输入将以换行符结束。数据类型为 InputStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)System.in.read();   <span class="comment">// 读取单个输入字符，返回其 ASCII 值(int)</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">System.in.read(b);                 <span class="comment">// 读取输入定长字符组，返回字符个数(int)</span></span><br></pre></td></tr></table></figure>


<h3 id="标准输出流-System-out"><a href="#标准输出流-System-out" class="headerlink" title="标准输出流 System.out"></a>标准输出流 System.out</h3><p>向标准输出设备输出数据（控制台）。数据类型为 PrintStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span>);                         <span class="comment">// 输出数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);                       <span class="comment">// 输出数据并换行</span></span><br></pre></td></tr></table></figure>

<p><strong>格式化输出</strong></p>
<p>通过 printf 方法可以输出指定格式数据：其中 <code>%d</code> 表示整型数字， <code>%f</code> 表示浮点型数字， <code>%%</code> 表示百分号。</p>
<p>在百分号后加入特殊符号，可以指定数据的显示类型。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
<th>示例</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>为正数或者负数添加符号</td>
<td>(“%+d”,99)</td>
<td>+99</td>
</tr>
<tr>
<td>2</td>
<td>位数（默认右对齐）</td>
<td>(“%4d”, 99)</td>
<td>__99</td>
</tr>
<tr>
<td>−</td>
<td>左对齐</td>
<td>(“%-4d”, 99)</td>
<td>99__</td>
</tr>
<tr>
<td>0</td>
<td>数字前补0</td>
<td>(“%04d”, 9999)</td>
<td>0099</td>
</tr>
<tr>
<td>,</td>
<td>以“,”对数字分组</td>
<td>(“%,d”, 9999)</td>
<td>9,999</td>
</tr>
<tr>
<td>.2</td>
<td>小数点后精确位数</td>
<td>(“%5.2f”, 9.999)</td>
<td>_9.99</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;The number is %+,9.3f&quot;</span>, PI);  <span class="comment">// 输出指定格式数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="流输入输出"><a href="#流输入输出" class="headerlink" title="流输入输出"></a>流输入输出</h2><p>java.io 文件夹内提供了 Java 程序中 I/O 操作使用的类，使用时需要进行导入。    </p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><h4 id="InputStream-OutputStream-类"><a href="#InputStream-OutputStream-类" class="headerlink" title="InputStream/OutputStream 类"></a>InputStream/OutputStream 类</h4><p>以字节为单位进行读取的数据流。常用来处理二进制数据的输入输出，如键盘输入、网络通信。但字节流不能正确显示 Unicode 字符。</p>
<p><strong>输入流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStream</span>(socket.getIntputStream());        <span class="comment">// 创建输入对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.available();                                          <span class="comment">// 读取输入对象长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)in.read();                                          <span class="comment">// 读取输入字节</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[len];                                          <span class="comment">// 连续读取输入字节</span></span><br><span class="line">in.read(b);</span><br><span class="line"></span><br><span class="line">in.close();                                                        <span class="comment">// 关闭输入对象</span></span><br></pre></td></tr></table></figure>

<p><strong>输出流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStream</span>(socket.getOutputStream());     <span class="comment">// 创建输出对象</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;                                                <span class="comment">// 导入输出字节          </span></span><br><span class="line">out.write(b);</span><br><span class="line"></span><br><span class="line">out.flush();                                                       <span class="comment">// 刷新输出对象，输出字节</span></span><br><span class="line"></span><br><span class="line">out.close();                                                       <span class="comment">// 关闭输出对象，输出字节</span></span><br></pre></td></tr></table></figure>


<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><h4 id="Reader-Writer-类"><a href="#Reader-Writer-类" class="headerlink" title="Reader/Writer 类"></a>Reader/Writer 类</h4><p>以字符为单位进行读取的数据流。只能用于处理文本数据。且所有文本数据，即经过 Unicode 编码的数据都必须以字符流的形式呈现。</p>
<p>我们在 Java 程序中处理数据往往需要用到字符流，但在通信中却需要使用字节流。这就需要进行数据格式转化。</p>
<h4 id="InputStreamReader-类"><a href="#InputStreamReader-类" class="headerlink" title="InputStreamReader 类"></a>InputStreamReader 类</h4><p>Reader 类子类。将字节流数据转换成字符流，常用于读取控制台输入或读取网络通信。可指定编码方式，否则使用 IDE 默认编码方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取键盘输入</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line"><span class="comment">// 读取套接字通信，并指定编码格式</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="OutputStreamWriter-类"><a href="#OutputStreamWriter-类" class="headerlink" title="OutputStreamWriter 类"></a>OutputStreamWriter 类</h4><p>Writer 类子类。将字符流数据转换成字节流，常用于发送网络通信。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据转化为字节流发送</span></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream());</span><br></pre></td></tr></table></figure>

<h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><h4 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h4><p>用于文件或者目录的描述信息，默认加载当前目录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;FileTest.txt&quot;</span>);                <span class="comment">// 读取当前目录文件</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://file//FileTest.txt&quot;</span>);      <span class="comment">// 读取指定目录文件</span></span><br></pre></td></tr></table></figure>

<h4 id="FileInputStream-FileReader-类"><a href="#FileInputStream-FileReader-类" class="headerlink" title="FileInputStream/FileReader 类"></a>FileInputStream/FileReader 类</h4><p>FileInputStream 类读取字节流文件信息，FileReader 类读取字符流文件信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileReader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ReadFile</span><span class="params">(String textName)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 连接文件</span></span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;D:\\Workspaces&quot;</span> + textName);</span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)c);</span><br><span class="line">            &#125;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到指定文件&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件读取错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FileOutputStream-FileWriter-类"><a href="#FileOutputStream-FileWriter-类" class="headerlink" title="FileOutputStream/FileWriter 类"></a>FileOutputStream/FileWriter 类</h4><p>FileOutputStream 写入字节流文件信息，FileWriter 类写入字符流文件信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileWriter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">ReadFile</span><span class="params">(String textName)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 追加模式，写入文本信息会添加到文本尾部</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(textName);            </span><br><span class="line">            <span class="comment">// 覆盖模式，写入文本信息会覆盖原有数据</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;data.txt&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="comment">// 执行操作</span></span><br><span class="line">            fw.write(<span class="string">&quot;Hello world！欢迎来到 java 世界\n&quot;</span>);                 </span><br><span class="line">            fw.append(<span class="string">&quot;我是下一行&quot;</span>);                            </span><br><span class="line">            fw.flush();                                       </span><br><span class="line">            System.out.println(<span class="string">&quot;文件编码为&quot;</span> + fw.getEncoding());</span><br><span class="line">            fw.close();                    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找不到指定文件&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件写入错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="BufferedInputStream-BufferedReader-类"><a href="#BufferedInputStream-BufferedReader-类" class="headerlink" title="BufferedInputStream/BufferedReader 类"></a>BufferedInputStream/BufferedReader 类</h4><p>BufferedInputStream 类将输入字节数据暂存到缓冲区数组，BufferedReader 类将输入字符流数据暂存到缓冲区数组。</p>
<p>JVM 在缓冲区数组满后一次性获取缓冲区内的数据，减少了对 CPU 的频繁请求。</p>
<h4 id="BufferedOutputStream-BufferedWriter-类"><a href="#BufferedOutputStream-BufferedWriter-类" class="headerlink" title="BufferedOutputStream/BufferedWriter 类"></a>BufferedOutputStream/BufferedWriter 类</h4><p>BufferedOutputStream 类将输出字节数据暂存到缓冲区数组，BufferedWriter 类将输出字符流数据暂存到缓冲区数组。</p>
<p>JVM 在刷新时一次性将缓冲区内的数据输出到外部设备，减少了对 CPU 的频繁请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestBuffer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bufferUse</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 通过缓冲区读取键盘输入</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="comment">// 通过缓冲区输出到文件</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;     <span class="comment">// readLine 缓冲流特有方法，一次性读取一行</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;over&quot;</span>.equals(line))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();                          <span class="comment">// newLine 缓冲流特有方法，写入换行符</span></span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="扫描器"><a href="#扫描器" class="headerlink" title="扫描器"></a>扫描器</h2><h3 id="Scanner-类"><a href="#Scanner-类" class="headerlink" title="Scanner 类"></a>Scanner 类</h3><p>包装输入并自动分割数据，调用 next 方法捕获，可以自动转换数据类型。位于 java.util 包内，使用时需进行导入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);                             <span class="comment">// 读取键盘输入，返回 String 数据类型                  </span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;example.txt&quot;</span>));     <span class="comment">// 读取文件信息，返回 String 数据类型</span></span><br><span class="line"></span><br><span class="line">sc.hasNextInt();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();                                            <span class="comment">// 截取数据并自动转化数据类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> sc.nextLine();                                      <span class="comment">// 取出行内全部数据</span></span><br><span class="line"></span><br><span class="line">sc.close();                                                      <span class="comment">// 关闭 Scanner 类</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javase</category>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Net</title>
    <url>/2023/05/14/javase/IO/Net/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java-Net"><a href="#Java-Net" class="headerlink" title="Java Net"></a>Java Net</h1><p>java.net 文件夹内提供了 Java 程序中网络通信使用的类，使用时需要进行导入。    </p>
<hr>
<h2 id="HTTP通信"><a href="#HTTP通信" class="headerlink" title="HTTP通信"></a>HTTP通信</h2><h3 id="URL-类"><a href="#URL-类" class="headerlink" title="URL 类"></a>URL 类</h3><ul>
<li><p><strong>URL 类</strong>：用于定向资源所在位置，资源由 URLConnection 类读取。</p>
</li>
<li><p><strong>URLConnection 类</strong>：用于读取和写入 URL 类定向的资源，在 HTTP 通信中常用 HttpURLConnection 子类。</p>
</li>
</ul>
<p>在 HTTP 通信中通常需要执行以下五个过程。</p>
<ol>
<li>创建连接对象。</li>
<li>设置连接参数和请求属性。</li>
<li>建立连接，输出流发送请求。 </li>
<li>输入流读取返回内容。</li>
<li>关闭连接。</li>
</ol>
<h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 URL 对象，如果 url 格式错误则抛出 IOException</span></span><br><span class="line"><span class="type">URL</span> <span class="variable">myUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);                   </span><br><span class="line"><span class="comment">// 创建 URLConnection 对象，读取 URL 资源</span></span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">myCon</span> <span class="operator">=</span> (HttpURLConnection)myUrl.openConnetcion();</span><br></pre></td></tr></table></figure>


<h4 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h4><p><strong>设置连接参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.setRequestMethod(<span class="string">&quot;POST&quot;</span>);               <span class="comment">// 设置连接方法，默认使用 GET</span></span><br><span class="line">myCon.setDoInput(<span class="literal">true</span>);                       <span class="comment">// （默认）允许进行字符流输入，执行 read 操作</span></span><br><span class="line">myCon.setDoOutput(<span class="literal">true</span>);                      <span class="comment">// （默认）允许进行字符流输出，执行 write 操作</span></span><br><span class="line">myCon.setUseCaches(<span class="literal">false</span>);                    <span class="comment">// 设置是否使用缓存</span></span><br><span class="line">myCon.setConnectTimeout(<span class="number">1000</span>);                 <span class="comment">// 设置最长建立连接时间，超时抛出 SocketTimeoutException</span></span><br><span class="line">myCon.setReadTimeout(<span class="number">1000</span>);                 <span class="comment">// 设置最长数据读取时间，超时抛出 SocketTimeoutException</span></span><br></pre></td></tr></table></figure>


<p><strong>设置请求属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置版本</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1.2.3&quot;</span>);         </span><br><span class="line"><span class="comment">// 设置浏览器类型（用于爬虫伪装）</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible;  Windows NT 5.1;SV1)&quot;</span>);</span><br><span class="line"><span class="comment">// 设置发送文本类型</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>



<h4 id="连接-amp-发送请求"><a href="#连接-amp-发送请求" class="headerlink" title="连接 &amp; 发送请求"></a>连接 &amp; 发送请求</h4><p>连接和发送请求有两种方式：</p>
<ol>
<li>调用 connect 方法，直接建立连接并发送请求。</li>
<li>调用 getOutputStream 方法，在输出流中写入数据，在关闭输出流时自动建立连接并发送输出流请求。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(myCon.getOutputStream());</span><br><span class="line">out.write(str);            <span class="comment">// 写入数据      </span></span><br><span class="line">out.close();               <span class="comment">// 建立连接并发送请求       </span></span><br></pre></td></tr></table></figure>

<h4 id="获取响应数据"><a href="#获取响应数据" class="headerlink" title="获取响应数据"></a>获取响应数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> myCon.getResponseCode();            <span class="comment">// 获取响应码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">head</span> <span class="operator">=</span> myCon.getHeaderField();          <span class="comment">// 获取响应头字段</span></span><br></pre></td></tr></table></figure>

<p>获取响应体数据有两种方式：</p>
<ol>
<li>调用 getContent 方法，直接获取响应内容。</li>
<li>调用 getInputStream 方法，通过输入流获取响应内容。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(myCon.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> ((str = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line">myCon.disconnect();</span><br></pre></td></tr></table></figure>


<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例：网络爬虫</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebCrawler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getHttpJson</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//配置URL</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">myUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://static-data.eol.cn/www/school/&quot;</span>+ i + <span class="string">&quot;/info.json&quot;</span>);</span><br><span class="line">            <span class="comment">//配置连接</span></span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">myCon</span> <span class="operator">=</span> (HttpURLConnection) myUrl.openConnection();</span><br><span class="line">            myCon.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;</span>);</span><br><span class="line">            myCon.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">            myCon.setReadTimeout(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            myCon.connect();</span><br><span class="line">            <span class="comment">//如果连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (myCon.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据读取成功，数据内容：&quot;</span>);</span><br><span class="line">                <span class="comment">//读取返回数据</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> myCon.getInputStream();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> in.available();</span><br><span class="line">                <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[cnt];</span><br><span class="line">                in.read(b);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">                <span class="comment">//输出返回数据</span></span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据读取失败，代码：&quot;</span> + myCon.getResponseCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;URL错误，无法查找到资源。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SocketTimeoutException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据访问连接超时。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送的请求存在错误，资源拒绝访问。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h3 id="Socket-类"><a href="#Socket-类" class="headerlink" title="Socket 类"></a>Socket 类</h3><ul>
<li><strong>Socket 类</strong>：通过套接字指向对方通信位置，用于建立 TCP 连接。</li>
<li><strong>ServerSocket 类</strong>：在服务器建立，绑定自身的端口号用于监听是否有用户请求。</li>
</ul>
<p><strong>服务器端</strong></p>
<ol>
<li>创建 ServerSocket 对象，绑定监听端口监听客户端请求。</li>
<li>接收到客户端请求后，创建 Socket 与该客户建立专线连接。</li>
<li>双方通过输入输出流进行对话。</li>
<li>关闭流和套接字，继续等待新的连接。</li>
</ol>
<p><strong>客户端</strong></p>
<ol>
<li>创建 Socket 对象，指明需要连接的服务器地址和端口号。</li>
<li>连接建立后，通过输出流向服务器发送请求信息。</li>
<li>双方通过输入输出流进行对话。</li>
<li>关闭流和套接字。</li>
</ol>
<h3 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">55533</span>);     <span class="comment">// 创建 Socket 对象指向服务器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">55533</span>);      <span class="comment">// 创建 ServerSocket 对象监听接口</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();                <span class="comment">// 阻塞进程，直到接收到客户端请求返回 Socket 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="进行对话"><a href="#进行对话" class="headerlink" title="进行对话"></a>进行对话</h4><p>输出流负责输出信息，在另一端输入流将得到输入。失败则抛出 IOException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开输出流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//输出信息（字节流）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">out.write(message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">out.write(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"><span class="comment">//关闭输出流</span></span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>

<p>输入流负责输入信息，得到另一端输出流信息。失败则抛出 IOException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开输入流（转化为字节流被缓冲流读取）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//输入信息(接收到end字符则结束)</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">while</span> ((str = in.readLine()) != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;end&quot;</span>.equals(str)) &#123;</span><br><span class="line">  message.append(str);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;get message: &quot;</span> + message);</span><br><span class="line"><span class="comment">//关闭输入流</span></span><br><span class="line">in.close(); <span class="comment">//socket.shutdownOutput();</span></span><br></pre></td></tr></table></figure>

<h3 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h3><ul>
<li><strong>客户端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//与本地服务器端建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制台输入并向服务器端输出</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in, <span class="string">&quot;UTF-8&quot;</span>));      </span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));         </span><br><span class="line">    <span class="keyword">while</span> (str != <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">      bufferedWriter.write(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      bufferedWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>服务器端</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环等待请求</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="comment">//建立连接</span></span><br><span class="line">      <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">      <span class="comment">//从socket中获取输入流并读取</span></span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      String str;，</span><br><span class="line">      <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get message from client:&quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭连接</span></span><br><span class="line">      inputStream.close();</span><br><span class="line">      socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>服务器端可以通过多线程实现伪异步，每接受一个 Socket 请求，就创建一个线程来处理它。防止程序被一个请求阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端（线程池管理）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//循环等待请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">//分配线程</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//从socket中获取输入流并读取</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    String str;</span><br><span class="line">                    <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;get message from client:&quot;</span> + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流输入输出"><a href="#流输入输出" class="headerlink" title="流输入输出"></a>流输入输出</h4><p>在实际应用中，我们通过是采用数据长度+类型+数据的方式来告知一次流输入完成，方便进行后续操作。</p>
<p><a href="https://blog.csdn.net/qq_33865313/article/details/79363640">https://blog.csdn.net/qq_33865313/article/details/79363640</a></p>
<p><a href="https://www.cnblogs.com/huanzi-qch/p/9889521.html">https://www.cnblogs.com/huanzi-qch/p/9889521.html</a></p>
<h3 id="WebSocket-类"><a href="#WebSocket-类" class="headerlink" title="WebSocket 类"></a>WebSocket 类</h3><p>Socket 消息推送机制中，用的都是 Ajax 轮询。在特定的时间间隔由客户端自动发出请求，将服务器的消息主动拉回来（服务器启动一个线程去监听与此客户端的通信），这种方式是非常消耗资源的，因为它本质还是 http 请求，而且显得非常笨拙：服务端不能主动向客户端推送数据。</p>
<p><code>import javax.websocket.*;</code></p>
<p>WebSocket 在浏览器和服务器完成一个握手的动作，在建立连接之后，服务器可以主动传送数据给客户端，客户端也可以随时向服务器发送数据。多客户端、涉及有界面的聊天建议使用websocket（嵌入到了浏览器的内核中）。</p>
<p><a href="https://www.cnblogs.com/interdrp/p/7903736.html">https://www.cnblogs.com/interdrp/p/7903736.html</a></p>
<p><strong>Spring框架</strong></p>
<p>服务端：</p>
<p> 1、添加Jar包依赖：</p>
<p> 2、创建一个WebSocket服务端类，并添加@ServerEndpoint(value = “/websocket”)注解<br>表示将 WebSocket 服务端运行在 ws://[Server 端 IP 或域名]:[Server 端口]/项目名/websocket 的访问端点</p>
<p> 3、实现onOpen、onClose、onMessage、onError等方法</p>
<p>客户端</p>
<p> 1、添加Jar包依赖：</p>
<p> 2、创建WebSocket客户端类并继承WebSocketClient</p>
<p> 3、实现构造器，重写onOpen、onClose、onMessage、onError等方法</p>
<p> <strong>Maven依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javaee-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>服务器定义WebSocket类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ServerEndpoint(&quot;/websocket/&#123;username&#125;&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocket</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">onlineCount</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, WebSocket&gt; clients = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, WebSocket&gt;();  </span><br><span class="line">    <span class="keyword">private</span> Session session;  </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@OnOpen</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onOpen</span><span class="params">(<span class="meta">@PathParam(&quot;username&quot;)</span> String username, Session session)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">this</span>.username = username;  </span><br><span class="line">        <span class="built_in">this</span>.session = session;  </span><br><span class="line">          </span><br><span class="line">        addOnlineCount();  </span><br><span class="line">        clients.put(username, <span class="built_in">this</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;已连接&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@OnClose</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClose</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        clients.remove(username);  </span><br><span class="line">        subOnlineCount();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@OnMessage</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonTo</span> <span class="operator">=</span> JSONObject.fromObject(message);  </span><br><span class="line">          </span><br><span class="line">        <span class="keyword">if</span> (!jsonTo.get(<span class="string">&quot;To&quot;</span>).equals(<span class="string">&quot;All&quot;</span>))&#123;  </span><br><span class="line">            sendMessageTo(<span class="string">&quot;给一个人&quot;</span>, jsonTo.get(<span class="string">&quot;To&quot;</span>).toString());  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            sendMessageAll(<span class="string">&quot;给所有人&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@OnError</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Session session, Throwable error)</span> &#123;  </span><br><span class="line">        error.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageTo</span><span class="params">(String message, String To)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="comment">// session.getBasicRemote().sendText(message);  </span></span><br><span class="line">        <span class="comment">//session.getAsyncRemote().sendText(message);  </span></span><br><span class="line">        <span class="keyword">for</span> (WebSocket item : clients.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (item.username.equals(To) )  </span><br><span class="line">                item.session.getAsyncRemote().sendText(message);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessageAll</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">for</span> (WebSocket item : clients.values()) &#123;  </span><br><span class="line">            item.session.getAsyncRemote().sendText(message);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">          </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getOnlineCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> onlineCount;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOnlineCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        WebSocket.onlineCount++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">subOnlineCount</span><span class="params">()</span> &#123;  </span><br><span class="line">        WebSocket.onlineCount--;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Map&lt;String, WebSocket&gt; <span class="title function_">getClients</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> clients;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端在JavaScript中调用即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;  </span><br><span class="line"><span class="keyword">var</span> username = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;name&quot;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断当前浏览器是否支持WebSocket  </span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;  </span><br><span class="line">    websocket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&quot;ws://&quot;</span> + <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">host</span> + <span class="string">&quot;/WebChat/websocket/&quot;</span> + username + <span class="string">&quot;/&quot;</span>+ _img);  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;当前浏览器 Not support websocket&#x27;</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//连接发生错误的回调方法  </span></span><br><span class="line">websocket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;WebSocket连接发生错误&quot;</span>);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//连接成功建立的回调方法  </span></span><br><span class="line">websocket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;WebSocket连接成功&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//接收到消息的回调方法  </span></span><br><span class="line">websocket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;  </span><br><span class="line">    <span class="title function_">setMessageInnerHTML</span>(event.<span class="property">data</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//连接关闭的回调方法  </span></span><br><span class="line">websocket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="title function_">setMessageInnerHTML</span>(<span class="string">&quot;WebSocket连接关闭&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。  </span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onbeforeunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    <span class="title function_">closeWebSocket</span>();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//关闭WebSocket连接  </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">closeWebSocket</span>(<span class="params"></span>) &#123;  </span><br><span class="line">    websocket.<span class="title function_">close</span>();  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>发送消息只需要使用websocket.send(“发送消息”)，就可以触发服务端的onMessage()方法，当连接时，触发服务器端onOpen()方法，此时也可以调用发送消息的方法去发送消息。关闭websocket时，触发服务器端onclose()方法，此时也可以发送消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">WebSocket</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">jo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">jo.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;这是后台返回的消息！&quot;</span>);</span><br><span class="line">jo.put(<span class="string">&quot;To&quot;</span>,invIO.getIoEmployeeUid());</span><br><span class="line">ws.onMessage(jo.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span>&#123;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] arg0)</span>&#123;</span><br><span class="line">　　　　<span class="type">MyWebSocketClient</span> <span class="variable">myClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWebSocketClient</span>(<span class="string">&quot;此处为websocket服务端URI&quot;</span>);</span><br><span class="line">　　　　<span class="comment">// 往websocket服务端发送数据</span></span><br><span class="line">　　　　myClient.send(<span class="string">&quot;此为要发送的数据内容&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javase</category>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM介绍</title>
    <url>/2023/05/14/javase/JVM/JVM%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><hr>
<h2 id="JDK-JRE-JVM-的关系"><a href="#JDK-JRE-JVM-的关系" class="headerlink" title="JDK / JRE / JVM 的关系"></a>JDK / JRE / JVM 的关系</h2><h3 id="JDK-开发工具包"><a href="#JDK-开发工具包" class="headerlink" title="JDK 开发工具包"></a>JDK 开发工具包</h3><p>(java development kit) <strong>支持开发和运行 Java 程序。</strong></p>
<p>JDK 包含 JRE 以及各种 Java 开发工具（如编译器 javac 、调试器 jdb 等）。</p>
<h3 id="JRE-运行环境"><a href="#JRE-运行环境" class="headerlink" title="JRE 运行环境"></a>JRE 运行环境</h3><p>(java runtime environment) <strong>能够运行已编译的 Java 程序。</strong></p>
<p>JRE 包含 JVM 以及运行时所需调用的基础类库（如 java.lang 包、 java.util 包等）。</p>
<h3 id="JVM-虚拟机"><a href="#JVM-虚拟机" class="headerlink" title="JVM 虚拟机"></a>JVM 虚拟机</h3><p>(java virtual machine) <strong>运行 Java 程序的工作环境。</strong></p>
<p>Java 程序在虚拟机上运行而不是直接在操作系统上运行，从软件层面屏蔽了底层硬件指令的细节。虚拟机会根据操作系统自动将字节码文件转化成相应的机器码，使 Java 字节码文件能够在多种平台上不加修改地运行。</p>
<p><em>HotSpot 虚拟机 是 SunJDK 和 OpenJDK 中所带的虚拟机，也是目前使用范围最广的 Java 虚拟机。</em></p>
<hr>
<h2 id="Java-运行原理"><a href="#Java-运行原理" class="headerlink" title="Java 运行原理"></a>Java 运行原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>解释和编译</strong></p>
<ul>
<li><strong>解释</strong>：源文件经过编译器编译成为脚本文件，由解释器逐行解释并执行。灵活性更好。</li>
<li><strong>编译</strong>：源文件经过编译器编译成为可执行文件，由计算机直接去执行。性能更好。</li>
</ul>
<p><strong>静态编译和动态编译</strong></p>
<ul>
<li><strong>静态编译</strong>：编译时确定类型，绑定对象。性能更好。</li>
<li><strong>动态编译</strong>：运行时确定类型，绑定对象。能更好地支持多态，灵活性强。</li>
</ul>
<h3 id="Java-运行原理-1"><a href="#Java-运行原理-1" class="headerlink" title="Java 运行原理"></a>Java 运行原理</h3><p><em><strong>Java 是编译和解释并行的语言，采取动态编译，支持反射机制。</strong></em></p>
<ol>
<li><p>源文件(.java) 经过编译器编译成为 字节码文件(.class) ，通过类加载器搬运到 JVM 中逐行解释并执行。</p>
</li>
<li><p>即时编译器(JIT) 在编译时会识别反复执行的热点代码（超过 10000 次）并保存机器码，复用时可直接由 JVM 执行。</p>
</li>
</ol>
<p><strong>优势</strong>：以虚拟机作为中介，字节码文件可以在所有操作平台上通用。即一次编译、到处运行。</p>
<p><strong>劣势</strong>：但这也导致了 Java 语言性能不如 C/C++ 等编译语言。</p>
<hr>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><p>在 Java 程序里如果使用某个尚未加载到内存中的类，JVM 会通过加载、链接、初始化 3 个步骤来对该类进行初始化。</p>
<p><img src="/pic/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类"></p>
<blockquote>
<p>创建类的实例，访问类的静态变量，或者调用类的静态方法都会导致类的初始化。但要注意对于 final 常量，如果在编译时就可以确定该变量的值，编译器会在编译时直接把这个变量替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。</p>
</blockquote>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p><strong>类的加载由类加载器完成。类加载器会读取类的字节码文件，并为之创建一个 java.lang.Class 对象。</strong></p>
<p>类加载器使用双亲委派模型，类加载器具备一种带有优先级的层次关系：</p>
<ul>
<li>根类加载器：负责加载 Java 的核心类，原生代码实现，并不继承自 java.lang.ClassLoader 类。</li>
<li>扩展类加载器：负责加载 JRE 扩展目录中的类。由 Java 语言实现，没有父类加载器。</li>
<li>系统类加载器：负责加载 CLASSPATH 路径中的类。由 Java 语言实现，父类加载器为扩展类加载器。</li>
<li>用户类加载器：开发者通过继承 ClassLoader 基类来创建的类加载器。由 Java 语言实现，默认父类加载器为系统类加载器。</li>
</ul>
<p>任何类加载器在接到加载类的请求时，都会将加载任务委托给父类加载器，最终委派给处于模型最顶端的根类加载器进行加载。只有父类加载器无法完成此加载任务时，才自己去加载。如果均无法载入类，则抛出 ClassNotFountException 异常。</p>
<ol>
<li>通过这种层级关系可以避免类的重复加载。</li>
<li>其次可以防止核心 API 库被随意篡改，用户即使编写了 java.lang.Object 的同名类，也永远无法被加载运行。</li>
</ol>
<p>【在双亲委派模型中，由父加载类加载的类，下层加载器是不能加载的。用户在 classpath 路径下自定义的java.*包内的类会抛出异常：SecurityException: Prohibited package name】</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><strong>当类被加载并生成 Class 对象后，连接阶段负责把类的二进制数据合并到 JRE 中。</strong></p>
<ul>
<li>验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。</li>
<li>准备：类准备阶段负责为类的静态变量分配内存，并赋予类型的默认值。</li>
<li>解析：将类的二进制数据中的符号引用替换成直接引用，指向具体的内存空间。</li>
</ul>
<p><em>Java 是相对 C++ 语言是安全的语言，验证过程用于确保 Class 文件的字节流符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</em></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>为类的静态变量赋予程序设定的初始值。</strong></p>
]]></content>
      <categories>
        <category>javase</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO</title>
    <url>/2023/05/14/javase/IO/NIO/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h3><ul>
<li><strong>BIO 同步阻塞</strong></li>
</ul>
<p>在服务器和客户端通信的过程中，服务器线程会一直等待请求结果返回，无法处理其他请求。</p>
<ul>
<li><strong>NIO 同步非阻塞</strong></li>
</ul>
<p>在服务器和客户端通信的过程中，服务器线程可以先处理其他请求，定时检查结果是否返回。</p>
<ul>
<li><strong>AIO 异步非阻塞</strong></li>
</ul>
<p>在服务器和客户端通信的过程中，服务器线程可以先处理其他请求，客户端会主动通知服务器返回了结果。</p>
<h3 id="NIO-模式"><a href="#NIO-模式" class="headerlink" title="NIO 模式"></a>NIO 模式</h3><p>BIO 通信通常使用线程池机制实现伪异步：每建立一个连接就创建一个线程，在执行读写操作时该线程将被阻塞，直到数据流读写完成。在高并发情况下会有大量线程被创建并阻塞、CPU 将频繁切换线程，非常消耗计算机资源。</p>
<p>因此 JDK 1.4 引入了 NIO 模型，相关类存储在 java.nio 文件夹内，使用时需要进行导入。NIO 模型中，在执行读写操作时数据会先存入缓冲区，该线程可以先处理其他连接，一定时间后再对缓冲区读取或写出。</p>
<ul>
<li><p><strong>Buffer</strong>：【缓冲区】暂存将要写入或者要读出的数据。</p>
</li>
<li><p><strong>Channel</strong>：【全双工通道】对缓冲区数据读写，在通道内部支持同时读写。</p>
</li>
<li><p><strong>Selector</strong>：【选择器】用于单线程同时管理多个通道，选择器会对多个客户进行轮询，使一个线程可以同时处理多个请求。</p>
</li>
</ul>
<p>JDK 1.7 引入了 AIO 模型，相关类存储在 java.aio 文件夹内。但在 Linux 底层 AIO 实现本质仍为轮询，所以 AIO 相比于 NIO 的性能提升非常有限。目前主流的 IO 模式仍为 NIO 。</p>
<h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><p>Java 提供的 NIO 编程非常复杂，开发工作量和难度巨大。且可能会产生空轮询，导致 CPU 占用率 100% 。</p>
<p>于是我们引入了 Netty 开源框架封装 NIO 通信，是目前主流的使用方式。用于开发高性能高并发的 IO 程序。</p>
<hr>
<h2 id="Netty-1"><a href="#Netty-1" class="headerlink" title="Netty"></a>Netty</h2><h3 id="Netty-框架"><a href="#Netty-框架" class="headerlink" title="Netty 框架"></a>Netty 框架</h3><p>但 NIO 编程复杂自行实现 bug 极多，目前主流的 NIO 通信使用 Netty 开源框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyOioServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">(<span class="type">int</span> port)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.unreleasableBuffer(</span><br><span class="line">                Unpooled.copiedBuffer(<span class="string">&quot;Hi!\r\n&quot;</span>, Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)));</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();        <span class="comment">// 负责连接的池</span></span><br><span class="line"></span><br><span class="line">            b.group(group)                                    <span class="comment">//2</span></span><br><span class="line">             .channel(OioServerSocketChannel.class)</span><br><span class="line">             .localAddress(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;    <span class="comment">// 初始化</span></span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> </span><br><span class="line">                     <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                     ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;            <span class="comment">//4</span></span><br><span class="line">                         <span class="meta">@Override</span></span><br><span class="line">                         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                             ctx.writeAndFlush(buf.duplicate()).addListener(ChannelFutureListener.CLOSE);<span class="comment">//5</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind().sync();  <span class="comment">//6</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully().sync();        <span class="comment">//7</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存空间</title>
    <url>/2023/05/14/javase/JVM/JVM%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>Java 程序中的内存分配和回收都由 JVM 管理，不支持程序员直接对内存地址进行操作。不容易出现内存泄漏和内存溢出问题。</p>
<hr>
<h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>进程是分配资源的基本单位。除方法区外，所有数据均存放在给进程分配的内存块中。</p>
<p>Java 程序的内存空间主要分为以下几个区域：</p>
<p><img src="/pic/%E5%86%85%E5%AD%98.png"></p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>(Method Area) 存放 <strong>Java 程序的二进制代码，即类的信息</strong>。</p>
<p>在虚拟机启动时直接存入系统内存中，大小只受系统内存的限制。</p>
<h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><p>(Heap) 存放进程创建的<strong>对象实例和数组</strong>。</p>
<p>由线程共享，在虚拟机启动时为进程创建，是占用内存最大的区域。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>存放 <strong>final 常量、static 变量和方法，以及 String 和部分包装类型的对象（一经赋值不再改变）</strong>。</p>
<blockquote>
<p>JDK 1.7 后 JVM 将常量池从方法区中移出，改为在堆中开辟空间存放。</p>
</blockquote>
<h3 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h3><p>(Stack) 存放线程执行 Java 方法调用的内存数据。线程每执行一个方法都会创建一个栈帧放入栈区，在方法执行结束后弹出。栈帧中储存局部变量表、操作数栈、动态链接、方法出口信息。其中局部变量表存放<strong>线程和方法的参数、方法中定义的基础类型变量和对象引用</strong>。</p>
<p>由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<p><em>栈区分为虚拟机栈（执行 java 方法）和本地方法栈（执行 native 方法，底层用 C 实现），但在 HotSpot 虚拟机中两者合二为一。</em></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>用来记录线程的运行状态、管理线程的运行。</p>
<ol>
<li><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</p>
</li>
<li><p>在多线程的情况下程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够继续运行。</p>
</li>
</ol>
<p>由线程私有。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p>
<hr>
<h2 id="对象的内存分配"><a href="#对象的内存分配" class="headerlink" title="对象的内存分配"></a>对象的内存分配</h2><h3 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h3><p>Hotspot 虚拟机中，对象在内存中分为 3 块区域：对象头、实例数据和对齐填充。</p>
<ul>
<li>对象头负责记录对象信息，包括对象运行数据（哈希码、GC 分代年龄、锁状态标志等）和 类型指针（对象所属的类）。 </li>
<li>对象起止地址必须是 8 字节整数倍，空余部分将使用对齐填充来补全。</li>
</ul>
<h3 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h3><p>在 Java 中创建对象，需要经过以下过程：</p>
<p><strong>Step 1. 类加载检查</strong></p>
<pre><code>JVM 接收到 new 指令，首先检查该类是否在常量池中，然后检查该类是否已被加载、解析和初始化。

如果没有则先加载类，类加载器会将类的字节码文件放入 JVM 解析。
</code></pre>
<p><strong>Step 2. 分配内存</strong></p>
<pre><code>类加载后，会从 Java 堆中划分一块固定大小的内存区域分配给对象。
</code></pre>
<p><strong>Step 3. 半初始化</strong></p>
<pre><code>内存分配完成后，虚拟机将对象的实例数据都半初始化为默认值。此时对象已经可用。
</code></pre>
<p><strong>Step 4. 设置对象头</strong></p>
<pre><code>初始化内存空间后，虚拟机要对对象进行必要的设置，把信息存放在对象头中。
</code></pre>
<p><strong>Step 5.初始化对象</strong></p>
<pre><code>新的对象已经产生，但所有的字段都为默认值。接下执行 init 方法，将对象的实例数据赋值。
</code></pre>
<p><strong>Step 6. 建立关联</strong></p>
<pre><code>将对象引用指向创建的对象。该对象可以通过引用被使用。
</code></pre>
<p><em>在创建对象的过程中可能会发生指令重排序。如果尚未完全初始化就建立了关联，其他线程读取该对象可能会读取到默认值。</em></p>
<h3 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h3><p>内存划分有以下两种分配方式：</p>
<ul>
<li>指针碰撞：（内存规整时） 已使用内存和未使用内存用指针隔开，需要分配内存时将指针移动一定位置。</li>
<li>空闲列表：（内存不规整时）虚拟机维护一个列表记录空闲内存块，需要分配内存时选择合适的内存块。</li>
</ul>
<p>Java 堆是否规整，取决于垃圾收集算法是否整理内存。</p>
<hr>
<h2 id="常量池内存分配"><a href="#常量池内存分配" class="headerlink" title="常量池内存分配"></a>常量池内存分配</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>String 对象创建后一经赋值不再改变，有以下两种创建方式：</p>
<ol>
<li><p>直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，<strong>引用指向常量池。</strong></p>
</li>
<li><p>构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，<strong>引用指向堆区。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;                       <span class="comment">// 引用指向常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;                  <span class="comment">// 引用指向常量池</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);           <span class="comment">// 引用指向堆区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;                    <span class="comment">// 引用指向堆区</span></span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);             <span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str3);             <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>JVM 将部分常用的包装类型数据提前缓存在常量池中，用户创建该类对象时直接在常量池取用，而不用真正新建对象。</p>
<ul>
<li><p><strong>布尔包装类 Boolean</strong>：将全部缓存数据保存在常量池中。</p>
</li>
<li><p><strong>字符包装类 Character</strong>：将 ASCII 字符(0-127) 数据缓存保存在常量池中。如果是汉字等其他字符仍然会创建对象。</p>
</li>
<li><p><strong>整型包装类 Byte/Short/Integer/Long</strong>：将数值 [-128，127] 内的数据缓存保存在常量池中。但是超出此范围仍然会去创建新的对象。</p>
</li>
<li><p><strong>浮点数类型包装类 Float/Double</strong>： 没有实现常量池技术。</p>
</li>
</ul>
<hr>
<h2 id="内存过载"><a href="#内存过载" class="headerlink" title="内存过载"></a>内存过载</h2><p>随着 Java 程序的使用，所占用和分配的内存将会越来越大。如果 JVM 已无法分配足够的内存，将会抛出 OutOfMemoryError 导致程序崩溃。</p>
<p>同时为了更合理地使用内存，Java 会由虚拟机对堆区内存空间自动进行垃圾回收。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收</title>
    <url>/2023/05/14/javase/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h1><hr>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配，堆区是垃圾收集器管理的主要区域。</p>
<p>开发者使用 System.gc() 方法可以提醒 JVM 进行垃圾回收，但不能强制。</p>
<h3 id="分区回收"><a href="#分区回收" class="headerlink" title="分区回收"></a>分区回收</h3><p>现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>
<ul>
<li>新生代 GC (Minor GC) ：新生代垃圾回收非常频繁，回收速度也比较快。</li>
</ul>
<ul>
<li>老年代 GC (Major GC) ：老年代垃圾回收次数较少，回收速度也明显更慢。</li>
</ul>
<p><img src="/pic/%E5%A0%86.png"></p>
<h3 id="初次分配对象"><a href="#初次分配对象" class="headerlink" title="初次分配对象"></a>初次分配对象</h3><p>新生代分为 eden 区和 survive 区， 其中 eden 区占用内存空间更大。</p>
<p>大多数情况下，对象在新生代 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p>
<h3 id="长期存活对象"><a href="#长期存活对象" class="headerlink" title="长期存活对象"></a>长期存活对象</h3><p>虚拟机给每个对象设置一个年龄计数器。如果对象经过一次 Minor GC 后仍然能够存活，将从 eden 移动到 survive 空间中。对象每熬过一次 Minor GC，年龄就增加 1 岁。当它的年龄增加到一定程度（默认为 15 岁），就会晋升到老年代。</p>
<p>survive 区分为 from 区和 to 区两块大小相等的内存空间。Minor GC 执行时，会将 eden 区和 from 区中的存活对象复制到 to 区，清除 eden 区和 from 区内存。再把这些存活对象从 to 区移动回 from 区。</p>
<p>当老年代也没有足够空间进行分配时，虚拟机将发起一次 Major GC。</p>
<h3 id="大对象"><a href="#大对象" class="headerlink" title="大对象"></a>大对象</h3><p>需要大量连续内存空间的对象（如字符串、数组）直接进入老年代，可以避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM指令重排序</title>
    <url>/2023/05/14/javase/JVM/JVM%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><hr>
<h2 id="指令概念"><a href="#指令概念" class="headerlink" title="指令概念"></a>指令概念</h2><p>指令是指示计算机执行某种操作的命令，如：数据传送指令、算术运算指令、位运算指令、程序流程控制指令、串操作指令、处理器控制指令。指令不同于我们所写的代码，一行代码按照操作的逻辑可以分成多条指令。</p>
<p>举个例子：int a = 1;  这段代码大致可以分为两条指令：1.加载常量1；2.将常量1赋值给变量a。</p>
<h2 id="指令重排序-1"><a href="#指令重排序-1" class="headerlink" title="指令重排序"></a>指令重排序</h2><p>只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。</p>
<p>指令重排序的意义：使指令更加符合 CPU 的执行特性，最大限度的发挥机器的性能，提高程序的执行效率。</p>
<h3 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h3><p>指令重排序主要分为三种，在这里主要讨论 JVM 中的指令重排序。</p>
<ol>
<li>编译器重排序：JVM 中完成</li>
<li>指令级并行重排序</li>
<li>处理器重排序：CPU 中完成</li>
</ol>
<h3 id="指令重排序原则"><a href="#指令重排序原则" class="headerlink" title="指令重排序原则"></a>指令重排序原则</h3><p>如果程序中操作A在操作B之前，那么线程中操作A将在操作B之前执行。（只对指令内部重排序，不在指令间重排序）</p>
<ul>
<li><strong>As-If-Serial语义</strong></li>
</ul>
<p>不管怎么进行指令重排序，单线程内程序的执行结果不能被改变。</p>
<p>编译器和处理器对存在依赖关系的操作都不会对其进行重排序。只有不存在依赖关系的操作有可能进行重排序。</p>
<p><strong>Happens-Before原则</strong></p>
<p>保证正确同步的多线程程序的执行结果不被改变。</p>
<p>对于被同步的操作，如果操作 A 先于操作 B，那么 A 操作的执行结果将对 B 操作可见，而且 A 操作的执行顺序排在 B 操作之前。</p>
<p>管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。<br>（如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程））</p>
<h2 id="防止指令重排序"><a href="#防止指令重排序" class="headerlink" title="防止指令重排序"></a>防止指令重排序</h2><p>volatile关键字通过“内存屏障”来防止指令被重排序。</p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>Java内存模型采取保守策略（见缝就插）</p>
<p>在每个volatile写操作的前面插入一个StoreStore屏障。<br>在每个volatile写操作的后面插入一个StoreLoad屏障。<br>在每个volatile读操作的后面插入一个LoadLoad屏障。<br>在每个volatile读操作的后面插入一个LoadStore屏障。</p>
<p>Synchronized 把多线程执行环境改变为单线程执行环境，无需关心指令重排序（单线程执行结果不会改变）。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><hr>
<h2 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h2><h3 id="Throwable-类"><a href="#Throwable-类" class="headerlink" title="Throwable 类"></a>Throwable 类</h3><p>Java 程序中的异常是一个在程序执行期间发生的事件，它中断正在执行程序的正常指令流。为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
<p>java 程序中所有的异常都继承自 Throwable 类，Throwable 类有两个子类 Error 类和 Exception 类：</p>
<ul>
<li><p><strong>Error 类</strong>：【错误】表示 java 程序在运行时产生的无法处理的故障（如堆栈溢出），错误出现时会导致程序无法正常执行并强制退出。</p>
</li>
<li><p><strong>Exception 类</strong>：【异常】表示 java 程序中产生的可以被处理的故障，异常出现时可以由程序进行处理。</p>
</li>
</ul>
<p><img src="/pic/exception.png" alt="Throwable"></p>
<h3 id="RuntimeException-类"><a href="#RuntimeException-类" class="headerlink" title="RuntimeException 类"></a>RuntimeException 类</h3><p>【运行时异常】 Exception 类的子类。</p>
<p>表示 java 程序运行状态中发生的异常，在编译时无法被检测。在 java 程序运行时会由系统自动抛出，允许应用程序不进行处理。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ArithmeticException</td>
<td>算术异常，以零做除数</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundException</td>
<td>数组越界异常</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>空指针异常，对象不存在</td>
</tr>
</tbody></table>
<h3 id="Checked-Exception-类"><a href="#Checked-Exception-类" class="headerlink" title="Checked Exception 类"></a>Checked Exception 类</h3><p>【可检查异常】Exception 类除 RuntimeException 以外其他子类的统称。</p>
<p>表示 java 程序编译时检测到的异常。出现时必须在程序中进行捕获或抛出，否则编译不会通过。</p>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>介绍</th>
</tr>
</thead>
<tbody><tr>
<td>IOException</td>
<td>IO 异常</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>找不到文件异常，继承自 IO 异常</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>找不到类异常</td>
</tr>
</tbody></table>
<hr>
<h2 id="Exception-类"><a href="#Exception-类" class="headerlink" title="Exception 类"></a>Exception 类</h2><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>状态信息</strong></p>
<p>Throwable / Exception 类是有状态的（因此 Throwable 是接口而不能是类），记录了四个信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object backtrace;                          <span class="comment">// 栈的回溯点</span></span><br><span class="line"><span class="keyword">private</span> String detailMessage;                                <span class="comment">// 异常的信息：在创建异常时备注</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> <span class="built_in">this</span>;                              <span class="comment">// 异常的原因：导致该异常的异常，默认为自身</span></span><br><span class="line"><span class="keyword">private</span> StackTraceElement[] stackTrace = UNASSIGNED_STACK;   <span class="comment">// 异常的发生顺序：以栈的形式存储</span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<p>Throwable / Exception 类含有四个构造方法，在创建时可以记录异常信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>();                           <span class="comment">// 默认</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>);                  <span class="comment">// 记录异常信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(e);                          <span class="comment">// 记录异常原因</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;message&quot;</span>, e);               <span class="comment">// 记录详细信息和异常原因</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法</strong></p>
<p>Throwable / Exception 类定义了多种常用方法用于获取异常数据，常用的有：</p>
<ul>
<li>getMessage 方法：获取异常的信息。</li>
<li>getStackTrace 方法：获取的异常发生顺序。</li>
<li>printStackTrace 方法：获取异常的发生顺序并打印（开发和调试阶段用来显示异常信息，帮助开发者找出错误）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    e.printStacTrace();                           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>我们也可以通过继承并重写 Exception / RuntimeException 类的方式，自定义异常类并使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义异常，重写方法可任选</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message,cause);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常转译"><a href="#异常转译" class="headerlink" title="异常转译"></a>异常转译</h3><p>在项目开发过程中，当 Sevice/DAO 层出现如 SQLException 异常时，程序一般不会把底层的异常传到 controller 层。程序可以捕获原始异常，然后再抛出一个新的业务异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;SQL Error&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="抛出异常-throw"><a href="#抛出异常-throw" class="headerlink" title="抛出异常 throw"></a>抛出异常 throw</h3><p>当方法执行出现问题时，方法就会创建异常对象并抛出。开发者可以在程序中自行抛出异常；JVM 在执行程序时发现问题也会自动抛出异常。</p>
<ul>
<li><p><strong>throw 语句</strong>：开发者自行创建异常对象并抛出，等待程序进行异常处理。</p>
</li>
<li><p><strong>throws 语句</strong>：声明方法可能抛出某种异常且未经处理，调用该方法的上级需要进行异常处理。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;       </span><br><span class="line">    <span class="comment">// 把方法中的抛出异常交给上层处理     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> IndexOutOfBoundsException, IOException&#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 用户自定义异常并抛出</span></span><br><span class="line">        <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 虚拟机自动发现异常也会抛出，必须出现在 try 代码块中</span></span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(txt));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="捕获异常-catch"><a href="#捕获异常-catch" class="headerlink" title="捕获异常 catch"></a>捕获异常 catch</h3><p>当方法执行抛出异常时，必须由专门的代码块对异常进行处理。</p>
<ul>
<li><p><strong>try 语句</strong>：可能出现异常的代码块。</p>
</li>
<li><p><strong>catch 语句</strong>：捕获相应异常后停止执行 try 代码，转而执行对应 catch 代码。如果没有异常 catch 代码不会执行。</p>
</li>
<li><p><strong>finally 语句</strong>：无论是否发生异常，finally 代码总会被执行。一般用于释放资源。</p>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ol>
<li><p>如果 try 语句中出现的异常未被 catch，默认将异常 throw 给上层调用者处理。但必须在方法中声明 throws。</p>
</li>
<li><p>try/catch 代码中的 return 语句会在执行完 finally 后再返回，但 finally 中对返回变量的改变不会影响最终的返回结果。</p>
</li>
<li><p>finally 代码中应避免含有 return 语句或抛出异常，否则只会执行 finally 中的 return 语句，且不会向上级抛出异常。</p>
</li>
</ol>
<p><em>Java 7 后在 try 语句中打开 IO 流，会在跳出后自动关闭流。不必再用 finally 语句关闭。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestException</span>&#123;               </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeList</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(size &lt; <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;至少要输出1个字符&quot;</span>);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;OutFile.txt&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                System.out.println(<span class="string">&quot;Value at: &quot;</span> + i + <span class="string">&quot; = &quot;</span> + list.get(i));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IndexOutOfBoundsException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Caught IOException: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>) out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<!--

**异常处理类**

在 Spring Boot 中，所有异常统一由专门的异常处理类`@ControllerAdvice`处理。

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//控制器异常处理类</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> org.slf4j.<span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ErrorHandler.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入参数校验异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NotValidExceptionHandler</span><span class="params">(HttpServletRequest req, MethodArgumentNotValidException e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//rfc4918 - 11.2. 422: Unprocessable Entity          </span></span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> MiscUtil.getValidateError(bindingResult);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.UNPROCESSABLE_ENTITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//404异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NoHandlerFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">NoHandlerFoundExceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">404</span>, <span class="string">&quot;页面不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//其他默认异常处理</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Result&gt; <span class="title function_">defaultHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                </span><br><span class="line">        <span class="type">Result</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">500</span>, <span class="string">&quot;服务器内部错误&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;异常详情&quot;</span>, e);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;Result&gt;(res, HttpStatus.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>–&gt;</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>数据比较</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%80%BC%E6%AF%94%E8%BE%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数值比较和排序的常用方法"><a href="#数值比较和排序的常用方法" class="headerlink" title="数值比较和排序的常用方法"></a>数值比较和排序的常用方法</h1><hr>
<h2 id="等值判断"><a href="#等值判断" class="headerlink" title="等值判断"></a>等值判断</h2><p>Object 类实现了 equals 方法 ，用于比较两个数据元素是否相等。</p>
<p>浮点类型由于精度丢失问题，进行等值判断常出现错误。如果有需求推荐使用 <a href="/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?id=bigdecimal-%E7%B1%BB">BigDecimal 类</a>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20</span> - <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(a.equals(b));         <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">20.0</span> - <span class="number">10.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line">System.out.println(a.equals(b));         <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="和 == 的区别"></a>和 == 的区别</h3><ol>
<li>对于基本类型，两者等价：判断数据是否相等。</li>
<li>对于对象（如 String 类）：</li>
</ol>
<ul>
<li>**==**：比较两个元素内存地址是否相等，即是否是同一个元素。</li>
<li><strong>equals 方法</strong>：比较两个元素内容是否一致。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(s1 == s2);                 <span class="comment">// 判断两个引用指向的内存地址是否相等  </span></span><br><span class="line">System.out.println(s1.equals(s2));            <span class="comment">// 判断两个引用指向的内存地址是否相等（s1 为空抛出空指针异常）</span></span><br><span class="line">System.out.println(Objects.equals(s1,s2));    <span class="comment">// 判断两个引用指向的元素是否一致（推荐）</span></span><br></pre></td></tr></table></figure>

<h3 id="重写-equals-方法"><a href="#重写-equals-方法" class="headerlink" title="重写 equals 方法"></a>重写 equals 方法</h3><p>对于用户自定义类，正常使用 equals 方法需要进行重写。<strong>重写 equals 方法必须重写 hashcode 方法</strong>：以保证相同对象拥有相同的哈希地址。这样才能正常地把该类对象放入 HashSet/HashMap 等集合框架中查找。</p>
<p><em>Object 类的 hashcode 方法是本地方法（底层用 c/c++ 实现），直接返回对象的内存地址。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">int</span> ID;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">other</span> <span class="operator">=</span> (User) obj;</span><br><span class="line">            <span class="keyword">if</span>(equals(<span class="built_in">this</span>.ID, other.ID) &amp;&amp; equals(<span class="built_in">this</span>.name, other.name))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + (ID == <span class="literal">null</span> ? <span class="number">0</span> : ID.hashCode());</span><br><span class="line">        result = <span class="number">31</span> * result + (name == <span class="literal">null</span> ? <span class="number">0</span> : name.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h2><p>Comparator 接口和 Comparable 接口都用于比较两个元素的大小：</p>
<ol>
<li><p>Comparable 接口位于 java.lang 包内，定义在要比较的实体类内部：包含 compareTo 方法。</p>
</li>
<li><p>Comparator 接口位于 java.util 包内，实现在类的外部：包含 compare 方法和 equals 方法。</p>
</li>
</ol>
<p><em>Comparator 接口的 equals 方法和 Object 类的 equals 方法不同， Object 类的 equals 方法实现在实体类的内部。</em></p>
<h3 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo 方法"></a>compareTo 方法</h3><p>Java 自带数据类型均已实现 Comparable 接口并重写 compareTo 方法，默认情况下</p>
<ul>
<li>如果 s1 等于 s2，则返回 0；</li>
<li>如果 s1 小于 s2，则返回小于 0 的值；</li>
<li>如果 s1 大于 s2，则返回大于 0 的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">90</span>;</span><br><span class="line">System.out.println(s1.compareTo(s2));        </span><br></pre></td></tr></table></figure>

<h3 id="compare-方法"><a href="#compare-方法" class="headerlink" title="compare 方法"></a>compare 方法</h3><p>Arrays/Collections 类定义了 sort 方法对数组或者集合元素进行排列，数值的比较通过调用 Comparator 接口的 compare 方法实现。</p>
<p>执行 sort 方法时如果没有重写 compare 方法，默认调用的 compare 方法将会直接调用数据类型的 compareTo 方法，使数据从小到大排列。如果是自定义数据类型且未实现 compareTo 方法，则必须重写 compare 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students);                      <span class="comment">// 对数组排序</span></span><br><span class="line">Collections.sort(students);                 <span class="comment">// 对集合元素排序</span></span><br></pre></td></tr></table></figure>


<p>开发者可以通过重写 compare 方法，实现自定义排列顺序。但要注意，如果数组中保存的是基础类型数据则无法自定义排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;          </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">	    <span class="keyword">return</span> s1.getID() - s2.getID();</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Collections.sort(students, (s1, s2) -&gt;  s1.getID() - s2.getID());     <span class="comment">// 使用 Lamdba 表达式简写</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h2><p>Arrays/Collections 类定义了 sort 方法对数组或者集合元素进行排列，数值的比较通过调用 Comparator 接口的 compare 方法实现。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><hr>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="基本类型-1"><a href="#基本类型-1" class="headerlink" title="基本类型"></a>基本类型</h3><p>Java 语言提供了八种基本类型，用户无需定义也可以直接使用。其数据保存在相应的方法栈中。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>字节数</th>
<th>默认值</th>
<th>包装数据类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
<td>0</td>
<td>Byte</td>
<td></td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>0</td>
<td>Short</td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0</td>
<td>Long</td>
<td></td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
<td>数字后加f</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0</td>
<td>Double</td>
<td></td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>null</td>
<td>Character</td>
<td>必须用单引号</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>false</td>
<td>Boolean</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>布尔型</strong></li>
</ul>
<p>boolean 类型只含有两个值：true 和 false。字节存储为 11111111 和 00000000 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;      </span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;   </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字符型</strong></li>
</ul>
<p>char 类型使用单引号来表示字符。因为 Java 统一采用 unicode 编码，2 字节可以表示一字符。char 类型同样可以用十六进制码保存汉字等特殊字符：’\u0000’ - ‘\uffff’。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;      </span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27;/u3089&#x27;</span>;   </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>整型和浮点型</strong></li>
</ul>
<p>Java 没有无符号类型，所有数据都有符号。</p>
<ol>
<li><p>整型(byte/short/int/long) 用来表示整型数据。</p>
</li>
<li><p>浮点型(float/double) 用来表示浮点数据，实际以指数形式存储，所以和实际值之间有偏差。</p>
</li>
</ol>
<ul>
<li><p>为 float 类型赋值必须在数字后加 f，否则数字默认被识别为 double 类型，会导致赋值出错。</p>
</li>
<li><p>数字基本类型都包含最大最小值常量，如 <code>Integer.MAX_VALUE</code> 和 <code>Integer.MIN_VALUE</code> .</p>
</li>
<li><p>在浮点型有三个特殊数值表示溢出和出错：</p>
<ul>
<li><code>POSITIVE_INFINITY</code> ：正无穷大，正数除以 0 可以得到。</li>
<li><code>NEGATIVE_INFINITY</code> ：负无穷大，负数除以 0 可以得到。</li>
<li><code>NaN</code> ：非数，零除以 0 可以得到。（两个 NAN 值也不相等）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> Long.MAX_VALUE;               </span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> POSITIVE_INFINITY;</span><br></pre></td></tr></table></figure>

<h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>均继承自 Number 抽象类，把基本类型数据封装成对象。基本类型和包装类型之间会自动进行转化。</p>
<ul>
<li><strong>基本类型</strong>（如int），是一个值。允许不赋初值，系统自动添加默认值。</li>
<li><strong>包装类型</strong>（如Integer），是一个对象。<strong>实例化必须赋初值，且赋值后不能改变(final)。</strong></li>
</ul>
<p>包装类型主要用于集合框架中的元素。但阿里巴巴要求所有实体类(POJO) 属性、远程过程调用方法(RPC) 的返回值和参数都必须使用包装数据类型。以此来提醒使用者在需要使用时，必须显式地进行赋值。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><img src="/pic/%E8%BD%AC%E6%8D%A2.png"></p>
<p>对于基础类型：</p>
<ul>
<li><p>按上图顺序可以自动进行类型转换。但整型转化为浮点型时，如果数据过大可能会导致数据丢失精度。</p>
</li>
<li><p>反之则必须进行强制类型转换。但务必小心，超出范围可能会产生意想不到的错误。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&#x27;x&#x27;</span>;                  <span class="comment">// 自动转换</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>)<span class="number">60</span>;            <span class="comment">// 强制转换</span></span><br></pre></td></tr></table></figure>

<p>但是包装类型之间的转换，需要使用特殊的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> l.intValue();</span><br><span class="line"><span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> i.longValue();</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="Array-类"><a href="#Array-类" class="headerlink" title="Array 类"></a>Array 类</h3><p>数据的集合。本质是一个对象，数据存储在堆区，由引用指向数组首个元素的地址。</p>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><p>创建数组时，必须确定数组长度和类型。但如果储存的是基本类型，允许不赋初值（使用默认值）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];                    <span class="comment">// 方法一</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;                     <span class="comment">// 方法二</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;            <span class="comment">// 方法三</span></span><br></pre></td></tr></table></figure>

<p><strong>数组长度</strong>：在数组对象中，定义了 length 属性记录了数组长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;                      <span class="comment">// 返回数组长度  </span></span><br></pre></td></tr></table></figure>


<h3 id="Arrays-类"><a href="#Arrays-类" class="headerlink" title="Arrays 类"></a>Arrays 类</h3><p>对数组进行操作的辅助类，实现了对数组的常用操作。</p>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p><strong>sort 方法</strong>：可以对数组排序，默认数组数值从小到大排列，用户可以自定义排列顺序，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(arr);                                     <span class="comment">// 数组排序</span></span><br></pre></td></tr></table></figure>

<h4 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h4><p><strong>copyOf/copyOfRange 方法</strong>：复制数组。底层调用 System.arrayCopy 的本地方法实现，常用于数组扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">10</span>);                  <span class="comment">// 复制数组：前 10 个单位</span></span><br><span class="line"><span class="type">int</span>[] arr2 = Arrays.copyOf(arr, <span class="number">0</span>, arr.length);       <span class="comment">// 复制数组：从 0 到 arr.length - 1</span></span><br></pre></td></tr></table></figure>

<h4 id="数组转化"><a href="#数组转化" class="headerlink" title="数组转化"></a>数组转化</h4><p><strong>asList 方法</strong>：将数组转化为列表（List 类），但数组数据必须是包装类型。</p>
<p>调用该方法将数组转换为列表后，在内存中实际还是以数组形式存储。这可能会导致以下两个问题：</p>
<ol>
<li>调用 List 类的 add 方法向列表中插入数据，会导致异常；</li>
<li>对原数组进行更改，也会导致列表中的数据发生变化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;                    <span class="comment">// 数组必须是包装数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);                       <span class="comment">// 将数组转换为集合（有问题）               </span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(arr));      <span class="comment">// 将数组转换为集合（推荐）  </span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h3><p>保存字符串。String 类本质是一个 final 对象，由引用指向存储字符串对象的地址。引用虽然可变，但内存数据不能被更改。</p>
<h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><p>String 对象创建后一经赋值不再改变，有以下两种创建方式：</p>
<ol>
<li><p>直接赋值：如果常量池没有，则在常量池新建对象。否则直接使用常量池中已有对象，<strong>引用指向常量池。</strong></p>
</li>
<li><p>构造方法：如果常量池没有，则在常量池新建对象。无论如何一定会在堆区创建对象，<strong>引用指向堆区。</strong></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;                       <span class="comment">// 引用指向常量池</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;                  <span class="comment">// 引用指向常量池（指向 str1 的字符串对象）</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);           <span class="comment">// 引用指向堆区（在堆区新建字符串对象）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;                    <span class="comment">// 引用指向堆区</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str.getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;GBK&quot;</span>);          <span class="comment">// 获取指定类型编码对象，按指定类型编码</span></span><br></pre></td></tr></table></figure>

<p>String 对象创建后一经赋值不再改变。对字符串数据进行改变，实际是创建新的 String 对象，并改变引用指向新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&quot;goodbye&quot;</span>;                             <span class="comment">// str1 指向新的字符串对象</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();                   <span class="comment">// 返回字符串长度</span></span><br><span class="line"></span><br><span class="line">String[] strs = str.split(<span class="string">&quot;,&quot;</span>);           <span class="comment">// 按分隔符分解字符串</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> str.contains(str2);           <span class="comment">// 判断是否存在子字符串</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(str2);            <span class="comment">// 查找子字符串出现的第一个位置，没有返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.lastIndexOf(str2);        <span class="comment">// 查找子字符串出现的最后一个位置，没有返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.trim();                 <span class="comment">// 去除字符串左右空格　　</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.substring(<span class="number">0</span>,<span class="number">3</span>);         <span class="comment">// 截取指定位置（0-2）的子字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);      <span class="comment">// 新字符 a 替换旧字符 b</span></span><br></pre></td></tr></table></figure>

<h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number &gt; String</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> data.toString();              <span class="comment">// data 必须为包装数据类型</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Integer.toString(data);       <span class="comment">// data 可以为基础数据类型，包括字符数组 char[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> String.valueOf(data);         <span class="comment">// data 可以为基础数据类型，包括字符数组 char[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String &gt; char</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line"><span class="type">char</span>[] ch = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// String &gt; int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> Integer.parseInt(str);          </span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Integer.valueOf(str);</span><br></pre></td></tr></table></figure>


<h3 id="StringBuilder-StringBuffer-类"><a href="#StringBuilder-StringBuffer-类" class="headerlink" title="StringBuilder / StringBuffer 类"></a>StringBuilder / StringBuffer 类</h3><p>由于 String 类不可变性，对其频繁更改往往会产生较多临时变量类，占用大量内存。对此我们通常使用 StringBuilder/StringBuffer 来避免，这两个类允许在原有内存地址对字符串进行操作。其中 StringBuilder 类性能更好，StringBuffer 类线程安全。</p>
<h4 id="创建字符串-1"><a href="#创建字符串-1" class="headerlink" title="创建字符串"></a>创建字符串</h4><p>必须通过构造方法创建，不可以直接赋值的形式创建：<del><code>StringBuffer str = &quot;hello&quot;;</code></del>。</p>
<p>字符串默认长度为16，超出后会进行自动扩容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>将 StringBuilder / StringBuffer 类转化为 String 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.toString();    </span><br></pre></td></tr></table></figure>

<h4 id="专用方法"><a href="#专用方法" class="headerlink" title="专用方法"></a>专用方法</h4><p>StringBuilder / StringBuffer 类可以使用 String 类的全部方法，还新增了以下方法直接对字符串进行修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str.append(<span class="string">&quot;add&quot;</span>);                 <span class="comment">// 末尾添加字符串，也可以是其他基础类型</span></span><br><span class="line">str.insert(<span class="number">0</span>,<span class="string">&quot;insert&quot;</span>);            <span class="comment">// 指定位置插入字符串，也可以是其他基础类型</span></span><br><span class="line">str.deleteCharAt(<span class="number">6</span>);               <span class="comment">// 删除指定位置（6）的字符</span></span><br><span class="line">str.delete(<span class="number">6</span>,<span class="number">8</span>);                   <span class="comment">// 删除指定位置（6和7）的字符串</span></span><br><span class="line">str.reverse(str2);                 <span class="comment">// 翻转字符串</span></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>在 Java 程序中，我们可能会用到一些数值特别巨大、或者小数特别精确的数值，这些数值无法用基础类型表示。因此我们定义了 BigInteger/BigDecimal 类来保存这类数据，实际是以字符串形式在堆区存储。</p>
<h3 id="BigInteger-类"><a href="#BigInteger-类" class="headerlink" title="BigInteger 类"></a>BigInteger 类</h3><p>主要用来操作比 long 类型更大的整型数字。</p>
<h3 id="BigDecimal-类"><a href="#BigDecimal-类" class="headerlink" title="BigDecimal 类"></a>BigDecimal 类</h3><p>基于 BigInteger 类实现。由于基本浮点数类型(float/double) 会产生精度丢失问题，因此常使用 BigDecimal 类代替。涉及金额必须使用该类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0f</span>;                           <span class="comment">// 约等于 0.1</span></span><br><span class="line"><span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a == b);               <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.0&quot;</span>);     <span class="comment">// 等于 0.1</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">y</span> <span class="operator">=</span> b.subtract(c);</span><br><span class="line">System.out.println(x.equals(y));          <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="BigInteger-和-BigDecimal-类常用方法"><a href="#BigInteger-和-BigDecimal-类常用方法" class="headerlink" title="BigInteger 和 BigDecimal 类常用方法"></a>BigInteger 和 BigDecimal 类常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.add(b);                  <span class="comment">// 加</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.subtract(b);             <span class="comment">// 减</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.multiply(b);             <span class="comment">// 乘</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.divide(b);               <span class="comment">// 除</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> a.abs();                   <span class="comment">// 绝对值</span></span><br><span class="line">a.compareTo(b);                           <span class="comment">// 比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigDecimal 类专用</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">x</span> <span class="operator">=</span> y.setScale(<span class="number">3</span>, rules);      <span class="comment">// 设置精度和保留规则</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><p>（JDK 1.5 新增）比 Class 类多了部分特殊约束的特殊类型，能更加简洁地定义常量。</p>
<p>使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</p>
<blockquote>
<p>自定义枚举类实际是继承 Enum 类的 final 类，在类中将自定义该类型的 public static final 属性，并引入了相关方法。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Day</span> &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Day today)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(today == Day.MONDAY) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> teturn <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>
<p><em>实际开发中，枚举类通常的形式是有两个参数（int code，Sring msg）的构造器，可以作为状态码进行返回。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StatusCodeEnum</span>&#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">200</span>,<span class="string">&quot;成功&quot;</span>), NOTFOUND(<span class="number">404</span>,<span class="string">&quot;未找到&quot;</span>), ERROR(<span class="number">500</span>,<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据常量自动构造</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">StatusCodeEnum</span><span class="params">(<span class="type">int</span> code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PinType&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;code=&quot;</span> + code +</span><br><span class="line">                <span class="string">&quot;, message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据常量自动构造对象并调用方法</p>
<p><code>System.out.println(StatusCodeEnum.SUCCESS.getCode());</code></p>
<hr>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>在日常 Java 开发中，我们最常使用 Long 类型，而不是 Date/Timestamp 类型表示时间。</p>
<p>我们可以通过 System.currentTimeMillis 方法获取当前系统时间，默认为 13 位的数字（精确到 ms）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">timestamp1</span> <span class="operator">=</span> System.currentTimeMillis();                 <span class="comment">// 13 位 精确到 ms</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">timestamp2</span> <span class="operator">=</span> (System.currentTimeMillis()) / <span class="number">1000</span>;        <span class="comment">// 10 位 精确到 s</span></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型定义"><a href="#泛型定义" class="headerlink" title="泛型定义"></a>泛型定义</h3><p>定义类时并不固定数据类型，等到创建对象或调用方法时再明确数据类型。</p>
<p><a href="javase/JVM/JVM%E4%BB%8B%E7%BB%8D?id=java-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86">编译</a>过程中，由编译器检查类型安全，自动隐性地对类的数据类型进行强制转换（Object -&gt; 指定数据类型）。编译后生成的 字节码文件(.class) 将不再含有泛型。</p>
<h3 id="泛型使用"><a href="#泛型使用" class="headerlink" title="泛型使用"></a>泛型使用</h3><p>可使用 A-Z 之间的任何一个字母，常用：</p>
<ul>
<li>T (type)： 表示具体的一个 java 类型</li>
<li>K V (key value)： 分别代表 java 键值中的 Key Value</li>
<li>E (element)： 代表 java 集合框架元素</li>
<li>？：表示不确定的 java 类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义时使用泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时明确类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Box&lt;Integer&gt; myBox = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br><span class="line">        myBox.set(<span class="number">3</span>);</span><br><span class="line">        System.out.print(myBox.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>方法调用</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h1><hr>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><strong>值传递</strong>：在 Java 方法中传递参数，形参本质是实参的副本。</p>
<ol>
<li>参数是基础数据类型：对形参的改变不会影响实参。</li>
<li>参数是指向对象的引用（包括数组、字符串）：对对象数据进行更改会影响实参，但改变引用指向的对象不会影响实参。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        test(i, arr);</span><br><span class="line">        System.out.print(i);            <span class="comment">// 输出为 0</span></span><br><span class="line">        System.out.print(arr[<span class="number">0</span>]);       <span class="comment">// 输出为 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        i++;                            <span class="comment">// 实参不改变</span></span><br><span class="line">        arr[<span class="number">0</span>]++;                       <span class="comment">// 实参指向的对象改变</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>&#125;;             <span class="comment">// 实参不改变</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>JDK 1.8 新增。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>正则匹配</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li><strong>Pattern 类</strong></li>
</ul>
<p>正则表达式的编译表示。没有公共构造方法，必须首先调用其公共静态编译方法获得 Pattern 对象。</p>
<ul>
<li><strong>Matcher 类</strong></li>
</ul>
<p>对输入字符串进行解释和匹配操作的引擎。没有公共构造方法，需要调用 Pattern 对象的 matcher 方法获得 Matcher 对象。</p>
<ul>
<li><strong>PatternSyntaxException 类</strong></li>
</ul>
<p>非强制异常类，表示正则表达式模式中的语法错误。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexMatches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span> &#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;abc&quot;</span>);        <span class="comment">// 编译正则表达式</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;abcdefg&quot;</span>);    <span class="comment">// 放入字符串中匹配</span></span><br><span class="line"></span><br><span class="line">        System.out.println(matcher.lookingAt());   <span class="comment">// 是否存在子串匹配 true</span></span><br><span class="line">        System.out.println(matcher.matches());     <span class="comment">// 是否完全匹配 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>我们可以通过使用特殊符号，让一个正则表达式能够匹配多种符合要求的字符串。</p>
<h3 id="表意符号"><a href="#表意符号" class="headerlink" title="表意符号"></a>表意符号</h3><ul>
<li><code>.</code> 表示任意字符</li>
</ul>
<p>在 Java 中，正则表达式编译需要再经过一次转义。因此 <code>\\</code> 才表示插入一个正则表达式的反斜线！</p>
<ul>
<li><code>\\d</code> 表示一位数字</li>
<li><code>\\\\</code> 表示一个反斜杠</li>
</ul>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><ul>
<li><code>x|y</code> 匹配 x 或 y</li>
<li><code>[abc]</code>    匹配括号中任意单个字符</li>
<li><code>[^abc]</code>    匹配除括号中的任意单个字符</li>
<li><code>[a-zA-Z]</code> 匹配任意单个字母</li>
<li><code>[a-z&amp;&amp;[^def]]</code> 除 def 外的任意单个字母</li>
</ul>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p>通过 <code>?</code>、<code>*</code>、<code>+</code> 符号，我们可以对指定类型的字符串进行匹配。</p>
<table>
<thead>
<tr>
<th>贪婪模式</th>
<th>饥饿模式</th>
<th>独占模式</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>X?</td>
<td>X??</td>
<td>X?+</td>
<td>匹配0或1次</td>
</tr>
<tr>
<td>X*</td>
<td>X*?</td>
<td>X*+</td>
<td>匹配0次或多次</td>
</tr>
<tr>
<td>X+</td>
<td>X+?</td>
<td>X++</td>
<td>匹配1次或多次</td>
</tr>
<tr>
<td>X{n}</td>
<td>X{n}?</td>
<td>X{n}+</td>
<td>匹配n次</td>
</tr>
<tr>
<td>X{m,n}</td>
<td>X{m,n}?</td>
<td>X{m,n}+</td>
<td>匹配m-n次</td>
</tr>
</tbody></table>
<p>在匹配字符串时，同一个正则表达式可能会在在字符串中匹配到多种结果。Java 提供了以下三种方式供开发者选择：</p>
<ul>
<li><strong>贪婪模式</strong> （默认）尽可能匹配长字符串。</li>
<li><strong>饥饿模式</strong> （?）尽可能匹配短字符串。</li>
<li><strong>独占模式</strong> （+）尽可能匹配长字符串，不成功会结束匹配而不回溯。</li>
</ul>
<hr>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><h3 id="普通捕获组"><a href="#普通捕获组" class="headerlink" title="普通捕获组"></a>普通捕获组</h3><p>我们可以在正则表达式中同时捕获多个结果，最终以 group 的形式呈现。</p>
<ul>
<li>matcher.group(0) 完全匹配整个正则表达式。</li>
<li>matcher.group(1-n) 从左到右分别记录正则表达式中 n 个括号内的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexMatches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\\d&#123;4&#125;)-((\\d&#123;2&#125;)-(\\d&#123;2&#125;))&quot;</span>     </span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);                <span class="comment">// 编译正则表达式</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;2020-10-25&quot;</span>);         <span class="comment">// 放入字符串</span></span><br><span class="line"></span><br><span class="line">        matcher.find();                      <span class="comment">// 执行匹配</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="number">0</span>)); <span class="comment">// 2020-10-25</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="number">1</span>)); <span class="comment">// 2020</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="number">2</span>)); <span class="comment">// 10-25</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="number">3</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="number">4</span>)); <span class="comment">// 25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命名捕获组"><a href="#命名捕获组" class="headerlink" title="命名捕获组"></a>命名捕获组</h3><p>我们可以通过 <code>(?&lt;Name&gt;Expression)</code> 对括号内容就行命名，并通过名称获取括号内的匹配结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexMatches</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String args[] )</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;md&gt;(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;date&gt;\\d&#123;2&#125;))&quot;</span>; </span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">p</span> <span class="operator">=</span> Pattern.compile(regex);                 <span class="comment">// 编译正则表达式</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> p.matcher(<span class="string">&quot;2020-10-25&quot;</span>);          <span class="comment">// 放入字符串中匹配</span></span><br><span class="line"></span><br><span class="line">        matcher.find();                            <span class="comment">// 执行匹配</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="string">&quot;year&quot;</span>));  <span class="comment">// 2020</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="string">&quot;md&quot;</span>));    <span class="comment">// 10-25</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="string">&quot;month&quot;</span>)); <span class="comment">// 10</span></span><br><span class="line">        System.out.printf(matcher.group(<span class="string">&quot;date&quot;</span>));  <span class="comment">// 25</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h3><p>我们可以通过 <code>(?:Expression)</code> 对组不进行捕获。</p>
<ul>
<li><code>(?=pattern)</code></li>
</ul>
<p>例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows 2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。</p>
<p>预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p>
<ul>
<li><code>(?!pattern)</code></li>
</ul>
<p>如 ‘Windows (?!95|98|NT|2000)’ 匹配”Windows 3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。</p>
<p>预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</p>
<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2>]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>类和接口</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><hr>
<h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h2><p>java 是面向对象的语言：对象包含了状态和行为，用户通过调用对象的方法、改变对象的属性来实现 java 程序的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&quot;BMW&quot;</span>);                          <span class="comment">// 创建对象       </span></span><br><span class="line">me.brand = <span class="string">&quot;Benz&quot;</span>;                                   <span class="comment">// 修改对象变量                   </span></span><br><span class="line">me.go(<span class="string">&quot;London&quot;</span>);                                     <span class="comment">// 调用对象方法</span></span><br></pre></td></tr></table></figure>


<p>在 java 程序中我们通过类和接口来定义对象的性质：每个 java 文件都是一个定义好的  public 类 / 接口，且类名 / 接口名与文件名相同。</p>
<p><em>java 文件可以含有多个类 / 接口，但只能有一个 public 类 / 接口供外部访问。</em></p>
<hr>
<h2 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h2><p>对象的类型：定义对象含有的变量和方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;     </span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;this is a car&quot;</span>;</span><br><span class="line">    <span class="comment">// static 变量 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> number_of_car;  </span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">car</span><span class="params">(String brand)</span>&#123;        </span><br><span class="line">        <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;go to&quot;</span> + loc);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// static 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">static</span> <span class="title function_">showNum</span><span class="params">()</span>&#123;            </span><br><span class="line">        System.out.print(number_of_car);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;       </span><br><span class="line">        number_of_car;                                      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static 初始化块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;                                                              </span><br><span class="line">        number_of_car = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Warranty</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">repair</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;repair&quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>变量</strong></li>
</ul>
<p>对象中存储的数据。</p>
<ul>
<li><strong>方法</strong></li>
</ul>
<p>调用时执行的代码。</p>
<ul>
<li><strong>初始化块</strong></li>
</ul>
<p>创建对象前自动执行的代码。</p>
<ul>
<li><strong>内部类</strong></li>
</ul>
<p>定义在类中的类。</p>
<ul>
<li><strong>构造方法</strong></li>
</ul>
<p>在创建对象时自动执行，不返回任何参数（先执行初始化块，再执行构造方法）。</p>
<p>未定义任何构造方法时，系统会自动添加无参构造方法。</p>
<h3 id="终态声明"><a href="#终态声明" class="headerlink" title="终态声明"></a>终态声明</h3><ul>
<li><strong>final 常量</strong>： 只能赋值一次，不可更改。</li>
<li><strong>final 类</strong>： 不可被继承。</li>
<li><strong>final 方法</strong>：（弃用）不可被继承。现在所有的 private 方法都隐式地指定为 final。</li>
</ul>
<p><em>对于 final 常量，如果编译时就可以确定值，编译器会在编译时直接把这个变量替换成它的值。</em></p>
<h3 id="静态声明"><a href="#静态声明" class="headerlink" title="静态声明"></a>静态声明</h3><ul>
<li><strong>static 变量</strong>：该变量由该类的所有对象共享，不需要创建对象也可使用。</li>
<li><strong>static 方法</strong>：允许直接访问，不需要创建对象也可被调用。如 main 方法。</li>
<li><strong>static 初始化块</strong>：在创建类的第一个对象前自动执行（先执行静态初始化块，再执行初始化块）。</li>
<li><strong>static 内部类</strong>：外部类对象共享，只能访问外部类的静态成员。</li>
</ul>
<h3 id="权限声明"><a href="#权限声明" class="headerlink" title="权限声明"></a>权限声明</h3><ul>
<li><strong>public</strong>： 允许所有访问。</li>
<li><strong>protected</strong>： 只允许本类、同包和子类访问。</li>
<li>**[default]**： 允许本类和同包访问。</li>
<li><strong>private</strong>： 只允许本类访问。</li>
</ul>
<hr>
<h2 id="接口-Interface"><a href="#接口-Interface" class="headerlink" title="接口 Interface"></a>接口 Interface</h2><p>类的规范：只规定应含有哪些方法，而不负责具体实现。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Move</span>&#123;  </span><br><span class="line">    <span class="comment">// abstract 方法                   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>;</span><br><span class="line">    <span class="comment">// default 方法                                 </span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;      </span><br><span class="line">        System.out.print(<span class="string">&quot;stop&quot;</span>);</span><br><span class="line">    &#125;;                  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>声明接口：必须且默认为 static final，通常为 public 。</li>
<li>只允许声明静态常量：必须且默认为 public static final 。</li>
<li>声明抽象方法：必须且默认为 abstract ，可以为 static。</li>
</ol>
<blockquote>
<p>JDK 1.8 以前，接口中抽象方法必须且默认为 public，不允许实现任何方法。<br>JDK 1.8 以后，接口中抽象方法可以且默认为 default，且允许实现 static 和 default 方法。<br>JDK 1.9 以后，接口中抽象方法可以是 private。*</p>
</blockquote>
<h3 id="抽象声明"><a href="#抽象声明" class="headerlink" title="抽象声明"></a>抽象声明</h3><ul>
<li><strong>abstract 方法</strong>：只有声明，而没有方法的具体实现。</li>
<li><strong>abstract 类</strong>：类的模板，不能实例化对象。必须由其他类继承才能使用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">    <span class="comment">// 声明变量</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="comment">// 声明并实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;go to&quot;</span> + loc);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><ol>
<li>接口不能实现普通方法，抽象类可以实现具体的方法、也可以不实现。</li>
<li>接口只能定义静态常量，抽象类可以定义非静态变量。</li>
<li>一个实体类可以实现多个接口，但只能继承一个抽象类。</li>
</ol>
<h3 id="更新声明"><a href="#更新声明" class="headerlink" title="更新声明"></a>更新声明</h3><ul>
<li><p><strong>default 方法</strong>：更新接口时添加的新方法，允许旧类实现接口而不实现该方法。</p>
<ul>
<li><p>可以直接在接口内实现，供没有定义的旧类直接使用。若类中实现了该方法则覆盖。</p>
</li>
<li><p>如果类实现了多个接口且拥有同名 default 方法：</p>
<ol>
<li>两个接口若存在继承关系，调用时优先使用子类方法。</li>
<li>否则，必须重写子类 default 方法，通过 super 关键字明确实现哪个接口：</li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Move</span>, Fly&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span>&#123;</span><br><span class="line">        Fly.<span class="built_in">super</span>.go();                 <span class="comment">// 实现选定 default 方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="包-Package"><a href="#包-Package" class="headerlink" title="包 Package"></a>包 Package</h2><p>命名空间，表示 java 文件的存储路径。其路径记录在每个 java 文件首。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.project.<span class="keyword">module</span>;                    <span class="comment">// 声明存储路径</span></span><br></pre></td></tr></table></figure>

<h3 id="导入-import"><a href="#导入-import" class="headerlink" title="导入 import"></a>导入 import</h3><p>在 java 文件中，如果要调用其他 java 文件中定义的类 / 接口，就需要进行导入：</p>
<ul>
<li>同一存储路径（包）下的 java 文件不需要导入，可以直接调用。</li>
<li>已默认导入 java.lang 路径下所有 java 文件，包含 System、String、Object、Math 等常用类。</li>
<li>如果没有导入对应 java 文件，或者导入了多个同名 java 文件，在调用类 / 接口时需要标明路径。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.project.<span class="keyword">module</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;                             <span class="comment">// 导入 java 文件，但不包括内部 static 变量和方法</span></span><br><span class="line"><span class="keyword">import</span> java.net.*;                                    <span class="comment">// 导入路径下所有 java 文件，但不包括下属文件夹</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;                      <span class="comment">// 导入 java 文件中的 static 变量或方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        java.io.<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.io.InputStream(System.in);    <span class="comment">// 未导入类，调用时需要标明路径</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(in);                                   <span class="comment">// 已导入类，可直接调用</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();                                       <span class="comment">// 默认导入类，可直接调用</span></span><br><span class="line">        sc.close();           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2023/05/14/javase/%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><hr>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul>
<li><p><strong>面向过程</strong>：根据解决问题的过程，直接设计系统。如 C 语言。</p>
</li>
<li><p><strong>面向对象</strong>：将问题分解成多个对象，设计模块化、低耦合的系统。如 java 语言。</p>
<ul>
<li><p>特性：封装、继承、多态。</p>
</li>
<li><p>优点：使系统更加灵活，易维护、易复用、易扩展。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h3><p>定义在类中的类，可以使用外部类所有属性和方法。普通内部类属于具体对象，因此不能声明 static 成员变量和方法。</p>
<p>成员内部类依附外部类而存在。也就是说，如果要创建普通内部类的对象，就必须首先存在外部类的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  </span><br><span class="line">        inner.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="string">&quot;10&quot;</span>;</span><br><span class="line">    <span class="comment">// 内部类  </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">output</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>定义在一个方法或者一个作用域里的内部类。对局部内部类的访问仅限于方法内或者该作用域内，且局部内部类不能被访问权限所修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="type">Factory</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Factory</span>();</span><br><span class="line">        <span class="type">Gun</span> <span class="variable">myrifle</span> <span class="operator">=</span> f.getRifle();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="comment">// 局部内部类</span></span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">getRifle</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Rifle</span> <span class="keyword">extends</span> <span class="title class_">Gun</span> &#123;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rifle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类不用定义名称，但必须继承一个父类或实现一个接口。由于没有类名，匿名内部类不能定义构造器。在创建匿名内部类的时候会立即创建它的实例。因此匿名内部类只能使用一次，通常用来简化代码编写。</p>
<p>最常用的情况就是在多线程的实现上，创建线程类传入参数需要继承 Thread 类或实现 Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类或接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123; </span><br><span class="line">            <span class="comment">// 定义匿名内部类并直接使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>JDK 1.8 中引入了 Lambda 表达式，你甚至连方法名都不需要写。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;eat apple&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        p.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>局部内部类和匿名内部类都定义在方法中，如果调用方法中的其他局部变量，只能调用外部类的局部 final 变量。因为在多线程中，外部类方法中定义的变量 A 在方法执行完毕后生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束。内部类方法中访问的变量 A 实际上是拷贝。这就必须限定变量为 final，否则改动将导致数据不一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是不需要依赖于外部类，可以在不创建外部类对象的情况下创建内部类的对象。静态内部类不能使用外部类的非 static 成员变量或者方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">// 无需外部对象，直接创建内部类</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>子类继承父类后，无需定义也可使用父类定义好的 public/protected 方法和属性。也可以进行扩展和方法的重写。</p>
<ul>
<li>父类的<strong>属性值</strong>不会被子类继承，但子类可以通过父类提供的方法得到父类的属性值。</li>
<li>父类的 <strong>static 方法</strong>不会被子类继承，子类的 static 方法会隐藏父类的同名 static 方法。</li>
<li>父类的<strong>构造方法</strong>不会被子类继承，子类必须在构造方法首行调用父类构造方法（先构造父类，再构造子类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trunk</span> <span class="keyword">extends</span> <span class="title class_">Car</span>&#123; </span><br><span class="line">    <span class="comment">// 重定义属性（未公开无法继承）</span></span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">String</span> <span class="variable">description</span> <span class="operator">=</span> <span class="string">&quot;this is a trunk&quot;</span>;</span><br><span class="line">    <span class="comment">// 扩展属性</span></span><br><span class="line">    <span class="type">int</span> goods;</span><br><span class="line">    <span class="comment">// 扩展方法              </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.goods += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trunk</span><span class="params">(String brand)</span>&#123;    </span><br><span class="line">        <span class="built_in">super</span>(brand);        </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;                          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="meta">@Override</span>         </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(String loc)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.go(loc);                            </span><br><span class="line">        System.out.print(<span class="string">&quot; with&quot;</span> + goods + <span class="string">&quot;goods&quot;</span>); </span><br><span class="line">        <span class="built_in">this</span>.goods = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Object 类是一切 java 类的父类。对于普通的 java 类,即便不声明也默认继承了 Object 类。</em></p>
<hr>
<h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>和类的继承类似。但 Java 类只能单继承，而 Java 接口可以多继承。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Charge</span> <span class="keyword">extends</span> <span class="title class_">Move</span>, Fight&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">kill</span><span class="params">(<span class="type">int</span> num)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="继承多态"><a href="#继承多态" class="headerlink" title="继承多态"></a>继承多态</h3><ul>
<li><strong>重载</strong>(overload)：定义多种同名方法，调用时根据传入参数判定调用哪种方法。</li>
<li><strong>重写</strong>(override)：子类定义完全相同的方法覆盖父类。</li>
</ul>
<p>重写是多态的前提，其允许父类引用指向子类对象（引用类型为父类，指向的实际对象类型为子类）。</p>
<p><code>Car mycar = new Trunk(&quot;Benz&quot;);</code></p>
<p>但不允许子类引用指向父类对象。</p>
<p><del><code>Trunk mycar = new Car(&quot;Benz&quot;);</code></del>   </p>
<p>如果两个类之间存在继承关系，可以进行强制类型转换。强制类型转换只能改变引用类型，实际指向对象类型不会发生变化。</p>
<p><code>Trunk newCar = (Trunk)mycar; </code></p>
<h3 id="方法多态"><a href="#方法多态" class="headerlink" title="方法多态"></a>方法多态</h3><ul>
<li><p><strong>调用普通方法</strong></p>
<p>子类同名方法会覆盖父类。执行方法根据实际对象类型来判定，即执行子类重写的方法。 </p>
</li>
<li><p><strong>调用 static / private / final 以及构造方法</strong></p>
<p>特殊方法不能被覆盖，不存在多态。执行方法会根据引用类型来判定，即执行父类方法。</p>
</li>
<li><p><strong>调用成员变量</strong></p>
<p>父类属性值不会被子类继承，不存在多态。调用变量会根据引用类型来判定，即得到父类属性值。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Car</span> <span class="variable">myCar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trunk</span>(<span class="string">&quot;Benz&quot;</span>);</span><br><span class="line"></span><br><span class="line">myCar.go(<span class="string">&quot;London&quot;</span>);                    <span class="comment">// (trunk) go to London with 0 goods</span></span><br><span class="line">myCar.showNum();                       <span class="comment">// (car) 1</span></span><br><span class="line">System.out.print(myCar.description);   <span class="comment">// (car) this is a car</span></span><br><span class="line"></span><br><span class="line"><span class="type">Trunk</span> <span class="variable">newCar</span> <span class="operator">=</span> (Trunk)mycar;           <span class="comment">// 强制类型转换</span></span><br><span class="line">System.out.print(newCar.description);  <span class="comment">// (trunk) this is a trunk</span></span><br></pre></td></tr></table></figure>


<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><p>JAVA 是动态编译语言（运行时才确定类型），支持反射机制。在运行状态中</p>
<ul>
<li>对于任意一个类，都能够知道这个类的所有属性和方法；</li>
<li>对于任意一个对象，都能够调用它的任意一个方法和属性。</li>
</ul>
<p>通过反射机制能更好地支持多态，降低模块耦合，提高代码灵活度（根据传入类名不同，就能实例化出不同的对象）。</p>
<p>但是在性能上会有较大的损耗。</p>
<p><em>尽管在应用层面很少使用反射机制，但在设计基础框架的时候反射机制非常有用。</em></p>
<h4 id="反射机制运用"><a href="#反射机制运用" class="headerlink" title="反射机制运用"></a>反射机制运用</h4><p>类的相关信息保存在以下类中，通过特定方法获取其对象能够知道这个类的信息。</p>
<ul>
<li><strong>Class 类</strong>：类</li>
<li><strong>Constructor 类</strong>：类的构造方法</li>
<li><strong>Field 类</strong>：类的属性</li>
<li><strong>Method 类</strong>：类的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflection</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 对象 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种方式 返回对象的类 【已有对象，获取类无意义】</span></span><br><span class="line">		<span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> stu.getClass();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第二种方式 获取数据类型的静态 class 属性 【需要导入类包】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Student.class;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 第三种方式 返回路径下的类 【常用】</span></span><br><span class="line">		<span class="type">Class</span> <span class="variable">stuClass</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Reflection.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 获取 Class 信息 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getName());   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getConstructors();</span><br><span class="line">        <span class="comment">// 获取类的全部构造方法</span></span><br><span class="line">        Constructor[] conArray = stuClass.getDeclaredConstructors();</span><br><span class="line">        <span class="comment">// 获取类的指定构造方法（参数）</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getConstructor(<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> stuClass.getDeclaredConstructor(<span class="type">char</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getFields(); </span><br><span class="line">        <span class="comment">// 获取类的全部属性</span></span><br><span class="line">        Field[] fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 获取类的指定属性（属性名）</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;name&quot;</span>);    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取类的公有方法</span></span><br><span class="line">        Method[] methodArray = stuClass.getMethods(); </span><br><span class="line">        <span class="comment">// 获取类的全部方法                </span></span><br><span class="line">        Method[] methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">        <span class="comment">// 获取类的指定方法（方法名+形参类型）                  </span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> stuClass.getMethod(<span class="string">&quot;main&quot;</span>, String.class);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 在对象中使用 **************************/</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> con.newInstance();   <span class="comment">// 调用公有无参构造方法创建对象</span></span><br><span class="line">        f.set(obj, <span class="string">&quot;X-man&quot;</span>);              <span class="comment">// 为对象的公有属性赋值</span></span><br><span class="line">        m.invoke(obj, <span class="string">&quot;X-man&quot;</span>);           <span class="comment">// 调用对象的公有方法</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p><a href="/java/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B?id=%E6%B3%9B%E5%9E%8B">泛型</a>在编译时检查类型安全，编译过后泛型被擦除、实际类型才确定。反射是在编译期模拟 java 运行时的环境读取和调用程序，因此不能获得泛型的实际类型。但可以通过反射越过泛型检查：</p>
<p><em>在 String 泛型的集合中，你甚至可以添加一个 Integer 类型的值。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();	</span><br><span class="line">		<span class="type">Class</span> <span class="variable">listClass</span> <span class="operator">=</span> strList.getClass(); </span><br><span class="line">		<span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> listClass.getMethod(<span class="string">&quot;add&quot;</span>, Object.class);</span><br><span class="line">		m.invoke(strList, <span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器</title>
    <url>/2023/05/14/javase/%E5%AE%B9%E5%99%A8/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><hr>
<h2 id="并发原理"><a href="#并发原理" class="headerlink" title="并发原理"></a>并发原理</h2><p>Java 提供的基础容器都是线程不安全的，如果并发条件下多个线程同时对一个容器中的数据进行操作，可能会导致各种意想不到的错误。</p>
<p>因此 Java 又提供了一些并发容器在多线程情况下使用，这些并发容器都位于 java.util.concurrent 包内，使用时需要进行导入。</p>
<hr>
<h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><h3 id="Vector-类（已过时）"><a href="#Vector-类（已过时）" class="headerlink" title="Vector 类（已过时）"></a><del>Vector 类（已过时）</del></h3><p>【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。</p>
<p>Vector 类内部所有方法都是同步(synchronized) 的，因此线程安全。但高并发场景下非常容易阻塞，性能很差。</p>
<h3 id="CopyOnWriteArrayList-类"><a href="#CopyOnWriteArrayList-类" class="headerlink" title="CopyOnWriteArrayList 类"></a>CopyOnWriteArrayList 类</h3><p>【数组序列】和 ArrayList 类类似，实现了 List 接口。内部使用 Object 数组存储。</p>
<p>CopyOnWriteArrayList 对读取操作不上锁，对写入操作上锁。写入操作通过创建数组的副本来实现，修改的内容写入副本后再替换原来的数据。</p>
<p>不允许同时写，但读操作和写操作不冲突，在多读的场合性能非常好。</p>
<h3 id="ConcurrentLinkedQueue-类"><a href="#ConcurrentLinkedQueue-类" class="headerlink" title="ConcurrentLinkedQueue 类"></a>ConcurrentLinkedQueue 类</h3><p>【链表序列】和 LinkedList 类类似，实现了 List 以及 Deque 接口。内部使用双向链表存储。</p>
<p>ConcurrentLinkedQueue 类非阻塞，通过 CAS 算法实现线程安全，尝试更新数据时会对数据进行比对。高并发场景下如果加锁的代价很高，可以达到很好的性能。</p>
<hr>
<h2 id="BlockingQueue-接口"><a href="#BlockingQueue-接口" class="headerlink" title="BlockingQueue 接口"></a>BlockingQueue 接口</h2><p>【阻塞队列】被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</p>
<h3 id="ArrayBlockingQueue-类"><a href="#ArrayBlockingQueue-类" class="headerlink" title="ArrayBlockingQueue 类"></a>ArrayBlockingQueue 类</h3><p>有界队列实现类，底层采用数组来实现。ArrayBlockingQueue 一旦创建，容量不能改变。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>
<h3 id="LinkedBlockingQueue-类"><a href="#LinkedBlockingQueue-类" class="headerlink" title="LinkedBlockingQueue 类"></a>LinkedBlockingQueue 类</h3><h3 id="PriorityBlockingQueue-类"><a href="#PriorityBlockingQueue-类" class="headerlink" title="PriorityBlockingQueue 类"></a>PriorityBlockingQueue 类</h3><hr>
<h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><h3 id="HashTable-类（已过时）"><a href="#HashTable-类（已过时）" class="headerlink" title="HashTable 类（已过时）"></a><del>HashTable 类（已过时）</del></h3><p>【哈希表】和 HashMap 类类似，实现了 Map 接口。 </p>
<p>HashTable 类内部所有方法都是同步(synchronized) 的，因此线程安全。但由于整个哈希存储区域共享一把锁，高并发场景下非常容易阻塞，性能很差。</p>
<h3 id="ConcurrentHashMap-类"><a href="#ConcurrentHashMap-类" class="headerlink" title="ConcurrentHashMap 类"></a>ConcurrentHashMap 类</h3><p>【哈希表】和 HashMap 类类似，实现了 Map 接口。 </p>
<p>并发控制使用 synchronized 和 CAS 来操作，采取分段锁机制。synchronized 对哈希存储区域的每个 key 分别上锁，只锁定当前链表或红黑二叉树的首节点，这样只要不发生哈希冲突就不会产生并发，效率大大提升。</p>
<p>JDK 1.7 中， ConcurrentHashMap 类中包含静态内部类 Segment，继承于 ReentrantLock 类用来充当锁的角色，每个 Segment 对象守护若干个保存键值对的链表，共同构成 ConcurrentHashMap 实例中的数组。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。 </p>
<p>JDK 1.8 中放弃了 Segment 臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HashEntry</span>&lt;K,V&gt; &#123;</span><br><span class="line">       <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">       <span class="keyword">final</span> <span class="type">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型</span></span><br><span class="line">       <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">       <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型</span></span><br><span class="line">  </span><br><span class="line">       HashEntry(K key, <span class="type">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="built_in">this</span>.key = key;</span><br><span class="line">           <span class="built_in">this</span>.hash = hash;</span><br><span class="line">           <span class="built_in">this</span>.next = next;</span><br><span class="line">           <span class="built_in">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="普通容器转换"><a href="#普通容器转换" class="headerlink" title="普通容器转换"></a>普通容器转换</h2><h3 id="synchronizedList-方法"><a href="#synchronizedList-方法" class="headerlink" title="synchronizedList 方法"></a>synchronizedList 方法</h3><p>如果遇到多个线程操作同一个容器的场景，可以通过 Collections 工具类中的 synchronizedList 方法将其转换成线程安全的容器。</p>
<p>方法会被 synchronized 关键字重定义。</p>
]]></content>
      <categories>
        <category>javase</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>流 Stream</title>
    <url>/2023/05/14/javase/%E5%AE%B9%E5%99%A8/stream/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h1><hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>流处理是对运动中的数据的处理，在生成或接收数据时直接计算数据。应用程序中分析和查询不断存在，数据不断地流经它们。在从流中接收到事件时，流处理应用程序对该事件作出反应。</p>
<p>如果我们使用传统的循环迭代方式对数据集进行复杂计算，常常会带来两个弊端：</p>
<ol>
<li>迭代次数多，迭代次数跟函数调用的次数相等。</li>
<li>频繁产生中间结果，存储开销无法接受。</li>
</ol>
<p>流处理可以立即对事件做出反应，且可以处理比其他数据处理系统大得多的数据量：直接处理事件流，并且只保留数据中有意义的子集。尤其是面对持续生成，本质上是无穷尽的数据集。</p>
<h3 id="Java-Stream-类"><a href="#Java-Stream-类" class="headerlink" title="Java Stream 类"></a>Java Stream 类</h3><p>JDK 1.8 新增。将要处理的元素集合看作一种流，在管道的节点上进行处理。使代码更简洁易读。</p>
<p>集合接口有两个方法来生成流，数据类型将由 Collection 转化为 Stream 。</p>
<ul>
<li><code>stream</code> 方法：为集合创建串行流。</li>
<li><code>parallelStream</code> 方法：为集合创建并行流。</li>
</ul>
<ol>
<li><p>Stream 的遍历方式和结果与 Iterator 无差别（便于转化），其优势在于其原型链的设计使得它可以对遍历处理后的数据进行再处理。</p>
</li>
<li><p>parallelStream 提供了流的并行处理，底层使用 Fork/Join 框架，简单理解就是多线程异步任务的一种实现。处理过程中会有多个线程处理元素，具体由 JDK 负责管理。不保证有序性。</p>
</li>
<li><p>串行流和并行流之间可以通过 <code>parallel</code> 和 <code>sequential</code> 方法相互转化。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = list.stream();                     <span class="comment">// 声明作为流处理</span></span><br><span class="line">ParellerStream&lt;Integer&gt; pStream = stream.parallel();        <span class="comment">// 转化为并行流</span></span><br></pre></td></tr></table></figure>

<h3 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h3><p>流处理的每个操作阶段都会封装到一个 Sink 接口里，处理数据后再将数据传递给下游的 Sink。</p>
<p>Stream 上的所有操作分为两类：中间操作和结束操作。Stream 是延迟执行的，只有调用到结束操作，才触发整个流水线的执行。如果未定义结束操作，那么流处理什么也不会做。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strings.parallelStream()                       <span class="comment">// 声明作为流处理</span></span><br><span class="line">                   .filter(string -&gt; string.isEmpty())     <span class="comment">// 中间操作，过滤空元素</span></span><br><span class="line">                   .count();                               <span class="comment">// 结束操作，计数</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map"></a>映射 map</h3><p><code>map</code> 方法用于映射每个元素到对应的结果，其实就是对结果进行转化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤 filter"></a>过滤 filter</h3><p><code>filter</code> 方法用于通过设置的条件过滤出元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h3 id="筛选-limit-skip"><a href="#筛选-limit-skip" class="headerlink" title="筛选 limit/skip"></a>筛选 limit/skip</h3><p><code>limit</code> 方法用于获取指定数量的流(前 n 个)， <code>skip</code> 方法用于去除指定数量的流(前 n 个)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 筛选出 11-20 条数据</span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">20</span>).skip(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序 sorted"></a>排序 sorted</h3><p><code>sorted</code> 方法通过 Comparable 接口对流进行排序，也可以自定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="去重-distinct"><a href="#去重-distinct" class="headerlink" title="去重 distinct"></a>去重 distinct</h3><p><code>distinct</code> 方法通过流元素的 hashCode 和 equals 方法去除重复元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="结束操作"><a href="#结束操作" class="headerlink" title="结束操作"></a>结束操作</h2><h3 id="迭代-forEach"><a href="#迭代-forEach" class="headerlink" title="迭代 forEach"></a>迭代 forEach</h3><p>结束操作： <code>forEach</code> 迭代流中的每个数据，即对每个数据进行最后的处理（比如保存到数据库中或打印）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出 10 个随机数 </span></span><br><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要用 forEach 方法收集元素！stream 并行执行会损害正确性和效率，使用下方操作。</p>
</blockquote>
<h3 id="聚合-Collectors"><a href="#聚合-Collectors" class="headerlink" title="聚合 Collectors"></a>聚合 Collectors</h3><p>结束操作：<code>Collectors</code> 类实现了归约操作，例如将流转换成集合和聚合元素，可用于返回列表或字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Stream 转化为 List</span></span><br><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream()</span><br><span class="line">                               .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                               .collect(Collectors.toList()); </span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stream 转化为 String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream()</span><br><span class="line">                             .filter(string -&gt; !string.isEmpty())</span><br><span class="line">                             .collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure>


<h3 id="统计-SummaryStatistics"><a href="#统计-SummaryStatistics" class="headerlink" title="统计 SummaryStatistics"></a>统计 SummaryStatistics</h3><p>结束操作：收集最终产生的统计结果，它们主要用于 int、double、long 等基本类型上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> numbers.stream()</span><br><span class="line">                                    .mapToInt((x) -&gt; x)</span><br><span class="line">                                    .summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javase</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>基础容器</title>
    <url>/2023/05/14/javase/%E5%AE%B9%E5%99%A8/%E5%9F%BA%E7%A1%80%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础容器"><a href="#基础容器" class="headerlink" title="基础容器"></a>基础容器</h1><hr>
<h2 id="基本接口"><a href="#基本接口" class="headerlink" title="基本接口"></a>基本接口</h2><p>java 提供了一些基础容器类，可以用特定的方式组织、存储和操作对象数据。这些集合框架分为两大分支：Collection 接口和 Map 接口。</p>
<p>所有容器都定义在 java.util 文件夹内，使用时需要进行导入。</p>
<h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>【集合】用特定的方式组织、存储和操作对象数据。有三个常用子接口 List 接口、Queue 接口、Set 接口。</p>
<p>Collection 接口以及所有子接口和子方法 都定义在 java.util 文件夹内，使用时需进行导入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line">collection.add(<span class="number">1</span>);                <span class="comment">// 添加元素</span></span><br><span class="line">collection.remove(<span class="number">1</span>);             <span class="comment">// 删除元素</span></span><br><span class="line">collection.clear();               <span class="comment">// 清除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">collection.isEmpty();             <span class="comment">// 判断集合是否为空</span></span><br><span class="line">collection.size();                <span class="comment">// 返回集合元素个数</span></span><br><span class="line">collection.contains(<span class="number">1</span>):           <span class="comment">// 判断集合中是否含有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多集合操作</span></span><br><span class="line">collection.addAll(c2);            <span class="comment">// 并操作，添加其他集合中元素</span></span><br><span class="line">collection.removeAll(c2);         <span class="comment">// 减操作，删除和其他集合共有元素</span></span><br><span class="line">collection.retainAll(c2);         <span class="comment">// 交操作，只保留和其他集合共有元素 </span></span><br><span class="line">collection.equals(c2);            <span class="comment">// 判断是否和其他集合元素相同</span></span><br><span class="line">collection.containsAll(c2);       <span class="comment">// 判断是否包含其它集合所有元素  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; iter = collection.iterator();</span><br></pre></td></tr></table></figure>

<h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><p>【列表】元素有序，可以按索引操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line">list.add(<span class="string">&quot;data1&quot;</span>);              <span class="comment">// 末尾添加元素</span></span><br><span class="line">list.add(<span class="number">0</span>, <span class="string">&quot;data0&quot;</span>);           <span class="comment">// 插入元素</span></span><br><span class="line">list.remove(<span class="number">0</span>);                 <span class="comment">// 按索引删除元素(int)</span></span><br><span class="line">list.remove(<span class="string">&quot;data&quot;</span>);            <span class="comment">// 按内容删除对象元素(Object)</span></span><br><span class="line">list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));    <span class="comment">// 按内容删除基础类型元素</span></span><br><span class="line">list.clear();                   <span class="comment">// 清除所有元素</span></span><br><span class="line">list.set(<span class="number">0</span>, <span class="string">&quot;data2&quot;</span>);           <span class="comment">// 修改元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">list.isEmpty();                 <span class="comment">// 判定是否为空</span></span><br><span class="line">list.size();                    <span class="comment">// 查询列表元素个数</span></span><br><span class="line">list.contains(<span class="string">&quot;data3&quot;</span>);         <span class="comment">// 判定是否含有元素</span></span><br><span class="line">list.get(<span class="number">1</span>);                    <span class="comment">// 按索引查找元素</span></span><br><span class="line">list.indexOf(<span class="string">&quot;data1&quot;</span>);          <span class="comment">// 查询索引号：如果有返回第一个，没有返回-1</span></span><br><span class="line">list.lastIndexOf(<span class="string">&quot;data1&quot;</span>);      <span class="comment">// 查询索引号：如果有返回最后一个，没有返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化</span></span><br><span class="line">list.toString();                <span class="comment">// 转化为字符串</span></span><br><span class="line">list.toArray();                 <span class="comment">// 转化为 Object[] 数组</span></span><br><span class="line">(String [])list.toArray();      <span class="comment">// 转化为对象数组，但不能是基础类型</span></span><br></pre></td></tr></table></figure>

<h3 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p>【队列】元素有序，在队列尾插入/在队列首移除。常用 Deque 子接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改</span></span><br><span class="line">queue.offer(<span class="number">10</span>);                <span class="comment">// 队列尾插入元素，队列满返回 false</span></span><br><span class="line">queue.peek();                   <span class="comment">// 获取队列首元素，队列空返回 null</span></span><br><span class="line">queue.poll();                   <span class="comment">// 获取并移除队列首元素，队列空返回 null</span></span><br><span class="line">queue.clear();                  <span class="comment">// 清空元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offer/peek/poll 方法可以用 add/get/remove 方法代替，但队列空/满时会抛出异常。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">queue.isEmpty();                 <span class="comment">// 判定是否为空</span></span><br><span class="line">queue.size();                    <span class="comment">// 查询列表元素个数</span></span><br><span class="line">queue.contains(<span class="string">&quot;data3&quot;</span>);         <span class="comment">// 判定是否含有元素</span></span><br></pre></td></tr></table></figure>

<h4 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h4><p>【双端队列】元素可以在两端进出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">deque.offerFirst(e);            <span class="comment">// 队列首添加元素 </span></span><br><span class="line">deque.pollFirst();              <span class="comment">// 队列首移除元素</span></span><br><span class="line">deque.peekFirst();              <span class="comment">// 获取队列首元素</span></span><br><span class="line"></span><br><span class="line">deque.offerLast(e);	            <span class="comment">// 队列尾添加元素</span></span><br><span class="line">deque.pollLast();               <span class="comment">// 队列尾移除元素</span></span><br><span class="line">deque.peekLast();               <span class="comment">// 获取队列尾元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offer/peek/poll 方法可以用 add/get/remove 方法代替，但队列空/满时会抛出异常。 */</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>【集】数据不可重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line">set.add(<span class="string">&quot;data&quot;</span>);              <span class="comment">// 添加元素</span></span><br><span class="line">set.remove(<span class="string">&quot;data&quot;</span>);           <span class="comment">// 删除元素</span></span><br><span class="line">set.clear();                  <span class="comment">// 清除所有元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">set.get(<span class="number">1</span>);                   <span class="comment">// 按序号查找元素（仅限于有序的 set 接口）</span></span><br><span class="line">set.isEmpty();                <span class="comment">// 判断是否为空</span></span><br><span class="line">set.size();                   <span class="comment">// 返回元素个数</span></span><br><span class="line">set.contains(<span class="string">&quot;data&quot;</span>);         <span class="comment">// 判定是否含有元素</span></span><br></pre></td></tr></table></figure>

<p><em>HashSet 类无序，因此不支持 get 方法：获取对象必须要通过 Iterator 来遍历。</em></p>
<h3 id="Collections-类"><a href="#Collections-类" class="headerlink" title="Collections 类"></a>Collections 类</h3><p>Collections 类是针对集合类的一个帮助类，他提供一系列静态方法实现各种集合操作。</p>
<ol>
<li>排序操作（主要针对List接口）  </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.swap(list, <span class="number">1</span>, <span class="number">2</span>);          <span class="comment">// 元素交换顺序</span></span><br><span class="line">Collections.shuffle(list);             <span class="comment">// 元素随机排序</span></span><br><span class="line">Collections.reverse(list);             <span class="comment">// 元素颠倒排序</span></span><br><span class="line">Collections.sort(list);                <span class="comment">// 元素按大小排序，可以自定义比较顺序</span></span><br><span class="line">Collections.rotate(list, <span class="number">2</span>);           <span class="comment">// 元素右移指定长度</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查找和替换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Collections.binarySearch(list, <span class="string">&quot;data&quot;</span>);              <span class="comment">// 二分查找元素索引，只适用于有序集合</span></span><br><span class="line">Collections.max(list);                               <span class="comment">// 返回最大元素，可以自定义比较顺序</span></span><br><span class="line">Collections.min(list);                               <span class="comment">// 返回最小元素，可以自定义比较顺序</span></span><br><span class="line">Collections.frequency(list, <span class="string">&quot;data&quot;</span>);                 <span class="comment">// 返回对象出现次数</span></span><br><span class="line"></span><br><span class="line">Collections.fill(list, <span class="string">&quot;data&quot;</span>);                      <span class="comment">// 使用指定元素填充</span></span><br><span class="line">Collections.replaceAll(list, <span class="string">&quot;old&quot;</span>, <span class="string">&quot;new&quot;</span>);          <span class="comment">// 使用指定元素替换</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上锁（主要针对List接口）  </li>
</ol>
<p>调用 Collections 类中的 synchronizedList 方法，可以将 List 接口转换成线程安全的容器使用。</p>
<p>List 接口中的方法都会被添加 synchronized 锁（效率不高）。但是 iterator 方法没有加锁，如果要遍历还需要在外层加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">i</span> <span class="operator">=</span> list.iterator(); </span><br><span class="line">    <span class="keyword">while</span> (i.hasNext())</span><br><span class="line">        foo(i.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><p>【图】组织存储 key-value 的数据元素组合：内部实际存储的是 <code>Map.Entry&lt;K, V&gt;</code> 静态内部类。</p>
<p>Entry 类可以通过 getKey、getValue、setKey、setValue 方法调整数据。</p>
<h4 id="Map-接口方法"><a href="#Map-接口方法" class="headerlink" title="Map 接口方法"></a>Map 接口方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(<span class="string">&quot;key_1&quot;</span>,<span class="number">1</span>);               <span class="comment">// 添加键值对,已有 key 则覆盖 value</span></span><br><span class="line">map.putIfAbsent(<span class="string">&quot;key_2&quot;</span>,<span class="number">2</span>);       <span class="comment">// 添加键值对,已有 key 则不操作</span></span><br><span class="line"></span><br><span class="line">map.remove(<span class="string">&quot;key_1&quot;</span>);              <span class="comment">// 删除键值对（按值）           </span></span><br><span class="line">map.remove(<span class="string">&quot;key_2&quot;</span>,<span class="number">2</span>);            <span class="comment">// 删除键值对（按键值）</span></span><br><span class="line"></span><br><span class="line">map.get(<span class="string">&quot;key_1&quot;</span>);                 <span class="comment">// 获取值, key 不存在返回null</span></span><br><span class="line">map.getOrDefault(<span class="string">&quot;key_2&quot;</span>,-<span class="number">1</span>);     <span class="comment">// 获取值, key 不存在返回默认值</span></span><br><span class="line"></span><br><span class="line">map.containsKey(<span class="string">&quot;key_1&quot;</span>);       <span class="comment">// 判断 key 是否存在  </span></span><br><span class="line">map.containsValue(<span class="number">1</span>);             <span class="comment">// 判断 value 是否存在      </span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="线性存储"><a href="#线性存储" class="headerlink" title="线性存储"></a>线性存储</h2><h3 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h3><p>【数组序列】实现了 List 接口，内部使用 Object 数组存储：</p>
<ol>
<li>可以高效地按索引进行元素修改和查询。</li>
<li>添加元素时动态扩容：当容量满后，ArrayList 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。</li>
</ol>
<p><strong>ArrayList 构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();              <span class="comment">// 默认初始容量为 10</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">100</span>);           <span class="comment">// 自定义初始容量</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(queue);         <span class="comment">// 构造时直接复制其他容器元素（可以是任何 Collection 类）</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();                         <span class="comment">// 未指定元素类型则为 Object 类</span></span><br></pre></td></tr></table></figure>

<h3 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h3><p>【链表序列】实现了 List 和 Deque 接口。内部使用双向链表存储：</p>
<ol>
<li>可以高效地进行元素插入和删除。</li>
<li>容量无限。</li>
</ol>
<p><strong>LinkedList 构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();              <span class="comment">// 创建空对象</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(queue);         <span class="comment">// 复制其他容器元素</span></span><br></pre></td></tr></table></figure>

<h3 id="ArrayDeque-类"><a href="#ArrayDeque-类" class="headerlink" title="ArrayDeque 类"></a>ArrayDeque 类</h3><p>【数组双端队列】实现了 Deque 接口。内部使用 Object 数组存储（不允许存储 null 值）：</p>
<ol>
<li>可以高效进行元素查找和尾部插入取出，是用作队列、双端队列、栈甚至递归树的绝佳选择。</li>
<li>添加元素时动态扩容：当容量满后，ArrayDeque 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。</li>
</ol>
<p><strong>ArrayDeque 构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayDeque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();              <span class="comment">// 创建空对象</span></span><br><span class="line">ArrayDeque&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(list);          <span class="comment">// 复制其他容器元素</span></span><br></pre></td></tr></table></figure>

<h3 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h3><p>【无界优先级队列】实现了 Queue 接口。内部使用 Object 数组存储（不允许存储 null 值）：</p>
<ol>
<li><strong>PriorityQueue 类内会自动对元素进行排序</strong>，是作为堆的绝佳选择。但实际在数组中并不是有序存储，而只保证队首元素是最小值：每次弹出队首元素后会自动查找剩余队列中的最小元素放到队首。</li>
<li>添加元素时动态扩容：当容量满后，PriorityQueue 类会新建一个 1.5 倍容量的新数组，然后将当前数组数据全部复制过去。</li>
</ol>
<p><strong>PriorityQueue 构造方法</strong></p>
<p>开发者在构造队列时可通过重写 compare 方法自定义排序规则。如果存储未重写 compareTo 方法的自定义对象，则必须重写 compare 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认排序方法</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义排序方法(Lambda 表达式)</span></span><br><span class="line">PriorityQueue&lt;Student&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Student&gt;((s1, s2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.getScore() == s2.getScore())&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.getName().compareTo(s2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.getScore() - s2.getScore();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="哈希存储"><a href="#哈希存储" class="headerlink" title="哈希存储"></a>哈希存储</h2><h3 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap 类"></a>HashMap 类</h3><p>【哈希表】 实现 Map 接口。底层使用散列存储：构造一个 Entry 数组，根据 key 的 hash 值将 Entry 存入指定位置。</p>
<ul>
<li>key 值无序且不可重复，且允许 null 作为 key 值存在。</li>
<li>发生哈希冲突时，HashMap 采用链表保存多个元素。当链表长度大于 8 时，链表自动转化为红黑树。</li>
<li>达到负载因数后，HashMap 将调用 resize 方法动态扩容：新建一个 2 倍容量的新数组复制当前数组的数据。</li>
</ul>
<p><strong>HashMap 构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();                       <span class="comment">// 默认初始容量 16 负载因数 0.75</span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>);                     <span class="comment">// 自定义初始容量</span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">32</span>, <span class="number">0.5f</span>);               <span class="comment">// 自定义初始容量和负载因数</span></span><br></pre></td></tr></table></figure>


<h3 id="LinkedHashMap-类"><a href="#LinkedHashMap-类" class="headerlink" title="LinkedHashMap 类"></a>LinkedHashMap 类</h3><p>【链式哈希表】继承 HashMap 类。</p>
<ol>
<li>底层使用散列存储：构造一个 Entry 数组，根据 key 的 hash 值将 Entry 存入指定位置。</li>
<li>Entry 额外添加了引用 before &amp; after ，使哈希表内的所有 Entry 构成一个双向链表维护 Entry 的顺序。</li>
</ol>
<p><strong>LinkedHashMap 构造方法</strong></p>
<p>在默认情况下 Entry 按照插入顺序排序，可指定创建时的初始容量和负载因数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();                  <span class="comment">// 默认初始容量 16 负载因数 0.75 </span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">32</span>);                <span class="comment">// 自定义初始容量</span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">32</span>, <span class="number">0.5f</span>);          <span class="comment">// 自定义初始容量和负载因数</span></span><br></pre></td></tr></table></figure>

<p>Entry 也可以按照访问顺序排序：对 Entry 进行操作时会先删除再插入，将 Entry 移动到双向链表的表尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(<span class="number">32</span>，<span class="number">0.5f</span>, <span class="literal">true</span>);    <span class="comment">// 基于访问顺序排序</span></span><br></pre></td></tr></table></figure>

<p>LinkedHashMap 类提供了 removeEldestEntry 方法，在使用 put 操作插入 Entry 时将自动调用此方法决定是否移除双向链表表头的 Entry：默认返回 false ，可通过重写此方法以实现 LRU 算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Entry 超过容量后自动删除最久未使用的 Entry</span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(capacity, <span class="number">0.5f</span>, <span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> size() &gt; capacity;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="TreeMap-类"><a href="#TreeMap-类" class="headerlink" title="TreeMap 类"></a>TreeMap 类</h3><p>【树表】 实现了 Map 接口。底层使用红黑树存储：Entry 按照 key 值大小插入红黑树，并动态调整红黑树高度。</p>
<p><strong>TreeMap 类方法</strong></p>
<p>TreeMap 类提供了以下专属方法使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.firstKey();                   <span class="comment">// 返回最小 key</span></span><br><span class="line">map.lastKey();                    <span class="comment">// 返回最大 key</span></span><br><span class="line"></span><br><span class="line">map.ceilingKey(<span class="string">&quot;10&quot;</span>);             <span class="comment">// 返回大于等于10的最小 Key，不存在则返回 null</span></span><br><span class="line">map.ceilingEntry(<span class="string">&quot;10&quot;</span>);           <span class="comment">// 返回大于等于10的最小 Key 的键值对(getKey / getValue 方法)</span></span><br><span class="line"></span><br><span class="line">map.floorKey(<span class="string">&quot;10&quot;</span>);               <span class="comment">// 返回小于等于10的最大 Key，不存在则返回 null</span></span><br><span class="line">map.floorEntry(<span class="string">&quot;10&quot;</span>);             <span class="comment">// 返回小于等于10的最大 Key 的键值对</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-子类"><a href="#Set-子类" class="headerlink" title="Set 子类"></a>Set 子类</h3><ul>
<li><strong>HashSet 类</strong>：【散列集】基于 HashMap 类实现。</li>
<li><strong>LinkedHashSet 类</strong>：【链式散列集】基于 LinkedHashMap 类实现。</li>
<li><strong>TreeSet 类</strong>：【树集】基于 TreeMap 类实现。</li>
</ul>
<hr>
<h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><h3 id="遍历容器"><a href="#遍历容器" class="headerlink" title="遍历容器"></a>遍历容器</h3><h4 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h4><p>是集合框架的顶级接口，被所有容器类都实现。</p>
<ol>
<li><p>提供 iterator 方法，用来创建一个实现了 Iterator 接口的 iterator 对象：按容器类规定的顺序实现遍历集合。</p>
</li>
<li><p>JDK 1.8 引入 foreach 方法遍历集合。效率更高，但不能对元素进行删除操作，否则会抛出异常。</p>
</li>
</ol>
<h4 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h4><p>提供了 hasNext、next、remove 三个方法，可以按容器类规定的顺序实现遍历集合。</p>
<h3 id="遍历顺序"><a href="#遍历顺序" class="headerlink" title="遍历顺序"></a>遍历顺序</h3><h4 id="List-Queue-接口"><a href="#List-Queue-接口" class="headerlink" title="List / Queue 接口"></a>List / Queue 接口</h4><ul>
<li><strong>全部方法</strong>：按数组或链表顺序输出。</li>
</ul>
<h4 id="Map-Set-接口"><a href="#Map-Set-接口" class="headerlink" title="Map / Set 接口"></a>Map / Set 接口</h4><ul>
<li><strong>HashSet/HashMap 类</strong>：在返回数据时没有特别的顺序。</li>
<li><strong>LinkedHashSet/LinkedHashMap 类</strong>：默认按插入顺序返回数据，也可以按访问顺序返回。</li>
<li><strong>TreeSet/TreeMap 类</strong>：在返回数据时按 key 值从小到大排列，即按照树的中序遍历返回。</li>
</ul>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><h4 id="Collection-接口-1"><a href="#Collection-接口-1" class="headerlink" title="Collection 接口"></a>Collection 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 遍历</span></span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;              </span><br><span class="line">      <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> iter.next();</span><br><span class="line">      <span class="keyword">if</span>(num &lt; <span class="number">0</span>) iter.remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机遍历（效率更高，但不能进行删除操作）</span></span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Map-接口-1"><a href="#Map-接口-1" class="headerlink" title="Map 接口"></a>Map 接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,String&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// iterator 遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = map.entrySet().iterator(); </span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123; </span><br><span class="line">	Map.Entry&lt;String, String&gt; entry = iter.next(); </span><br><span class="line">	System.out.println(entry.getKey() + entry.getValue()); </span><br><span class="line">&#125; </span><br><span class="line">		</span><br><span class="line"><span class="comment">// 随机遍历（效率更高，但不能进行删除操作）</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; </span><br><span class="line">	System.out.println(entry.getKey() + entry.getValue()); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 只遍历 key</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123; </span><br><span class="line">	System.out.println(key + map.get(key)); </span><br><span class="line">&#125; </span><br><span class="line">		</span><br><span class="line"><span class="comment">// 只遍历 value</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123; </span><br><span class="line">	System.out.println(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="遍历失败"><a href="#遍历失败" class="headerlink" title="遍历失败"></a>遍历失败</h3><p>在迭代元素的时候不能通过集合的方法修改或删除元素，但可以通过迭代器的 remove 方法删除元素。</p>
<ul>
<li><p>java.util 包下面的所有的集合类都是快速失败的。直接对原容器进行修改，会抛出 ConcurrentModificationException 异常。</p>
</li>
<li><p>java.util.concurrent 包下面的所有的集合类都是安全失败的。遍历时先对底层集合做拷贝再遍历，因此不会抛出异常。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>javase</category>
        <category>容器</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程</title>
    <url>/2023/05/14/javase/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><hr>
<h2 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><ul>
<li><p><strong>并行</strong>：多个CPU核心同时工作，处理不同的任务。</p>
</li>
<li><p><strong>并发</strong>：多个任务交替使用 CPU 核心工作，以提高 CPU 利用率。</p>
</li>
</ul>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><h4 id="进程-Processor"><a href="#进程-Processor" class="headerlink" title="进程 Processor"></a>进程 Processor</h4><p>程序的一次执行。由操作系统创建并分配资源，执行一个单独的任务。</p>
<p>进程是系统进行资源分配和调度的独立单位，每个进程都有自己的内存空间和系统资源。进程内所有线程共享堆存储空间，保存程序中定义的对象和常量池。</p>
<p><em>Windows系统中，每个运行的 Java 程序都是一个独立的进程。</em></p>
<h4 id="线程-Thread"><a href="#线程-Thread" class="headerlink" title="线程 Thread"></a>线程 Thread</h4><p>进程内的执行单元，不分配单独的资源，执行一个单独的子任务。</p>
<p>线程是进程内调度和分派的基本单位，共享进程资源。每个线程有自己的独立的栈存储空间，保存线程执行的方法以及基本类型的数据。</p>
<p><em>运行的 Java 程序内含至少一个主线程 main ，用户可以在 Java 程序中自定义并调用多个线程。 JVM 垃圾回收线程也是一个独立的线程。</em></p>
<hr>
<h3 id="线程的运行状态"><a href="#线程的运行状态" class="headerlink" title="线程的运行状态"></a>线程的运行状态</h3><p>线程除创建状态 New 和结束状态 Terminate 外，主要有以下几种运行状态：</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>(Running) CPU 正在执行线程。</p>
<h4 id="就绪"><a href="#就绪" class="headerlink" title="就绪"></a>就绪</h4><p>(Runnable) 线程一切就绪，等待 CPU 执行。   </p>
<p><em>运行/就绪状态 统称为可运行状态 Runnable。 Java 程序中，线程在 运行/就绪状态 之间的切换由 JVM 自动调度，开发者无法获知。线程之间的调度采用分优先级多队列时间片轮转算法。进程在执行完 CPU 时间片切换到就绪状态之前会先保存自己的状态，下次进入运行状态时再重新加载。</em></p>
<h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>(Blocked) 线程因缺少其他资源，比如请求资源被上锁而暂停执行。在获得资源后进入就绪状态。 </p>
<h4 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h4><p>(Waitting) 线程接受了等待指令，释放资源暂停执行。在超时/接受唤醒指令后进入就绪状态。  </p>
<hr>
<h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><p>Thread 类是系统自带的线程类，实现了 Runnable 接口。 </p>
<h3 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h3><p>Runnable 接口内唯一声明了 run 方法，由 Thread 类实现。开发者在 run 方法中定义运行时线程将要执行的功能，线程开启后由 JVM 自动调用并执行。如果开发者主动调用 run 方法，只会当作普通方法执行。</p>
<p>开发者可以通过以下两种方式自定义线程类：</p>
<ol>
<li>继承 Thread 类，重写 run 方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>实现 Runnable 接口，实现 run 方法。推荐使用，避免了单继承的局限性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h3><p>Thread 类定义了 start 方法。调用 start 方法后，系统会开启一个新线程进入就绪状态：由 JVM 会自动对线程进行调度，在运行时调用并执行线程的 run 方法。一个线程只能启动一次。</p>
<ol>
<li>如果自定义线程类继承 Thread 类，直接启动。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;ThreadName&quot;</span>);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果自定义线程类实现 Runnable 接口，则需要借助 Thread 类启动线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);                   <span class="comment">// 由系统指定默认线程名 Thread-X</span></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread, <span class="string">&quot;ThreadName&quot;</span>);     <span class="comment">// 开发者自定义线程名 </span></span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同时定义和启动线程"><a href="#同时定义和启动线程" class="headerlink" title="同时定义和启动线程"></a>同时定义和启动线程</h4><p>通过匿名内部类方式，我们可以实现同时定义和启动线程的简洁写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式简写一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda 表达式简写二</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(test::method);         </span><br><span class="line">       t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">       System.out.println(Thread.currentThread().getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程弹出执行"><a href="#线程弹出执行" class="headerlink" title="线程弹出执行"></a>线程弹出执行</h3><p>Thread 类定义了 yield 方法。当前线程执行到 <code>Thread.yield()</code> 方法，会停止运行进入就绪状态。但线程切换到就绪状态后，什么时候被 JVM 调度回运行状态开发者无法控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);    </span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>();                    <span class="comment">// 切换到就绪状态</span></span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程暂停执行"><a href="#线程暂停执行" class="headerlink" title="线程暂停执行"></a>线程暂停执行</h3><p>Thread 类定义了 sleep 方法。当前线程执行到 <code>Thread.sleep(1000)</code> 方法，会停止运行进入阻塞状态，但仍会保持对象锁，其他线程不可访问其资源。直到超时后进入就绪状态。调用 sleep 方法需要捕获或抛出 InterruptException 异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);    </span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);             <span class="comment">// 当前线程暂停 1s</span></span><br><span class="line">                &#125; <span class="keyword">catch</span>(InterruptException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="线程交互"><a href="#线程交互" class="headerlink" title="线程交互"></a>线程交互</h3><p>Object 类定义了 wait 和 notify 方法，通常被用于线程间交互/通信。必须在同步环境下(synchronized)使用，否则会抛出 IllegalMonitorStateException 异常。假定 obj 为同步环境上锁的对象：</p>
<h4 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h4><p>当前线程执行 <code>obj.wait()</code> 方法，线程会停止运行并释放对象锁 obj，其他线程可以访问其资源。同时线程进入 obj 对象的等待池，直到被 notify 方法唤醒进入就绪状态。调用 wait 方法需要捕获或抛出 InterruptException 异常。</p>
<p>wait 方法允许计时等待。当前线程执行 <code>obj.wait(1000)</code> 方法，计时结束后线程会被自动唤醒进入就绪状态。</p>
<h4 id="线程唤醒"><a href="#线程唤醒" class="headerlink" title="线程唤醒"></a>线程唤醒</h4><p>当前线程执行 <code>obj.notify()</code> 方法，会随机从 obj 对象等待池中选择一个线程唤醒，使其进入就绪状态。但是 notify 方法不会释放当前进程的对象锁，如果该线程持有 obj 对象的锁，当前线程释放锁后被唤醒的其他线程才能被执行。如果想被唤醒线程先执行，notify 方法后添加 wait 方法释放锁。</p>
<p>当前线程执行 <code>obj.notifyall()</code> 方法，会将所有 obj 对象等待池中所有线程唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(t) &#123;                         <span class="comment">// 对 t 设置对象锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">                t.wait();                         <span class="comment">// 当前线程释放 t 锁，进入 t 对象等待池</span></span><br><span class="line">                System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;                 <span class="comment">// 对 t 设置对象锁        </span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="built_in">this</span>.notify();                    <span class="comment">// 随机唤醒一个 t 对象等待池中的线程</span></span><br><span class="line">                System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他线程优先"><a href="#其他线程优先" class="headerlink" title="其他线程优先"></a>其他线程优先</h3><p>Thread 类定义了 join 方法，其底层通过调用 wait 方法实现。当前线程执行 <code>t.join()</code> 方法，线程会停止运行并释放对象锁，同时线程进入线程 t 对象的等待池，直到被唤醒进入就绪状态。通常用于主线程 main，等到线程 t 终止时自动被唤醒。调用 join 方法需要捕获或抛出 InterruptException 异常。</p>
<p>同样允许计时等待。当前线程执行 <code>t.join(1000)</code> 方法，计时结束后线程会被自动唤醒进入就绪状态，无须等待子线程结束时唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       t.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       t.join();                              <span class="comment">// 子线程结束后才被唤醒</span></span><br><span class="line">       System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);    </span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       t.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       t.join(<span class="number">500</span>);                           <span class="comment">// 0.5s 后自动被唤醒</span></span><br><span class="line">       System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);    </span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们手动给线程 t 加锁，即使计时结束后线程被唤醒进入就绪状态，但仍无法立刻拿到锁进入运行状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       t.start();</span><br><span class="line">       System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">       t.join(<span class="number">500</span>);                           <span class="comment">// 自动被唤醒后仍要等待线程 t 释放锁</span></span><br><span class="line">       System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (currentThread()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;   </span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>调用 <code>t.stop()</code> 方法可以强制终止线程 t 运行，但强制中断线程可能会造成意想不到的问题，已不推荐使用。</p>
<p>目前主要采用设置线程中断标志的方式，向线程发送中止信号。由线程自行终止运行：</p>
<ul>
<li>执行 <code>t.interrupt()</code> 方法，将线程 t 中断标志设为 true 。</li>
<li>执行 <code>t.isInterrupted()</code> 方法，查看线程 t 中断标志。</li>
<li>执行 <code>t.interrupted()</code> 方法，查看线程 t 中断标志然后将其设为 false 。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);              </span><br><span class="line">       t.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">       t.interrupt();                            <span class="comment">// 设置中断标志为 true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">this</span>.isInterrupted())&#123;        <span class="comment">// 查看中断标志，若为 true 结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>调用 <code>t.interrupt()</code> 方法时如果线程 t 处在阻塞/等待状态，会立即退出阻塞/等待状态，并抛出 InterruptedException 异常。因此在调用 sleep/wait/join 方法时需要捕获 InterruptedException 异常。</p>
<p>开发者经常用 <code>t.interrupt()</code> 方法使线程退出阻塞/等待状态，同时也可以在捕获异常时使线程立即终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mythread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mythread);</span><br><span class="line">        t.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        t.interrupt();                               <span class="comment">// 设置中断标志，使线程 t 退出等待状态</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;      <span class="comment">// 被设置中断标志后会自动抛出异常</span></span><br><span class="line">                System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;                             <span class="comment">// 捕获异常后终止线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全入门</title>
    <url>/2023/05/14/javase/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><hr>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><h3 id="多线程风险"><a href="#多线程风险" class="headerlink" title="多线程风险"></a>多线程风险</h3><p>在 Java 程序中，存储数据的内存空间分为共享内存和本地内存。线程在读写主存的共享变量时，会先将该变量拷贝一份副本到自己的本地内存，然后在自己的本地内存中对该变量进行操作，完成操作之后再将结果同步至主内存。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储介质</th>
<th>数据</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>共享内存</td>
<td>主内存</td>
<td>存放变量</td>
<td>多线程共享</td>
</tr>
<tr>
<td>本地内存</td>
<td>CPU 高速缓存、缓冲区、寄存器以及其它硬件优化</td>
<td>临时存放线程使用的变量副本</td>
<td>使用期间其它线程无法访问</td>
</tr>
</tbody></table>
<ul>
<li>优势：由于 CPU 执行速度明先快于内存读写速度，将运算需要的数据拷贝到 CPU 高速缓存中运算，可以大大加快程序运行速度。</li>
<li>劣势：主内存数据和本地内存的不同步，导致多个线程同时操作主内存里的同一个变量时，变量数据可能会遭到破坏。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;                            <span class="comment">// 对象中的数据由线程共享</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;final x: &quot;</span> + x);     <span class="comment">// 最后输出的数据不一定为 20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h3><p>JMM 定义了共享内存系统中多线程程序读写操作行为的规范，用来保证共享内存的原子性、可见性、有序性。</p>
<p><img src="/pic/JMM.jpg" alt="JMM"></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><strong>原子性是指一个操作，要么全部执行并且执行过程不会被打断，要么就都不执行。</strong></p>
<ul>
<li>Java 语言本身只保证了基本类型变量的读取和赋值是原子性操作。</li>
<li>简单操作的原子性可以通过 Atomic 原子类实现。</li>
<li>通过 synchronized 和 ReenTrantLock 等锁结构可以保证更大范围的原子性。</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong></p>
<ul>
<li>Java 语言会尽可能保证主内存数据和本地内存同步，但仍可能出现不可见问题。</li>
<li>通常用 volatile 关键字来保证可见性。</li>
<li>通过 synchronized 和 ReenTrantLock 等锁结构在释放锁之前会将对变量的修改刷新到主存当中，也能够保证可见性。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p><strong>有序性是指程序执行的顺序按照代码的先后顺序执行。</strong></p>
<ul>
<li>Java 内存模型具备先天的有序性。但 Java 允许编译器和处理器对指令进行重排序，可能影响多线程并发执行时的有序性。</li>
<li>通过 synchronized 和 ReenTrantLock 等锁结构可以保证有序性。</li>
<li>volatile 关键字可以禁止 JVM 的指令重排，也可以保证有序性。</li>
</ul>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><h3 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h3><ul>
<li><strong>互斥锁</strong></li>
</ul>
<p>阻塞锁。当线程需要获取的锁已经被其他线程占用时，该线程会被直接挂起。直到其他线程释放锁，由操作系统激活线程。</p>
<p>适用于锁使用者保持锁时间比较长的情况，线程挂起后不再消耗 CPU 资源。</p>
<ul>
<li><strong>自旋锁</strong></li>
</ul>
<p>非阻塞锁。当线程需要获取的锁已经被其他线程占用时，该线程会不断地消耗 CPU 的时间去试图获取锁。</p>
<p>适用于锁使用者保持锁时间比较短的情况，没有用户态和内核态调度、上下文切换的开销和损耗。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><strong>悲观锁</strong></li>
</ul>
<p>每次读写资源时都会给资源上锁，其他线程想获取该资源时会被阻塞，直到其释放锁。</p>
<p>适用于写频繁的应用场景，写资源请求不会被一直驳回。synchronized 和 ReentrantLock 等独占锁都是悲观锁。</p>
<ul>
<li><strong>乐观锁</strong></li>
</ul>
<p>读资源时不会给资源上锁，多个线程可以同时读取资源。写资源时会比对数据检查其他线程有没有更新过该资源，如果未更新就写入资源并更新版本号，否则写资源请求被驳回，重新读取并写资源。 </p>
<p>适用于读频繁的应用场景，多线程同时读取能有效提高吞吐量。CAS 算法和版本号机制都是乐观锁，悲观锁的抢占也会利用 CAS 算法。</p>
<h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul>
<li><strong>公平锁</strong></li>
</ul>
<p>加入到队列中等待唤醒，先到者先拿到锁。</p>
<p>公平锁不会出现线程饥饿，迟迟无法获取锁的情况。ReentrantLock 可以实现公平锁。</p>
<ul>
<li><strong>非公平锁</strong></li>
</ul>
<p>当线程要获取锁时通过两次 CAS 操作去抢锁，如果没抢到加入到队列中等待唤醒。</p>
<p>非公平锁的性能更好。synchronized 是非公平锁，ReentrantLock 默认情况下也是非公平锁。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>允许一个线程对同一对象多次上锁。由 JVM 记录对象被线程加锁次数，只有当线程释放掉所有锁（加锁次数为0）时，其他线程才获准进入。</p>
<p>synchronized 和 ReentrantLock 等锁结构都是可重入锁。</p>
<hr>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p><strong>修饰成员变量，每次被线程访问时，强迫从主存中读写该成员变量的值。</strong></p>
<p>volatile 关键字只能保证可见性，不能保证原子性。多个线程同时操作主内存里的同一个变量时，变量数据仍有可能会遭到破坏。</p>
<ul>
<li>线程执行过程中如果 CPU 一直满载运转，就会默认使用本地内存中的值，而没有空闲读取主存同步数据。</li>
<li>线程执行过程中一旦 CPU 获得空闲，JVM 也会自动同步主存数据，尽可能保证可见性。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        t.setRun(<span class="literal">false</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 添加 volatile 关键字，强制同步主存数据。</span></span><br><span class="line">    <span class="comment">// 删除 volatile 关键字，子线程将始终读取本地内存中 true 副本：陷入死循环。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;             </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRun</span><span class="params">(<span class="type">boolean</span> run)</span> &#123; <span class="built_in">this</span>.run = run; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">this</span>.run == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">            <span class="comment">// System.out.print(&quot;CPU rest&quot;);      打印输出时 CPU 获得空闲，自动同步主存数据。</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;end&quot;</span>);   </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p><strong>修饰方法或代码块。被线程访问时由线程抢占锁，直到执行完毕后自动释放锁。其他线程没有获得锁将无法访问上锁内容。保证了指定内容在同一时刻只有一个线程能访问。</strong></p>
<ol>
<li>修饰 static 方法实质是给当前类上锁：这个类的所有 synchronized static 方法共享一个锁。</li>
<li>修饰实例方法实质是给对象上锁：这个对象内所有的 synchronized 实例方法共享一个锁。</li>
</ol>
<p>每一个对象都有且仅有一个与之对应的 monitor 对象。synchronized 关键字修饰方法时会对方法添加标志位，当线程执行到某个方法时，JVM会去检查该方法的访问标志是否被设置，如果设置了线程会先获取这个对象所对应的 monitor 对象，再执行方法体，方法执行完后释放 monitor 。 </p>
<p>同步代码块则是在同步代码块前插入 monitorenter ，在同步代码块结束后插入 monitorexit 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m2).start();   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">500</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步对象"><a href="#同步对象" class="headerlink" title="同步对象"></a>同步对象</h4><p>创建两个不同的对象就拥有两把不同的锁，不同对象的 synchronized 实例方法互不影响。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">test1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">test2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test1::m1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test2::m2).start(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">1500</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">500</span>); &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>其他线程无法获取该对象锁，就不能访问该对象的所有 synchronized 实例方法，但仍可以访问其他方法。 synchronized 实例方法中调取的数据仍可能被其他方法修改。</p>
<p><em>在实际开发过程中，我们常常对写操作加锁，但对读操作不加锁，提升系统的并发性能。但可能会导致脏读问题。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m2).start(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">data</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(data);            <span class="comment">// false</span></span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(data);             <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            Thread.sleep(<span class="number">500</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">        <span class="built_in">this</span>.data = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>如果我们需要同步的代码只有一小部分，就没有必要对整个方法进行同步操作，我们只需要同步的代码块进行包裹。</p>
<p>修饰代码块，需要指定被上锁的对象或者类。每次线程进入 synchronized 代码块时就会要求当前线程持有该对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行操作。我们通常使用 this 对象或者当前类的 class 对象作为锁。</p>
<p><em>不要以字符串对象作为锁的对象。字符串常量在常量池里被锁定，可能会导致意想不到的阻塞。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m1).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(test::m2).start();   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                Thread.sleep(<span class="number">500</span>); </span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;&#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程执行代码出现异常时也会自动释放所有锁，因此在 synchronized 内部处理异常一定要非常小心。如果不想释放锁，使用 try-catch 语句捕获异常。</p>
<h3 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h3><ol>
<li><p>volatile 关键字用于修饰变量，synchronized 关键字用于修饰方法以及代码块。</p>
</li>
<li><p>volatile 关键字是数据同步的轻量级实现，性能比 synchronized 关键字更好。</p>
</li>
<li><p>volatile 关键字被多线程访问不会发生阻塞，synchronized 关键字可能发生阻塞。</p>
</li>
<li><p>volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重锁结构实现单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ReentrantLock-锁"><a href="#ReentrantLock-锁" class="headerlink" title="ReentrantLock 锁"></a>ReentrantLock 锁</h2><p>实现 Lock 接口，使用时需导入 <code>import java.util.concurrent.locks.*;</code>。</p>
<p>实现功能和 synchronized 关键字类似。但 synchronized 关键字是在 JVM 层面实现的，而 ReenTrantLock 是在 JDK 层面实现的。需要手动调用 lock 和 unlock 方法配合 try/finally 语句块来完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                                   </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁，通常在 try 语句里完成</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;excute&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="comment">// 解锁，必须在 finally 语句里完成</span></span><br><span class="line">                lock.unlock();    </span><br><span class="line">            &#125;                      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>ReenTrantLock 比 synchronized 增加了一些高级功能，主要有以下三点：</em></p>
<h3 id="实现等待中断"><a href="#实现等待中断" class="headerlink" title="实现等待中断"></a>实现等待中断</h3><p>调用 lockInterruptibly 方法上锁，线程中断标志置为 true 时会抛出 InterruptedException 异常并释放锁。防止线程因为无法获得锁而一直等待，常用来从外部破坏线程死锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(),<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(),<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 提前中断线程</span></span><br><span class="line">        t2.interrupt();                                      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加可中断锁</span></span><br><span class="line">                lock.lockInterruptibly();                    </span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;out&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(IllegalMonitorStateException e) &#123;&#125;  </span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 tryLock 方法上锁，可以从线程内部破坏死锁，可以更好地解决死锁问题。</p>
<ul>
<li>传入时间参数设定等待锁的时间，超时没有获得锁则中止。</li>
<li>无参则返回锁申请的结果：true表示获取锁成功，false表示获取锁失败。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(),<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(),<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();                                  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;begin&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 加锁失败直接退出</span></span><br><span class="line">                <span class="keyword">if</span>(!lock.tryLock()) &#123;                         </span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;out&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;                  </span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125; <span class="keyword">catch</span>(IllegalMonitorStateException e) &#123;&#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现公平锁"><a href="#实现公平锁" class="headerlink" title="实现公平锁"></a>实现公平锁</h3><p>允许先等待的线程先获取锁，防止线程因无法获得锁而一直等待。但由于性能优势，默认情况下仍使用非公平锁。在构造锁对象时添加参数 true 即可实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建锁对象，且声明为公平锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();                                     </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;excute&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">            lock.unlock();                                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择性通知"><a href="#选择性通知" class="headerlink" title="选择性通知"></a>选择性通知</h3><p>ReentrantLock 对象可以创建一个或多个 Condition 对象，实现线程间的等待通知机制。比 synchronized 关键字 使用 wait/notify 方法更为简便和易用。</p>
<p>线程获得 Lock 锁之后便可调用 Condition 接口的 await 方法释放锁并等待,直到有其他线程调用 Condition 的 signal 方法唤醒线程。通过设置多个 condition 对象，多个线程等待不同的 condition 对象，可以实现选择性地叫醒线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>()).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程等待通知&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程恢复运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程通知&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h2><p>原子对象的单个方法具有原子性，通过 CAS 算法和自旋操作实现，并发效率高。使用时需导入 <code>import java.util.concurrent.atomic.*</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);       <span class="comment">// 定义整型地原子类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            count.incrementAndGet();                  <span class="comment">// 原子性自增操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;final x: &quot;</span> + count);      <span class="comment">// 最后输出的数据为 20000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ThreadLocal-线程本地对象"><a href="#ThreadLocal-线程本地对象" class="headerlink" title="ThreadLocal 线程本地对象"></a>ThreadLocal 线程本地对象</h2><p>ThreadLocal 类会对每一个线程创建一个副本，用来保存其私有的数据，其他线程无法访问。简单方便且并发性好，在开发框架中被大量使用，比如 session 管理。</p>
<p><strong>ThreadLocal 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();        <span class="comment">// 构造 ThreadLocal</span></span><br><span class="line">ThreadLocal&lt;T&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();   <span class="comment">// 支持泛型</span></span><br><span class="line"></span><br><span class="line">threadLocal.get();                      <span class="comment">// 获取当前线程中保存的变量副本</span></span><br><span class="line">threadLocal.set(<span class="number">10</span>);                    <span class="comment">// 设置当前线程中变量的副本</span></span><br><span class="line">threadLocal.remove();                   <span class="comment">// 移除当前线程中变量的副本</span></span><br></pre></td></tr></table></figure>

<p><strong>ThreadLocal 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个线程从同一个 MyThread 对象取值，但结果不同。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        threadLocal.set((<span class="type">int</span>) (Math.random() * <span class="number">100D</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>javase</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2023/05/14/javase/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><hr>
<h2 id="线程池基本概念"><a href="#线程池基本概念" class="headerlink" title="线程池基本概念"></a>线程池基本概念</h2><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3><p>线程池本质上是一种对象池，用于管理线程资源。在任务执行前，需要从线程池中拿出线程来执行。在任务执行完成之后，把线程放回线程池。实际开发中，线程资源一般通过线程池提供，比如处理数据库连接、接收网络请求。</p>
<ol>
<li>线程的创建更加规范，可以合理控制开辟线程的数量。</li>
<li>不必频繁地创建和销毁线程，优化了资源的开销。</li>
</ol>
<h3 id="核心线程池"><a href="#核心线程池" class="headerlink" title="核心线程池"></a>核心线程池</h3><p><strong>(corePool) 通常状况下，线程池最多能创建的线程数。</strong></p>
<p>当有新任务等待处理时，线程池会首先判断核心线程池是否已满，如果没满则创建线程执行任务。即使有其他核心线程空闲也会创建新的核心线程来执行。</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p><strong>(BlockQueue) 线程池中等待被线程执行的任务队列。</strong></p>
<p>如果核心线程池已满，线程池会判断队列是否已满。如果队列没满，就会将任务放在队列中等待执行。</p>
<ul>
<li>ArrayBlockingQueue // 基于数组实现的阻塞队列，有界。</li>
<li>LinkedBlockingQueue // 基于链表实现的阻塞队列，可以无界。</li>
<li>SynchronousQueue // 不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作。</li>
<li>PriorityBlockingQueue // 带优先级的阻塞队列，无界。</li>
</ul>
<h3 id="最大线程池"><a href="#最大线程池" class="headerlink" title="最大线程池"></a>最大线程池</h3><p><strong>(maximumPool) 任务量很大时，线程池最多能创建的线程数。</strong></p>
<p>如果队列已满，说明当前任务量已经非常大，仅靠核心线程池内的线程数量已无法处理。线程池会判断最大线程池是否已满，如果没满则创建更多线程，从等待队列首部取得任务并执行。</p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p><strong>(RejectedExecutionHandler) 线程池拒绝过量任务的方式。</strong></p>
<p>如果最大线程池已满，表示当前服务器已无法处理这么多任务。任务会按照既定的拒绝策略被处理。</p>
<ul>
<li>CallerRunsPolicy // 在调用者线程执行。</li>
<li>AbortPolicy // 直接抛出 RejectedExecutionException 异常。</li>
<li>DiscardPolicy // （常用）任务直接丢弃，不做任何处理。</li>
<li>DiscardOldestPolicy // 丢弃队列里最旧的那个任务，再尝试执行当前任务。</li>
</ul>
<hr>
<h2 id="ThreadPoolExecutor-类"><a href="#ThreadPoolExecutor-类" class="headerlink" title="ThreadPoolExecutor 类"></a>ThreadPoolExecutor 类</h2><p>实现了 ExecutorService 接口，是 java 开发常用的线程池类。位于 java.util.concurrent 包内，使用时需要进行导入。</p>
<h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><ol>
<li>ThreadPoolExecutor 类在创建线程池时需要输入以下参数：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">2</span>;                                                <span class="comment">// 核心线程池大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">4</span>;                                             <span class="comment">// 最大线程池大小</span></span><br><span class="line"><span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">10</span>;                                             <span class="comment">// 空闲线程多久被销毁，0 表示永远不会</span></span><br><span class="line"><span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;                                    <span class="comment">// keepAliveTime 的单位</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);     <span class="comment">// 任务队列</span></span><br><span class="line"><span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameTreadFactory</span>();                <span class="comment">// 线程工厂接口，一般默认。</span></span><br><span class="line"><span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyIgnorePolicy</span>();             <span class="comment">// 拒绝策略，一般默认。</span></span><br><span class="line"></span><br><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, </span><br><span class="line">unit, workQueue, threadFactory, handler);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>ThreadPoolExecutor 类还可以重写以下方法（默认为空实现）：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="comment">// 任务执行前被调用</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;beforeExecute is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 任务执行后被调用</span></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterExecute is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程池结束后被调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">terminated</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;terminated is called&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="获取线程池信息"><a href="#获取线程池信息" class="headerlink" title="获取线程池信息"></a>获取线程池信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.getTaskCount();                 <span class="comment">// 获取已经执行或正在执行的任务数</span></span><br><span class="line">service.getCompletedTaskCount();        <span class="comment">// 获取已经执行的任务数</span></span><br><span class="line">service.getLargestPoolSize();           <span class="comment">// 获取线程池曾经创建过的最大线程数</span></span><br><span class="line">service.getPoolSize();                  <span class="comment">// 获取线程池线程数</span></span><br><span class="line">service.getActiveCount();               <span class="comment">// 获取活跃线程数（正在执行任务的线程数）</span></span><br></pre></td></tr></table></figure>

<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>可以向线程池提交的任务有两种：Runnable 接口和 Callable 接口。</p>
<h4 id="Runnable-接口"><a href="#Runnable-接口" class="headerlink" title="Runnable 接口"></a>Runnable 接口</h4><p>内部定义了 run 方法，没有返回值，不允许抛出异常。通过 execute 方法向线程池提交。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;             </span><br><span class="line">    System.out.println(<span class="string">&quot;new thread&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Callable-接口"><a href="#Callable-接口" class="headerlink" title="Callable 接口"></a>Callable 接口</h4><p>内部定义了 call 方法，允许有返回值，允许抛出异常。通过 submit 方法向线程池提交，返回一个 Future 对象。</p>
<p>可以通过调用 Future 对象的 get 方法获得数据，在返回结果前 get 方法会阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Integer&gt; f = service.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>()&#123;            </span><br><span class="line">    System.out.println(<span class="string">&quot;new thread&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(f.get());</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">service.shutdown();      <span class="comment">// 线程池不再接受新的任务，线程池中已有任务执行完成后终止。</span></span><br><span class="line">service.shutdownNow();   <span class="comment">// 线程池不再接受新的任务并对所有线程执行 interrupt 操作，清空队列并终止。</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> service.isShutdown();      <span class="comment">// 返回线程池是否关闭：不再接受新任务。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> service.isTerminated();    <span class="comment">// 返回线程池是否终止</span></span><br></pre></td></tr></table></figure>

<p><strong>ThreadPoolExecutor 类示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//自定义线程工厂</span></span><br><span class="line">        pool = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">5</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span>+r.hashCode()+<span class="string">&quot;创建&quot;</span>);</span><br><span class="line">                <span class="comment">//线程命名</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">th</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r,<span class="string">&quot;threadPool&quot;</span>+r.hashCode());</span><br><span class="line">                <span class="keyword">return</span> th;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">          </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> <span class="title class_">ThreadTask</span>());</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//输出执行线程的名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ThreadName:&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Executors-类（不常用）"><a href="#Executors-类（不常用）" class="headerlink" title="Executors 类（不常用）"></a><del>Executors 类（不常用）</del></h2><p>继承 ThreadPoolExecutor 类的线程池工厂类：提供 4 种工厂方法创建线程池。但该方法既不灵活也不安全，实际开发中很少使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个线程的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">// 指定数量的线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadExecutor(<span class="number">10</span>); </span><br><span class="line"><span class="comment">// 大小不限的线程池，60s 不使用会自动回收空闲线程。</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newCacheThreadExecutor();</span><br><span class="line"><span class="comment">// 大小不限的线程池，可定时执行任务。</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduleThreadExecutor();</span><br></pre></td></tr></table></figure>

<p><strong>Executors 类示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread id is: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javase</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全进阶</title>
    <url>/2023/05/14/javase/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">https://blog.csdn.net/mulinsen77/article/details/84583716</a></p>
<h2 id="AbstractQueuedSynchronizer-类"><a href="#AbstractQueuedSynchronizer-类" class="headerlink" title="AbstractQueuedSynchronizer 类"></a>AbstractQueuedSynchronizer 类</h2><p>又名 AQS 框架，位于 java.util.concurrent.locks 包内。用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore 等。</p>
<p>AQS 核心思想是通过以下方式，建立一套线程阻塞等待以及被唤醒时锁分配的机制。</p>
<ul>
<li>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。</li>
<li>如果被请求的共享资源被占用，就将暂时获取不到锁的线程封装成一个结点，加入到一个虚拟的双向队列 CLH 中。</li>
</ul>
<p><em>CLH 不存在真实的队列，仅存在结点之间的关联关系。</em></p>
<p><img src="/pic/CLH.png" alt="CLH"></p>
<h3 id="AQS-存储状态"><a href="#AQS-存储状态" class="headerlink" title="AQS 存储状态"></a>AQS 存储状态</h3><p>AQS 负责维护：</p>
<ol>
<li>一个 volatile int 成员变量 state</li>
<li>一个 FIFO 线程等待队列</li>
</ol>
<p>成员变量 state 表示资源状态，通过 getState/setState 方法存取。</p>
<p>线程抢占资源时会通过 CAS 操作去尝试修改 state ，成功则获取锁成功，失败则进入等待队列等待被唤醒。</p>
<h3 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a>资源共享方式</h3><p>AQS 定义两种资源共享方式</p>
<ul>
<li><strong>Exclusive（独占）</strong></li>
</ul>
<p>只有一个线程能执行，如 ReentrantLock。</p>
<p>state初始化为0，表示未锁定状态。加一后锁定。</p>
<ul>
<li><strong>Share（共享）</strong></li>
</ul>
<p>多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 。</p>
<p>返回 state 负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</p>
<h3 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<p>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。</p>
<p>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）<br>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
<p>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="ReentrantReadWriteLock-锁"><a href="#ReentrantReadWriteLock-锁" class="headerlink" title="ReentrantReadWriteLock 锁"></a>ReentrantReadWriteLock 锁</h2><p>Java 的并发包提供了读写锁 ReentrantReadWriteLock ，其拥有两个锁：读锁-共享锁；写锁-排他锁。如果其他线程没有持有写锁，线程就能获得读锁。而只有其他线程没有持有任何锁，线程才能获得写锁。这样在没有写操作的时候，允许多个线程同时读一个资源，提高并发效率。</p>
<p>一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；写锁可以降级为读锁；读锁不能升级为写锁。</p>
<h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>Semaphore 类是一个同步工具类，需要进行导入：<code>import java.util.concurrent.Semaphore</code>。</p>
<p>synchronized 和 ReentrantLock 一次只允许一个线程访问某个资源，如果指定多个线程同时访问某个资源需要钱使用 Semaphore 类。线程执行时调用 acquire 方法申请信号量，如果剩余信号量不足则必须等待其他线程执行完毕后调用 release 方法释放信号量。</p>
<p><strong>Semaphore 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);       </span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>, <span class="literal">true</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// Semaphore 构造方法设定了初始信号量，可以为 0。默认为非公平锁，设定属性 true 则为公平锁。</span></span><br><span class="line"></span><br><span class="line">semaphore.acquire();              <span class="comment">// 线程获取一个信号量</span></span><br><span class="line">semaphore.acquire(<span class="number">5</span>);             <span class="comment">// 线程获取五个信号量</span></span><br><span class="line"></span><br><span class="line">semaphore.release();              <span class="comment">// 线程释放一个信号量</span></span><br><span class="line">semaphore.release(<span class="number">5</span>);             <span class="comment">// 线程释放五个信号量</span></span><br><span class="line"></span><br><span class="line">semaphore.availablePermits();     <span class="comment">// 读取剩余信号量</span></span><br></pre></td></tr></table></figure>

<p><strong>Semaphore 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreExample1</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 设置 20 个信号量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// final Semaphore semaphore = new Semaphore(20, true);  公平锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">threadnum</span> <span class="operator">=</span> i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();             <span class="comment">// 获取一个信号量</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();             <span class="comment">// 释放一个信号量</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;threadnum:&quot;</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="CountDownLatch-倒计时器"><a href="#CountDownLatch-倒计时器" class="headerlink" title="CountDownLatch 倒计时器"></a>CountDownLatch 倒计时器</h2><p>CountDownLatch 类是一个同步工具类，需要进行导入：<code>import java.util.concurrent.CountDownLatch</code>。</p>
<p>其通过 await 方法设置一个屏障，线程到达后被阻塞。直到其他线程调用 countDown 方法达到 N 次后才允许向后执行。 CountDownLatch 类是一次性的，计数器值只能在构造方法中初始化一次，不能被重复使用。常用来协同多个线程之间的执行顺序，比如主线程需要等待多个组件加载完毕之后再继续执行。</p>
<p><strong>CountDownLatch 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountDownLatch 构造方法设定了门闩个数。</span></span><br><span class="line"></span><br><span class="line">latch.countDown();                <span class="comment">// 解锁门闩，门闩个数减一</span></span><br><span class="line">latch.await();                    <span class="comment">// 线程等待门闩，个数为 0 后向后执行</span></span><br></pre></td></tr></table></figure>

<p><strong>CountDownLatch 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;打开门闩&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h2><p>CyclicBarrier 类也是一个同步工具类，需要进行导入：<code>import java.util.concurrent.CyclicBarrier</code>。</p>
<p>其通过 await 方法设置一个屏障，线程到达后被阻塞。只有当 N 个线程都到达屏障后才允许这些线程向后执行。和 CountDownLatch 不同，CyclicBarrier 可循环利用。常用于多线程计算数据，最后合并计算结果的场景。</p>
<p><strong>CyclicBarrier 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> CyclicBarrier(<span class="number">10</span>); </span><br><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> CyclicBarrier(<span class="number">10</span>, ()-&gt; System.out.println(<span class="string">&quot;open&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// CyclicBarrier 构造方法设定了参与线程的个数 N，也可以选择设定在第 N 个线程到达屏障时执行方法。</span></span><br><span class="line"></span><br><span class="line">barrier.await();                             <span class="comment">// 线程必须等到 N 个线程才能向后执行</span></span><br><span class="line">barrier.await(<span class="number">20</span>, TimeUnit.SECONDS);         <span class="comment">// 线程等待规定时间后无论如何都会向后执行</span></span><br></pre></td></tr></table></figure>

<p><strong>CyclicBarrier 示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栅栏开启&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; 到达栅栏&quot;</span>);</span><br><span class="line">            barrier.await();</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot; 冲破栅栏&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javase</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javase</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC</title>
    <url>/2023/05/14/javaee/JDBC/JDBC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><hr>
<h2 id="JDBC-简介"><a href="#JDBC-简介" class="headerlink" title="JDBC 简介"></a>JDBC 简介</h2><p>JDBC 是 Java EE 提供的数据库接口，负责连接 java 程序和后台数据库。安装数据库驱动程序后，开发者可以按照 JDBC 规范直接在 Java 程序上对数据库进行操作，由数据库厂商负责具体实现。</p>
<h3 id="驱动安装"><a href="#驱动安装" class="headerlink" title="驱动安装"></a>驱动安装</h3><ol>
<li>下载 MySQL 驱动包，解压后得到 jar 库文件：<a href="http://dev.mysql.com/downloads/connector/j/">http://dev.mysql.com/downloads/connector/j/</a></li>
<li>打开 IDE，在对应项目中 configure build path 导入 jar 库文件。</li>
</ol>
<hr>
<h2 id="JDBC-编程"><a href="#JDBC-编程" class="headerlink" title="JDBC 编程"></a>JDBC 编程</h2><p>JDBC 常用工具类位于 sql 包内，使用时需导入：<code>import java.sql.*</code> 。使用时可能 抛出 SQLException 异常。</p>
<h3 id="加载驱动"><a href="#加载驱动" class="headerlink" title="加载驱动"></a>加载驱动</h3><p>JDBC 首先要使用反射机制加载驱动类，并创建其对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);          <span class="comment">// MySQL 数据库驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);   <span class="comment">// Oracle 数据库驱动</span></span><br></pre></td></tr></table></figure>

<h3 id="连接数据库-Connection"><a href="#连接数据库-Connection" class="headerlink" title="连接数据库 Connection"></a>连接数据库 Connection</h3><p>JDBC 由 Connection 类负责连接数据库，参数中输入数据库 URL、账号、密码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 连接本地 RUNOOB 数据库，需设置时区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;            <span class="comment">// 数据库账号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;          <span class="comment">// 数据库密码</span></span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(DB_URL,USER,PASS);    <span class="comment">// 建立连接</span></span><br><span class="line">conn.close();                                                       <span class="comment">// 关闭连接</span></span><br></pre></td></tr></table></figure>

<h3 id="执行语句-Statement"><a href="#执行语句-Statement" class="headerlink" title="执行语句 Statement"></a>执行语句 Statement</h3><p>JDBC 由 Statement 类负责发送 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> = conn.createStatement();         <span class="comment">// 创建 Statement 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// executeQuery 执行查询操作，返回 ResultSet 结果集</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM websites&quot;</span>); </span><br><span class="line"><span class="comment">// executeUpdate 执行更新操作，返回 int 数据表示受影响行数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> stmt.executeUpdate(<span class="string">&quot;DELETE * FROM websites&quot;</span>); </span><br><span class="line">     </span><br><span class="line">stmt.close();                                      <span class="comment">// 关闭 Statement 对象</span></span><br></pre></td></tr></table></figure>

<h3 id="返回查询结果-ResultSet"><a href="#返回查询结果-ResultSet" class="headerlink" title="返回查询结果 ResultSet"></a>返回查询结果 ResultSet</h3><p>JDBC 由 ResultSet 类返回 select 语句执行结果，读取 executeQuery 方法返回的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(sql);             <span class="comment">// 获取返回结果</span></span><br><span class="line">               </span><br><span class="line"><span class="keyword">while</span>(rs.next())&#123;                                  <span class="comment">// 输出返回结果</span></span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JDBC-进阶"><a href="#JDBC-进阶" class="headerlink" title="JDBC 进阶"></a>JDBC 进阶</h2><h3 id="预编译-PreparedStatement"><a href="#预编译-PreparedStatement" class="headerlink" title="预编译 PreparedStatement"></a>预编译 PreparedStatement</h3><p>PreparedStatement 类继承自 Statement 类，在 JDBC 开发中用来取代前者。有以下两个优势：</p>
<ol>
<li>可对 SQL 语句进行预编译，可以灵活地修改 SQL 语句，提高开发效率。 </li>
<li>把用户输入单引号转义，防止恶意注入，保护数据库安全。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.preparedStatement(sql);   <span class="comment">// 创建对象并预编译</span></span><br><span class="line">stmt.setInt(<span class="number">1</span>, <span class="number">755</span>);                                          <span class="comment">// 在第一个占位符(?)位置插入数字</span></span><br><span class="line">stmt.setString(<span class="number">2</span>, <span class="string">&quot;MrJoker&quot;</span>);                                 <span class="comment">// 在第二个占位符(?)位置插入字符串</span></span><br><span class="line">stmt.executeUpdate();                                         <span class="comment">// 更新并执行</span></span><br></pre></td></tr></table></figure>

<h3 id="批处理-executeBath"><a href="#批处理-executeBath" class="headerlink" title="批处理 executeBath"></a>批处理 executeBath</h3><p>PreparedStatement 类可以通过 executeBath 方法批量处理 SQL 语句，进一步提高效率。其返回值为一个 int[] 数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO test(id,name) VALUES (?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    stmt.setInt(<span class="number">1</span>, i);</span><br><span class="line">    stmt.setString(<span class="number">2</span>, (i + <span class="string">&quot;号士兵&quot;</span>));</span><br><span class="line">    stmt.addBatch();                                           <span class="comment">// 语句添加到批处理序列中</span></span><br><span class="line">&#125;</span><br><span class="line">preparedStatement.executeBatch();                              <span class="comment">// 语句发送给数据库批量处理</span></span><br><span class="line">preparedStatement.clearBatch();                                <span class="comment">// 清空批处理序列</span></span><br></pre></td></tr></table></figure>


<h3 id="大文本和二进制数据"><a href="#大文本和二进制数据" class="headerlink" title="大文本和二进制数据"></a>大文本和二进制数据</h3><ul>
<li><p>clob 用于存储大文本</p>
</li>
<li><p>blob用于存储二进制数据</p>
</li>
</ul>
<hr>
<h2 id="JDBC-示例"><a href="#JDBC-示例" class="headerlink" title="JDBC 示例"></a>JDBC 示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 适用于 JDK 1.8 以后版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySQLTest</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JDBC_DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DB_URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&amp;serverTimezone=UTC&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASS</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> useMethod（）&#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;                  </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;                    </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(JDBC_DRIVER);                                </span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);    </span><br><span class="line">            stmt = conn.preparedStatement(<span class="string">&quot;SELECT id, name, url FROM websites&quot;</span>);  </span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery();        </span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(rs.getString(<span class="string">&quot;area_id&quot;</span>));   </span><br><span class="line">            &#125;</span><br><span class="line">            rs.close(); </span><br><span class="line">            stmt.close(); </span><br><span class="line">            conn.close();                    </span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;         <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;             <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;                                                 </span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                <span class="keyword">if</span>(stmt != <span class="literal">null</span>) stmt.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;&#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn != <span class="literal">null</span>) conn.close(); </span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;&#125; </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaee</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA</title>
    <url>/2023/05/14/javaee/JDBC/JPA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><hr>
<h2 id="JPA-相关概念"><a href="#JPA-相关概念" class="headerlink" title="JPA 相关概念"></a>JPA 相关概念</h2><h3 id="ORM-框架"><a href="#ORM-框架" class="headerlink" title="ORM 框架"></a>ORM 框架</h3><p>(Object Relational Mapping) 建立 Java 程序实体类与数据库表之间的映射关系。使用 ORM 框架进行编程 Java 程序会根据开发者配置，在运行时自动把数据对象持久化到数据库中，比直接使用 JDBC 编程更为方便和强大。</p>
<p>常见的 ORM 框架有 Hibernate, MyBatis 等。</p>
<h3 id="JPA-规范"><a href="#JPA-规范" class="headerlink" title="JPA 规范"></a>JPA 规范</h3><p>(Java Persistence API) Java 程序和数据库连接的 Java EE 标准，本质上是一种 ORM 规范。使用户不必在 Java 程序中书写 SQL 语句就能直接把数据对象持久化到数据库中，由数据库厂商负责具体实现。</p>
<h4 id="JDBC-和-JPA-的区别"><a href="#JDBC-和-JPA-的区别" class="headerlink" title="JDBC 和 JPA 的区别"></a>JDBC 和 JPA 的区别</h4><ul>
<li>JDBC 是面向 SQL 的规范和接口，用户仍需要在 java 程序中书写 SQL 语句。</li>
<li>JPA 是直接面向数据对象的规范和接口，可以通过直接操作对象来实现持久化，大大简化了操作的繁杂度。</li>
</ul>
<p>P.S. Hibernate 是符合 JPA 规范的，而 MyBatis 却不符合，因为 MyBatis 还需要书写 SQL 语句。</p>
<p><a href="https://www.jianshu.com/p/c14640b63653">https://www.jianshu.com/p/c14640b63653</a></p>
<hr>
<h2 id="Spring-JPA"><a href="#Spring-JPA" class="headerlink" title="Spring JPA"></a>Spring JPA</h2><p>Spring 框架中提供了对数据操作的框架 SpringData ； SpringData 框架下则提供了基于 JPA 标准操作数据的模块 SpringData JPA 。</p>
<p>import javax.persistence.Column;<br>import javax.persistence.Entity;<br>import javax.persistence.Id;<br>import javax.persistence.Table;</p>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>类</p>
<p><code>@Entity</code> 声明实体类，自动对应数据库表（必选）</p>
<p><code>@Table(name = &quot;AUTH_USER&quot;)</code> 声明了数据库实体对应的表名，如果没有默认表名和实体名一致。</p>
<p>属性</p>
<p><code>@Id</code> 声明属性对应数据库字段是主键。</p>
<p><code>@Column(length = 32)</code> 用来声明实体属性的表字段的定义。</p>
<ol>
<li>name - 属性对应数据库字段名，默认和属性名称一致。</li>
<li>length - 属性对应数据库字段长度，默认 255。</li>
<li>属性对应数据库字段类型会自动推断。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;AUTH_USER&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDO</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column(length = 32)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时，系统自动将数据表给我们建好了。</p>
<p>我们要实现一个增加、删除、修改、查询功能的持久层服务，那么我只需要声明一个接口，这个接口继承<br>org.springframework.data.repository.Repository&lt;T, ID&gt; 接口或者他的子接口就行。这里为了功能的完备，我们继承了 org.springframework.data.jpa.repository.JpaRepository&lt;T, ID&gt; 接口。其中 T 是数据库实体类，ID 是数据库实体类的主键。<br>然后再简单的在这个接口上增加一个 @Repository 注解就结束了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserDAO, id&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> UserDO userDO = new UserDO();<br>        userDO.setId(1L);<br>        userDO.setName(“风清扬”);</p>
]]></content>
      <categories>
        <category>javaee</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/2023/05/14/javaee/JDBC/MyBatis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><hr>
]]></content>
      <categories>
        <category>javaee</category>
        <category>JDBC</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet</title>
    <url>/2023/05/14/javaee/Servlet/servlet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><hr>
<h2 id="Servlet-介绍"><a href="#Servlet-介绍" class="headerlink" title="Servlet 介绍"></a>Servlet 介绍</h2><h3 id="Servlet-功能"><a href="#Servlet-功能" class="headerlink" title="Servlet 功能"></a>Servlet 功能</h3><p>Servlet 程序运行在服务器端，处理浏览器带来的 HTTP 请求，并返回响应给浏览器，实现用户交互。</p>
<p><img src="/pic/servlet.png" alt="img"></p>
<p>相比于 CGI（公共网关接口），Servlet 有以下几点优势：</p>
<ol>
<li>性能明显更好。</li>
<li>在 Web 服务器的地址空间内执行，不必单独创建进程来处理每个客户端请求。</li>
<li>使用 Java 编写，平台无关性。</li>
<li>进行了一系列限制，可以保护服务器计算机上的资源。</li>
</ol>
<p><em>目前主流框架的底层响应都以 Servlet 的方式实现。</em></p>
<h3 id="Servlet-生命周期"><a href="#Servlet-生命周期" class="headerlink" title="Servlet 生命周期"></a>Servlet 生命周期</h3><ul>
<li><strong>加载和初始化</strong></li>
</ul>
<p>服务器第一次访问 Servlet 时会创建 Servlet 的实例（一个 Servlet 类只有一个实例）。</p>
<p>之后服务器调用 <code>init</code> 方法初始化 Servlet 对象，创建或加载初始化数据。</p>
<ul>
<li><strong>处理服务</strong></li>
</ul>
<p>每接收到一个 Http 请求时，服务器会产生一个新的线程并调用 <code>service</code> 方法处理请求。</p>
<ul>
<li><strong>销毁和垃圾回收</strong></li>
</ul>
<p>当 Servlet 被销毁时，服务器调用 <code>destroy</code> 方法释放 Servlet 对象所占的资源。</p>
<p>最后由 JVM 对 Servlet 实例进行垃圾回收。</p>
<hr>
<h2 id="Servlet-开发"><a href="#Servlet-开发" class="headerlink" title="Servlet 开发"></a>Servlet 开发</h2><h3 id="Servlet-接口"><a href="#Servlet-接口" class="headerlink" title="Servlet 接口"></a>Servlet 接口</h3><p>实现 Serlvet 接口，即可得到 Servlet 的 Java 类。Servlet 接口内定义了以下 5 个方法。</p>
<ul>
<li><strong>ServletRequest 类</strong>：用户请求</li>
<li><strong>ServletResponse 类</strong>：返回信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig arg0)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理服务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest arg0, ServletResponse arg1)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 Servlet 配置</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 Servlet 信息</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HttpServlet-类"><a href="#HttpServlet-类" class="headerlink" title="HttpServlet 类"></a>HttpServlet 类</h3><p>在 Java EE 中， HttpServlet 类已经实现了 Servlet 接口。实际开发中我们可以直接使用。</p>
<p>HttpServlet 类中 service 方法会根据 HTTP 请求类型，选择调用 <code>doGet</code>、<code>doPost</code>、<code>doPut</code>，<code>doDelete</code> 等方法。</p>
<ul>
<li><strong>HttpServletRequest 类</strong>：用户请求</li>
<li><strong>HttpServletResponse 类</strong>：服务器响应</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="comment">// 接收 GET 请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Get&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收 POST 请求</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span>  <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Post&quot;</span>);</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HttpServletRequest/HttpServletResponse 对象封装了 HTTP 请求头/响应头中的所有信息，可以通过对象提供的方法获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




<p>通过 request 对象提供的 getRequestDispatche(String path)方法返回一个 RequestDispatcher 对象，调用这个对象的 forward 方法可以实现请求转发。</p>
<p>request 对象同时也是一个域对象(Map 容器)，开发人员通过 request 对象在实现转发时，可以通过 setAttribute 方法将数据带给其它 web 资源处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 通过 ruquest 对象传递一个值</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">        <span class="comment">// 跳转登录页面（重定向）</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>










<hr>
<p>Servlet 可以设置初始化参数，供Servlet内部使用。，在它初始化时调用init()方法，销毁时调用destroy()方法。Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），一个Servlet可以设置多个URL访问。Servlet不是线程安全，因此要谨慎使用类变量。</p>
<p>创建 Serlvet 类后，我们在 web.xml 配置。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建的servlet 类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--创建的servlet 包名--&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--初始化参数--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>          </span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>                </span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--建立映射：通过url访问servlet类--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>                                  </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Servlet</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/2023/05/14/javaee/spring/Spring/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Spring-1"><a href="#Spring-1" class="headerlink" title="Spring"></a>Spring</h3><p>Spring 是用于开发 Java 应用程序的开源框架，为解决企业应用开发的复杂性而创建。</p>
<ol>
<li>Spring 的基本设计思想是利用 IOC（依赖注入）和 AOP （面向切面）解耦应用组件，降低应用程序各组件之间的耦合度。</li>
<li>在这两者的基础上，Spring 逐渐衍生出了其他的高级功能：如 Security，JPA 等。</li>
</ol>
<h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring MVC 是 Spring 的子功能模块，专用于 Web 开发。</p>
<p>Spring MVC 基于 Servlet 实现，将 Web 应用中的数据业务、显示逻辑和控制逻辑进行分层设计。开发者可以直接调用 Spring MVC 框架中 Spring 解耦的组件，快速构建 Web 应用。</p>
<h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>Spring Boot 是用于简化创建 Spring 项目配置流程，快速构建 Spring 应用程序的辅助工具。Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能。但 在创建 Spring 项目时，Spring Boot 可以：</p>
<ol>
<li>自动添加 Maven 依赖，不需要在 pom.xml 中手动添加配置依赖。</li>
<li>不需要配置 XML 文件，将全部配置浓缩在一个 appliaction.yml 配置文件中。</li>
<li>自动创建启动类，代表着本工程项目和服务器的启动加载。</li>
<li>内嵌 Tomcat 、Jetty 等容器，无需手动部署 war 文件。</li>
</ol>
<hr>
<h2 id="Spring-Boot-配置"><a href="#Spring-Boot-配置" class="headerlink" title="Spring Boot 配置"></a>Spring Boot 配置</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>在Spring Boot中，引入的所有包都是 starter 形式：</p>
<p>spring-boot-starter-web-services，针对 SOAP Web Services<br>spring-boot-starter-web，针对 Web 应用与网络接口<br>spring-boot-starter-jdbc，针对 JDBC<br>spring-boot-starter-data-jpa，基于 Hibernate 的持久层框架<br>spring-boot-starter-cache，针对缓存支持</p>
<h3 id="默认映射路径"><a href="#默认映射路径" class="headerlink" title="默认映射路径"></a>默认映射路径</h3><ul>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code> </li>
<li><code>classpath:/public/</code></li>
</ul>
<p>优先级顺序：META-INF/resources &gt; resources &gt; static &gt; public</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>位于 resources 文件夹下，支持以下两种格式。由 Spring Boot 自动加载。</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment">#访问前缀</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#数据库驱动</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jc.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="comment">#数据库用户名</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据库密码</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">wdh19970506</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="comment">#配置文件路径</span></span><br><span class="line"><span class="attr">mybatis_config_file</span>=<span class="string">mybatis-config.xml</span></span><br><span class="line"><span class="comment">#SQL语句配置路径</span></span><br><span class="line"><span class="attr">mapper_path</span>=<span class="string">/mapper/**.xml</span></span><br><span class="line"><span class="comment">#实体类所在包</span></span><br><span class="line"><span class="attr">type_alias_package</span>=<span class="string">com.example.demo.entity</span></span><br></pre></td></tr></table></figure>

<ul>
<li>JDBC 连接 Mysql5 驱动： com.mysql.jdbc.Driver</li>
<li>JDBC 连接 Mysql6 驱动： com.mysql.cj.jdbc.Driver , URL 必须要指定时区 serverTimezone ！</li>
</ul>
<p><strong>多重配置</strong></p>
<p>在 Spring Boot 中，我们往往需要配置多个不同的配置文件去适应不同的环境：</p>
<ul>
<li><code>application-dev.properties</code> 开发环境</li>
<li><code>application-test.properties</code> 测试环境</li>
<li><code>application-prod.properties</code> 生产环境</li>
</ul>
<p>只需要在程序默认配置文件 <code>application.properties</code> 中设置环境，就可以使用指定的配置。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>

<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p> <code>@SpringBootApplication</code> 类：作为程序入口，在创建 Spring Boot 项目时自动创建。</p>
<p> 等同于 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code> ，会自动完成配置并扫描路径下所有包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>Spring 需要定义调度程序 servlet ，映射和其他支持配置。我们可以使用 web.xml 文件或 Initializer 类来完成此操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebAppInitializer</span> <span class="keyword">implements</span> <span class="title class_">WebApplicationInitializer</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onStartup</span><span class="params">(ServletContext container)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.setConfigLocation(<span class="string">&quot;com.pingfangushi&quot;</span>);</span><br><span class="line">          container.addListener(<span class="keyword">new</span> <span class="title class_">ContextLoaderListener</span>(context));</span><br><span class="line">          ServletRegistration.<span class="type">Dynamic</span> <span class="variable">dispatcher</span> <span class="operator">=</span> container</span><br><span class="line">          .addServlet(<span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>(context));</span><br><span class="line">        dispatcher.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">        dispatcher.addMapping(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还需要将 <code>@EnableWebMvc</code> 注释添加到 <code>@Configuration</code> 类，并定义一个视图解析器来解析从控制器返回的视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; </span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">InternalResourceViewResolver</span> <span class="variable">bean</span></span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InternalResourceViewResolver</span>();</span><br><span class="line">      bean.setViewClass(JstlView.class);</span><br><span class="line">      bean.setPrefix(<span class="string">&quot;/WEB-INF/view/&quot;</span>);</span><br><span class="line">      bean.setSuffix(<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP</title>
    <url>/2023/05/14/javaee/spring/SpringAOP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h1><p><a href="https://www.cnblogs.com/joy99/p/10941543.html">https://www.cnblogs.com/joy99/p/10941543.html</a></p>
<p>超级详细版：<a href="http://shouce.jb51.net/spring/aop.html">http://shouce.jb51.net/spring/aop.html</a></p>
<hr>
<h2 id="AOP-原理"><a href="#AOP-原理" class="headerlink" title="AOP 原理"></a>AOP 原理</h2><h3 id="面向切面"><a href="#面向切面" class="headerlink" title="面向切面"></a>面向切面</h3><p>( Aspect Orient Programming ) 面向切面编程，是面向对象编程(OOP) 的一种补充。</p>
<p>在 Java 程序自上而下处理主业务时，也会经常处理一些和主业务逻辑无关的问题（比如在接收用户访问请求时，计算程序响应该请求的运行时间）。这些代码如果和主逻辑代码混淆，会导致后期难以维护。</p>
<p>AOP 就是将这些横切性问题和主逻辑解耦。保证开发者不修改主逻辑代码的前提下，能为系统中的业务组件添加删除、或复用某种功能。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>AOP 的本质是修改业务组件实际执行方法的源代码。即代理类 A 封装了目标类 B ，外部调用 B 的目标方法时会被代理类 A 拦截，代理类 A 一方面执行切面逻辑，一方面把调用转发给目标类 B ，执行目标方法。</p>
<p>该过程是代理模式的实现，代理方式有以下两种：</p>
<ul>
<li><strong>静态 AOP</strong> ：在编译阶段对程序源代码进行修改，生成静态的 AOP 代理类（字节码文件已被修改）。性能更好。</li>
<li><strong>动态 AOP</strong> ：在运行阶段动态生成代理对象。灵活性更好。</li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>Spring 中的 AOP 是通过动态代理实现的，有以下两种方式：</p>
<ul>
<li><strong>JDK 动态代理</strong></li>
</ul>
<p>利用反射机制生成一个实现代理接口的类，在调用具体方法前调用 InvokeHandler 来处理。</p>
<p>JDK 代理只能对实现接口的类生成代理。代理生成的是一个接口对象，因此代理类必须实现了接口，否则会抛出异常。</p>
<ul>
<li><strong>CGlib 动态代理</strong></li>
</ul>
<p>直接操作字节码对代理对象类的字节码文件加载并修改，生成子类来处理。</p>
<p>CGlib 代理针对类实现代理，对指定的类生成一个子类并覆盖其中的方法，因此不能代理 final 类。</p>
<hr>
<h2 id="AOP-注解详解"><a href="#AOP-注解详解" class="headerlink" title="AOP 注解详解"></a>AOP 注解详解</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对负责扫描组件的配置文件类(@Configuration) 添加 <code>@EnableAspectJAutoProxy</code> 注解，启用 AOP 功能。</p>
<p><strong>默认通过 JDK 动态代理方式进行织入。</strong>但必须代理一个实现接口的类，否则会抛出异常。</p>
<p>注解改为 <code>@EnableAspectJAutoProxy(proxyTargetClass = true)</code>：</p>
<p>通过 cglib 的动态代理方式进行织入。但如果拓展类的方法被 final 修饰，则织入无效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.company.project.service.Meal.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>对组件类(@component) 添加 <code>@Aspect</code> 注解，表示该类为切面类。</p>
<h4 id="增强类型"><a href="#增强类型" class="headerlink" title="增强类型"></a>增强类型</h4><p><strong>前置通知</strong></p>
<p>切面方法注解 <code>@Before</code> 表示目标方法调用前，执行该切面方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后置通知</strong></p>
<ul>
<li>切面方法注解 <code>@After</code> 表示目标方法返回或抛出异常后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterReturning</code> 只在目标方法返回后，执行该切面方法。</li>
<li>切面方法注解 <code>@AfterThrowing</code> 只在目标方法抛出异常后，执行该切面方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>环绕通知</strong></p>
<p>切面方法注解 <code>@Around</code> 表示切面方法执行过程中，执行目标方法。</p>
<p>传入参数为 ProceedingJoinPoint 类对象，表示目标方法。在切面方法中调用其 proceed 方法来执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">        pj.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切点声明"><a href="#切点声明" class="headerlink" title="切点声明"></a>切点声明</h4><p>在切面方法中需要声明切面方法要切入的目标方法，execution 指示器是我们定义切点时最主要使用的指示器。</p>
<p>格式为： <code>execution(返回数据类型 路径.类.方法(传入参数类型))</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>execution(* com.company.project.service.Meal.eat(..))</code></td>
<td>执行 Meal 类的 eat 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.eat(int,String))</code></td>
<td>执行 Meal 类的 eat(int,String) 方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.Meal.*(..))</code></td>
<td>执行 Meal 类的所有方法时切入</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service.*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（不包含子包）</td>
</tr>
<tr>
<td><code>execution(* com.company.project.service..*.*(..))</code></td>
<td>执行 service 包内的任意方法时切入（包含子包）</td>
</tr>
<tr>
<td><code>execution(public * *(..))</code></td>
<td>执行所有目标类的所有 public 方法时切入</td>
</tr>
<tr>
<td><code>execution(* pre*(...))</code></td>
<td>执行所有目标类所有以 pre 为前缀的方法时切入</td>
</tr>
</tbody></table>
<p>还有一些其他指示器：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>within(com.company.project.service.*)</code></td>
<td>执行 service 包内的任意方法时切入</td>
</tr>
<tr>
<td><code>this(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的代理对象的任意方法时切入</td>
</tr>
<tr>
<td><code>target(com.company.project.service.AccountService)</code></td>
<td>执行实现 AccountService 接口的目标对象的任意方法时切入</td>
</tr>
<tr>
<td><code>args(java.io.Serializable)</code></td>
<td>任何一个只接受一个参数，并且运行时所传入的参数是 Serializable 接口的方法</td>
</tr>
</tbody></table>
<ul>
<li>多个匹配条件之间使用链接符连接： <code>&amp;&amp;</code>、<code>||</code>、<code>!</code> 。</li>
<li>within 指示器表示可以选择的包，bean 指示器可以在切点中选择 bean 。</li>
</ul>
<p>如参数 <code>execution(String com.company.project.service.test1.IBuy.buy(double)) &amp;&amp; args(price) &amp;&amp; bean(girl)</code> </p>
<p>要求返回类型为 String ；参数类型为 double ；参数名为 price ；调用目标方法的 bean 名称为 girl 。</p>
<p><strong>简化代码</strong></p>
<p>对于类中要频繁要切入的目标方法，我们可以使用 <code>@Pointcut</code> 注解声明切点表达式，简化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EatPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.company.project.service.Meal.eat(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cook</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">party</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;cook&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;clean&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(String com.company.project.service.Meal.eat(double)) &amp;&amp; args(price) &amp;&amp; bean(people)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point2</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point2(price)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pay</span><span class="params">(ProceedingJoinPoint pj, <span class="type">double</span> price)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pj.proceed();</span><br><span class="line">            <span class="keyword">if</span> (price &gt; <span class="number">100</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;can not afford&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;没有购买&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;购买&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="常用-AOP"><a href="#常用-AOP" class="headerlink" title="常用 AOP"></a>常用 AOP</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul>
<li><p><code>@ControllerAdvice</code> / <code>@RestControllerAdvice</code>: 标注当前类为所有 Controller 类服务</p>
</li>
<li><p><code>@ExceptionHandler</code>: 标注当前方法处理异常（默认处理 RuntimeException）<br><code>@ExceptionHandler(value = Exception.class)</code>: 处理所有异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ControllerExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(Throwable.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleOtherException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;错误=%s,位置=%s&quot;</span>, e.toString(), e.getStackTrace()[<span class="number">0</span>].toString());</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.UNKNOWN_ERROR.getErrorCode(), message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(StreamPlatformException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleVenusException</span><span class="params">(StreamPlatformException e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(e.getErrorCode(), e.getMessageToUser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(FormValidationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultBean <span class="title function_">handleFormValidationException</span><span class="params">(FormValidationException e)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        e.getResult().getAllErrors().forEach(objectError -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (objectError <span class="keyword">instanceof</span> FieldError) &#123;</span><br><span class="line">                <span class="type">FieldError</span> <span class="variable">fieldError</span> <span class="operator">=</span> (FieldError) objectError;</span><br><span class="line">                message.append(<span class="string">&quot;参数&quot;</span>).append(fieldError.getField())</span><br><span class="line">                        .append(<span class="string">&quot;错误值为&quot;</span>).append(fieldError.getRejectedValue())</span><br><span class="line">                        .append(fieldError.getDefaultMessage());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                message.append(objectError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> ResultBean.error(ErrorCode.PARAMETER_VALIDATION_ERROR.getErrorCode(),</span><br><span class="line">                String.format(ErrorCode.PARAMETER_VALIDATION_ERROR.getMessage(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ul>
<li><strong>拦截器(Interceptor)</strong></li>
</ul>
<p>Java Web 中，在执行 Controller 方法前后对 Controller 请求进行拦截和处理。依赖于 web 框架，在 Spring 配置。在实现上基于 Java 的反射机制。</p>
<ul>
<li><strong>过滤器(Filter)</strong></li>
</ul>
<p>Java Web 中，在 request/response 传入 Servlet 前，过滤信息或设置参数。依赖于 servlet 容器，在 web.xml 配置。在实现上基于函数回调。</p>
<blockquote>
<p>两者常用于修改字符编码、删除无用参数、登录校验等。Spring 框架中优先使用拦截器：功能接近、使用更加灵活。</p>
</blockquote>
<p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在配置中引入拦截器对象（单独编写拦截器类）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 导入拦截器对象，默认拦截全部</span></span><br><span class="line">    <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">myInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除配置</span></span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);               </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);                       </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 拦截配置</span></span><br><span class="line">    addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器类通过实现 HandlerInterceptor 接口或者继承 HandlerInterceptorAdapter 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 预处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 检查 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 重定向到登录页面</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 善后处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INTERCEPTOR POSTHANDLE CALLED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器类通过继承 Filter 类实现，直接添加注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>                                                                <span class="comment">// 作为组件，交给容器处理</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span>                                                     <span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/login/*&quot;,filterName = &quot;loginFilter&quot;)</span>           <span class="comment">// 设定过滤路径和名称</span></span><br><span class="line"><span class="meta">@Order(1)</span>                                                                 <span class="comment">// 设定优先级（值小会优先执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤器前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行内部逻辑</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">// 过滤器后执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>调用顺序</strong></p>
<p><img src="/pic/filter.png" alt="filter"></p>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2023/05/14/javaee/spring/SpringBootService/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>进一步对Spring中的操作进行封装，通过注解（@）取代xml文件进行自动配置，简化编程。</p>
<hr>
<h2 id="默认映射路径"><a href="#默认映射路径" class="headerlink" title="默认映射路径"></a>默认映射路径</h2><ul>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code> </li>
<li><code>classpath:/public/</code></li>
</ul>
<p>优先级顺序：META-INF/resources &gt; resources &gt; static &gt; public</p>
<hr>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>resources 文件夹下，支持以下两种格式。由 Spring Boot 自动加载。</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment">#访问前缀</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#数据库驱动</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jc.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="comment">#数据库用户名</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据库密码</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">wdh19970506</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="comment">#配置文件路径</span></span><br><span class="line"><span class="attr">mybatis_config_file</span>=<span class="string">mybatis-config.xml</span></span><br><span class="line"><span class="comment">#SQL语句配置路径</span></span><br><span class="line"><span class="attr">mapper_path</span>=<span class="string">/mapper/**.xml</span></span><br><span class="line"><span class="comment">#实体类所在包</span></span><br><span class="line"><span class="attr">type_alias_package</span>=<span class="string">com.example.demo.entity</span></span><br></pre></td></tr></table></figure>

<p>JDBC连接Mysql5驱动： com.mysql.jdbc.Driver<br>JDBC连接Mysql6驱动： com.mysql.cj.jdbc.Driver, URL必须要指定时区serverTimezone！</p>
<hr>
<h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p> <code>@SpringBootApplication</code> 类：作为程序入口，在创建 Spring Boot 项目时自动创建。</p>
<p> 等同于 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code> ，会自动完成配置并扫描路径下所有包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DemoApplication.class</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><ul>
<li><code>@Configuration</code>：标注类为配置类</li>
<li><code>@Bean(name = &#39;bean&#39;)</code>：标注方法，IOC容器通过该方法生成bean</li>
<li><code>@AutoWired</code>：标注属性，由IOC容器自动装配并使用</li>
</ul>
<p>配置类内声明的Bean方法将生成实例纳入到spring容器中，并且实例名就是方法名。</p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li><code>@Component</code>: 标注类为工具类</li>
</ul>
<p>工具类声明后会自动生成bean实例纳入到spring容器中。</p>
<h3 id="异常处理类"><a href="#异常处理类" class="headerlink" title="异常处理类"></a>异常处理类</h3><ul>
<li><code>@ControllerAdvice</code>: 标注当前类为所有Controller类服务</li>
<li><code>@ExceptionHandler</code>: 标注当前方法处理异常（默认处理RuntimeException）<br><code>@ExceptionHandler(value = Exception.class)</code>: 处理所有异常</li>
<li><code>@ResponseBody</code>:将Controller类返回数据(通常为map)转码添加到response中(默认为json形式)</li>
</ul>
<hr>
<h2 id="数据访问层-DAO"><a href="#数据访问层-DAO" class="headerlink" title="数据访问层 DAO"></a>数据访问层 DAO</h2><p>和数据库建立连接，并定义和数据库之间的交互操作。</p>
<details>
<summary>1. 配置类：配置数据库连接</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataSourceConfiguration.java</span></span><br><span class="line"><span class="comment">//创建DataSource Bean并交由Ioc容器管理，通过其与数据库进行连接</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.demo.dao&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//全局配置为属性赋值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String jdbcDriver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUsername;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建DataSource Bean并生成实例</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ComboPooledDataSource <span class="title function_">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">// 生成dataSource实例</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置数据库驱动</span></span><br><span class="line">        dataSource.setDriverClass(jdbcDriver);</span><br><span class="line">        <span class="comment">// 设置数据库连接URL</span></span><br><span class="line">        dataSource.setJdbcUrl(jdbcUrl);</span><br><span class="line">        <span class="comment">// 设置用户名</span></span><br><span class="line">        dataSource.setUser(jdbcUsername);</span><br><span class="line">        <span class="comment">// 设置用户密码</span></span><br><span class="line">        dataSource.setPassword(jdbcPassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接池最大线程数（需引入c3p0包）</span></span><br><span class="line">        dataSource.setMaxPoolSize(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 连接池最小线程数</span></span><br><span class="line">        dataSource.setMinPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 关闭连接后不自动提交</span></span><br><span class="line">        dataSource.setAutoCommitOnClose(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 连接超时时间</span></span><br><span class="line">        dataSource.setCheckoutTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 连接失败重试次数</span></span><br><span class="line">        dataSource.setAcquireRetryAttempts(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<ul>
<li><code>@Mapper</code>：Mybatis注解，标注接口，编译时自动生成实现类（根据mapper/xml文件）</li>
<li><code>@MapperScan(&quot;package&quot;)</code>：Mybatis注解，标注接口所在包，编译时对接口自动生成实现类</li>
</ul>
<details>
<summary>2. 配置类：配置MyBatis</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SessionFactoryConfiguration.java(dao)</span></span><br><span class="line"><span class="comment">//MyBatis核心：自动创建Session Bean（封装JDBC连接），其实例可以直接执行被映射的SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionFactoryConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置mybatis相关路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mybatisConfigFile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis_config_file&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisConfigFile</span><span class="params">(String mybatisConfigFile)</span> &#123;</span><br><span class="line">        SessionFactoryConfiguration.mybatisConfigFile = mybatisConfigFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mapperPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mapper_path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapperPath</span><span class="params">(String mapperPath)</span> &#123;</span><br><span class="line">        SessionFactoryConfiguration.mapperPath = mapperPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;type_alias_package&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String typeAliasPackage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入连接池</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建sqlSessionFactory Bean并生成实例</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">createSqlSessionFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 生成sqlSessionFactory实例</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 设置相关扫描路径和连接池</span></span><br><span class="line">        sqlSessionFactoryBean.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(mybatisConfigFile));</span><br><span class="line">        <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">pathMatchingResourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperPath;</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(pathMatchingResourcePatternResolver.getResources(packageSearchPath));</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasPackage);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details>
<summary>3. XML文件：配置mybatis全局属性（可选）</summary>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-config.xml(resources文件夹)--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用jdbc的getGeneratedKeys获取数据库自增主键值--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--使用列标签替换列别名 默认:true--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--属性名和数据库参数名一致时，mybatis才会把从数据库参数自动转换为实体类属性。--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>4. 定义实体类（略）</summary>
</details>
<details>
<summary>5. 定义接口类，规定对属性的存取操作</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//personDao.java(dao文件夹)</span></span><br><span class="line"><span class="comment">//接口类：规定对相关属性的数据库存取操作（由mybatis加载时自动配置实现类）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> personList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">queryPerson</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查找person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Person <span class="title function_">queryPersonById</span><span class="params">(<span class="type">int</span> ID)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertPerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deletePerson</span><span class="params">(<span class="type">int</span> ID)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>XML文件：设置执行方法的SQL语句<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--PersonDao.xml(resources/mapper文件夹)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MyBatis会根据该文件自动配置对数据库操作的实现类--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.PersonDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryPerson&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		SELECT person_ID,person_name</span><br><span class="line">		FROM demo_person</span><br><span class="line">		ORDER BY person_ID</span><br><span class="line">		DESC</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryPersonById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		SELECT person_ID,person_name</span><br><span class="line">		FROM demo_person</span><br><span class="line">		where</span><br><span class="line">		person_ID= #&#123;person_ID&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--insert成功会返回一个名为ID的主键值，在数据库中为person_ID项--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertPerson&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;ID&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">keyColumn</span>=<span class="string">&quot;person_ID&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		INSERT INTO</span><br><span class="line">		demo_person(person_ID,person_name)</span><br><span class="line">		VALUES</span><br><span class="line">		(#&#123;person_ID&#125;,#&#123;person_name&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updatePerson&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span>/</span><br><span class="line">		update demo_person</span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;person_name != null&quot;</span>&gt;</span>person_name=#&#123;person_name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where person_id=#&#123;person_ID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deletePerson&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM</span><br><span class="line">		demo_person</span><br><span class="line">		WHERE</span><br><span class="line">		person_id =</span><br><span class="line">		#&#123;person_ID&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="业务层-Service"><a href="#业务层-Service" class="headerlink" title="业务层 Service"></a>业务层 Service</h2><p>规定事务，保障事务的原子属性。</p>
<details>
<summary>1. 配置类：配置事务管理</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TransactionManagementConfiguration.java(service)</span></span><br><span class="line"><span class="comment">//声明事务，通过其对事务进行管理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagementConfiguration</span> <span class="keyword">implements</span> <span class="title class_">TransactionManagementConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 注入连接池</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">annotationDrivenTransactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><code>@EnableTransactionManagement</code>：开启事务管理（方法上添加注解 @Transactional）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PersonServiceImpl.java(service/impl文件夹内)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">getPersonList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回所有的区域信息</span></span><br><span class="line">        <span class="keyword">return</span> personDao.queryPerson();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(<span class="type">int</span> PersonId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personDao.queryPersonById(PersonId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addPerson</span><span class="params">(Person Person)</span> &#123;</span><br><span class="line">        <span class="comment">// 空值判断，主要是判断PersonName不为空</span></span><br><span class="line">        <span class="keyword">if</span> (Person.getName() != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(Person.getName())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.insertPerson(Person);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;添加信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;添加信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;信息不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyPerson</span><span class="params">(Person Person)</span> &#123;</span><br><span class="line">        <span class="comment">// 空值判断，主要是PersonId不为空</span></span><br><span class="line">        <span class="keyword">if</span> (Person.getID() != <span class="literal">null</span> &amp;&amp; Person.getID() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置默认值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 更新区域信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.updatePerson(Person);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;更新信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;更新信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;信息不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deletePerson</span><span class="params">(<span class="type">int</span> PersonId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PersonId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 删除区域信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.deletePerson(PersonId);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ID不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Transactional</code>：标记类/方法具有事务属性，默认出现RuntimeException则回滚。<br><code>@Transactional(rollbackFor = Exception.class)</code>  事务在遇到全部异常(Exception)均回滚。</li>
</ul>
<hr>
<h2 id="控制层-Controller"><a href="#控制层-Controller" class="headerlink" title="控制层 Controller"></a>控制层 Controller</h2><p>Spring Boot 内集成了 TomCat 服务器，通过控制层接收浏览器的 URL 请求进行操作并返回数据。</p>
<p>底层和浏览器的信息交互仍旧由 servlet 完成。</p>
<h3 id="控制层配置"><a href="#控制层配置" class="headerlink" title="控制层配置"></a>控制层配置</h3><p>配置文件继承 WebMvcConfigurerAdapter 类（已过时），通过重写以下几个方法管理控制层。</p>
<p>替代方案 直接实现 WebMvcConfigurer 接口或继承 WebMvcConfigurationSupport 类，这表明用户完全接管 spring MVC，会丢弃 SpringBoot 的默认设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 解决跨域问题 **/</span><br><span class="line">public void addCorsMappings(CorsRegistry registry) ;</span><br><span class="line">/** 添加拦截器 **/</span><br><span class="line">void addInterceptors(InterceptorRegistry registry);</span><br><span class="line">/** 配置视图解析器 **/</span><br><span class="line">void configureViewResolvers(ViewResolverRegistry registry);</span><br><span class="line">/** 配置内容裁决选项 **/</span><br><span class="line">void configureContentNegotiation(ContentNegotiationConfigurer configurer);</span><br><span class="line">/** 视图跳转控制器 **/</span><br><span class="line">void addViewControllers(ViewControllerRegistry registry);</span><br><span class="line">/** 静态资源处理 **/</span><br><span class="line">void addResourceHandlers(ResourceHandlerRegistry registry);</span><br><span class="line">/** 默认静态资源处理器 **/</span><br><span class="line">void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);</span><br></pre></td></tr></table></figure>


<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>否则返回数据会被浏览器拦截</p>
<p>public void addCorsMappings(CorsRegistry registry) {<br>        //添加映射路径<br>        registry.addMapping(“/**”)<br>                //放行哪些原始域<br>                .allowedOrigins(“<em>“)<br>                //是否发送Cookie信息<br>                .allowCredentials(true)<br>                //放行哪些原始域(请求方式)<br>                .allowedMethods(“GET”,”POST”, “PUT”, “DELETE”)<br>                //放行哪些原始域(头部信息)<br>                .allowedHeaders(“</em>“)<br>                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）<br>                .exposedHeaders(“Header1”, “Header2”);<br>    }</p>
<h4 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h4><p>Javaweb中，在执行Controller方法前后对Controller请求进行拦截和处理。</p>
<p>依赖于web框架(Spring配置)，在实现上基于Java的反射机制。</p>
<p><strong>过滤器(Filter)</strong></p>
<p>Javaweb中，在request/response传入Servlet前，过滤信息或设置参数。</p>
<p>它依赖于servlet容器(web.xml配置)。在实现上基于函数回调。</p>
<p><strong>两者常用于修改字符编码、删除无用参数、登录校验等。Spring框架中优先使用拦截器：功能接近、使用更加灵活。</strong></p>
<p>一个*：只匹配字符，不匹配路径（/）<br>两个**：匹配字符，和路径（/）</p>
<p><a href="https://www.cnblogs.com/kangkaii/p/9023751.html">https://www.cnblogs.com/kangkaii/p/9023751.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//路径映射，已在Controller中配置</span></span><br><span class="line">        <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">        public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;success&quot;);</span></span><br><span class="line"><span class="comment">            registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//session ke</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载拦截器</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> SecurityInterceptor <span class="title function_">getSecurityInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityInterceptor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置拦截器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">            <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(getSecurityInterceptor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除配置</span></span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截配置</span></span><br><span class="line">            <span class="comment">//addInterceptor.excludePathPatterns(&quot;/**&quot;);</span></span><br><span class="line">            addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义拦截器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SecurityInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">                    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">                <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 跳转登录</span></span><br><span class="line">                request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">                <span class="comment">// 请求转发请求转发是一个请求一次响应，而重定向是两次请求两次响应。请求转发地址不变化，而重定向会显示后一个请求的地址</span></span><br><span class="line">                request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p>Controller 类需要使用 <code>@RestController</code> 或 <code>@Controller</code> 注解标注。</p>
<ul>
<li><p><code>@Controller</code>：类中所有方法以 String 形式返回 classpath 路径下同名 html 页面。适用于 JSP/thymeleaf 等动态加载页面。</p>
</li>
<li><p><code>@RestController</code>：类中所有方法以 Map/List 等形式返回 JSON 数据。适用于前后端分离开发。</p>
</li>
</ul>
<p><code>@Controller</code> 类中标注 <code>@ResponseBody</code> 方法，可以起到和 <code>@RestController</code> 类相同的效果。</p>
<h4 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h4><p>Controller 类中的方法使用 <code>@RequestMapping</code> 注解标注，就可以将指定 URL 请求映射到方法上处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span>     <span class="comment">// 参数为 URL 路径和请求方式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span>                                         <span class="comment">// 默认接收所有请求方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>                                             <span class="comment">// 简写形式的 GET 请求</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/hello&quot;)</span>                                            <span class="comment">// 简写形式的 POST 请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵活映射</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/?/hello&quot;)</span>                                      <span class="comment">// ? 匹配单字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/*/hello&quot;)</span>`：                                    <span class="comment">// * 匹配任意数量字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/**/hello&quot;)</span>：                                    <span class="comment">// ** 匹配任意数量目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;ID&#125;/hello&quot;)</span>`                                   <span class="comment">// &#123;&#125; 读取 URL 路径中的参数</span></span><br></pre></td></tr></table></figure>

<p>Controller 类也可以通过 <code>@RequestMapping</code> 注解标注，表示路径下的 URL 请求在该类中寻找方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/speak&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpeakController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="参数接收"><a href="#参数接收" class="headerlink" title="参数接收"></a>参数接收</h4><p>对于请求 /test?username=mrjoker&amp;password=123456 ，有以下几种方式接收参数。</p>
<ol>
<li>直接获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 HttpServletRequest 类来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过自定义对象来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 RequestParam 注解来获取参数（实参值赋给形参）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String s1, <span class="meta">@RequestParam(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 PathVariable 注解来动态获取参数，对于请求 /test/mrjoker/123456</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&#123;username&#125;/&#123;password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String s1, <span class="meta">@PathVariable(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>通过 ModelAttribute 注解来获取其他方法返回值作为参数</li>
</ol>
<p><a href="https://blog.csdn.net/a532672728/article/details/78057218">https://blog.csdn.net/a532672728/article/details/78057218</a> 传递参数</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>GET 请求请求参数直接附着在 URL 中。而 POST 请求请求参数放置在请求体中，其请求参数有以下两种格式：</p>
<p><strong>Form Data 格式</strong></p>
<p>请求的 Content-Type 为 application/x-www-form-urlencoded</p>
<p>示例：<code>username=mrjoker&amp;password=123456</code></p>
<p><strong>Request Payload 格式</strong></p>
<p>请求的 Content-Type 为 application/json 或者 multipart/form-data</p>
<p>示例：<code>&#123;&quot;username&quot;:&quot;mrjoker&quot;, &quot;password&quot;:&quot;123456&quot;&#125;</code></p>
<p>AJAX 提交 POST 请求默认使用 Form Data 格式，Spring MVC 会自动解析到对应的 bean 中并获取参数。但对于 Request Payload 请求，则必须进行处理：</p>
<ol>
<li>前端解决方案 axios 库可以使用 qs 库将 json 对象转化为 Form Data 格式。</li>
<li>后端解决方案 Spring Boot 在请求参数上加 <code>@RequestBody</code> 注解，将请求正文解析到对应的 bean 中获取参数。</li>
</ol>
<p>一个请求可以有多个 RequestParam，但只能有一个 RequestBody。如果 URL 内含有参数，两者也可以同时使用。</p>
<p>@RequestBody 可以直接以 String 接收前端传过来的 json 数据，也可以用对象自动解析前端传过来的 json 数据。对象里定义 List 属性，可用来接收多条 json 数据。</p>
<p>axios 中的 params与 data 传参的区别: params 传参，参数以 k=v&amp;k=v 格式放置在 url 中传递。data传参，参数会收到Request Header中的 Content-Type 类型的影响 data 的参数会在 form表单中。</p>
<p><a href="https://www.cnblogs.com/dw039/p/11104628.html">https://www.cnblogs.com/dw039/p/11104628.html</a></p>
<h4 id="局部跨域"><a href="#局部跨域" class="headerlink" title="局部跨域"></a>局部跨域</h4><p>在方法上（@RequestMapping）或者在控制器（@Controller）上使用注解 @CrossOrigin，可以实现局部跨域</p>
<p> @RequestMapping(“/hello”)<br>    @ResponseBody<br>    @CrossOrigin(“<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>)<br>    public String index( ){<br>        return “Hello World”;<br>    }</p>
<p>使用HttpServletResponse对象添加响应头（Access-Control-Allow-Origin）来授权原始域，这里Origin的值也可以设置为”*” ，表示全部放行。<br>@RequestMapping(“/hello”)<br>    @ResponseBody<br>    public String index(HttpServletResponse response){<br>        response.addHeader(“Access-Control-Allow-Origin”, “<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>);<br>        return “Hello World”;<br>    }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PersonController.java（web文件夹内）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/superadmin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonService PersonService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/listPerson&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">listPerson</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        <span class="comment">// 获取列表</span></span><br><span class="line">        list = PersonService.getPersonList();</span><br><span class="line">        modelMap.put(<span class="string">&quot;PersonList&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID获取信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getPersonbyid&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getPersonById</span><span class="params">(Integer PersonId)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 获取信息</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">Person</span> <span class="operator">=</span> PersonService.getPersonById(PersonId);</span><br><span class="line">        modelMap.put(<span class="string">&quot;Person&quot;</span>, Person);</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> PersonStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonMappingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/addPerson&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person Person)</span></span><br><span class="line">            <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 添加区域信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.addPerson(Person));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改信息，主要修改名字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> PersonStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonMappingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/modifyPerson&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">modifyPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person Person)</span></span><br><span class="line">            <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 修改信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.modifyPerson(Person));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/removePerson&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">removePerson</span><span class="params">(Integer PersonId)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 修改信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.deletePerson(PersonId));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h4><p>1.请求转发（forward）:</p>
<p>当客户端（浏览器）向远程服务器发送一个URL请求后，服务器接收到请求后，会在服务器内部直接通过另外的一个URL获取资源并将此资源再响应给浏览器，请求转发整个过程是一次性的。</p>
<p>浏览器的URL地址仍然是原来的URL.</p>
<p>2.重定向（Redirect）:<br>    当客户端（浏览器）向服务器发送一个URL请求后，服务器会告诉浏览器，资源在另外一个URL地址上，此时浏览器会重新发送请求到新的资源地址。重定向发送了两次URL请求。</p>
<p>浏览器上面的URL已经换位了新的资源请求地址。</p>
<p><a href="https://www.cnblogs.com/javaxiaobu/p/11149151.html">https://www.cnblogs.com/javaxiaobu/p/11149151.html</a></p>
<hr>
<h3 id="Spring-Boot配置HTTPS"><a href="#Spring-Boot配置HTTPS" class="headerlink" title="Spring Boot配置HTTPS"></a>Spring Boot配置HTTPS</h3><p>####生成SSL证书</p>
<p><a href="https://www.cnblogs.com/benwu/articles/4891758.html">https://www.cnblogs.com/benwu/articles/4891758.html</a></p>
<p>JDK提供证书管理工具: JDK\bin\keytool.exe </p>
<p><font size =2 color = green>Tomcat使用Java提供的密码库，通过Java的Keytool工具生成JKS等格式的证书文件。<br>Apache使用OpenSSL提供的密码库，生成PEM、KEY、CRT等格式的证书文件。</font></p>
<p><strong>cmd命令(JDK\bin目录打开)</strong></p>
<p>密钥库: 保存密钥和对应的证书。【证书只含有公钥】</p>
<p><font size =2 color = blond>genkeypair 生成密钥对（非对称加密算法）<br>genseckey 生成密钥（对称加密算法）<br></font><br>创建名为tomcat的密钥对以及自签名的证书，放入mykeystore密钥库中（不存在则创建）<br><code>keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -validity 180 -keypass &quot;123456&quot; -keystore &quot;D:\mykeystore.keystore&quot; -storetype PKCS12 -storepass </code></p>
<ul>
<li>alias 证书别名</li>
<li>keyalg 加密算法，生成密钥对默认RSA</li>
<li>keysize 密钥键长，RSA默认2048</li>
<li>validity 证书有效期，默认90</li>
<li>keypass 证书密码</li>
<li>keystore 密钥库路径，默认创建在用户目录下</li>
<li>storetype 密钥库类型，默认JKS</li>
<li>storepass 密钥库密码</li>
</ul>
<p>查看密钥库<br><code>keytool -list -v -alias tomcat -keystore &quot;D:\mykeystore.keystore&quot; -storepass 123456 </code></p>
<p>将生成的证书文件拷贝到项目resources目录下</p>
<p>####修改全局配置文件</p>
<p>application.properties格式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span> = <span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span> = <span class="string">classpath:mykeystore.keystore</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span> = <span class="string">123456</span></span><br><span class="line"><span class="attr">server.ssl.keyStoreType</span> = <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.keyAlias</span> = <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>

<p>设置SSL后，默认使用HTTPS协议。访问localhost:8443，会出现证书安全提示，强行进入即可。<br><font size =2 color = brown>【未付费注册，不被数字认证机构CA认可：会被浏览器标记为不安全】</font></p>
<p>如果将服务器端口号设置成443端口,即https的默认访问端口,那么在进行https访问的时候可以不带端口号直接访问。</p>
<p><strong>修改入口文件</strong></p>
<p>如果访问<a href="http://localhost:8443，则提示需要TLS。">http://localhost:8443，则提示需要TLS。</a></p>
<p>》》将http连接自动转换为https连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSslApplication</span> &#123;</span><br><span class="line">    <span class="comment">//servlet容器，自己写的bean会覆盖自动配置的bean？</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        tomcat.addAdditionalTomcatConnectors(createStandardConnector());</span><br><span class="line">        <span class="keyword">return</span> tomcat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">// 新建connecter监听80端口，并重定向至8443</span></span><br><span class="line">    <span class="keyword">private</span> Connector <span class="title function_">createStandardConnector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">80</span>);</span><br><span class="line">        connector.setSecure(<span class="literal">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8443</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>重新配置Servlet容器(Tomcat)</p>
<p>自动配置类ServletWebServerFactoryAutoConfiguration会读取bean</p>
<p><a href="https://www.jianshu.com/p/017a7f40efff">https://www.jianshu.com/p/017a7f40efff</a></p>
<p><strong>衍生：Spring Boot是如何启动Tomcat的？</strong></p>
<p>tomcat最顶层容器是Server，代表着整个服务器，一个Server包含多个Service。Service主要包括多个Connector和一个Container。Connector用来处理连接相关的事情，并提供Socket到Request和Response相关转化。Container用于封装和管理Servlet，以及处理具体的Request请求。</p>
<hr>
<p>main方法： 实例化SpringApplication，执行run方法</p>
<p>run方法：<br>    配置属性、获取监听器，初始化输入参数、配置环境，输出banner<br>    创建上下文、预处理上下文、刷新上下文、再刷新上下文：context</p>
<p>refreshApplicationContext方法：通过ServletWebServerFactory接口定义了getwebServer方法，通过其创建webServer并返回（创建时做了两件重要的事情：把Connector对象添加到tomcat中，配置引擎）【TomcatServletWebServerFactory是接口其中一个实现类】</p>
<p>TomcatwebServer类中，规定了Tomcat服务器的启动和关闭方法。</p>
<p>Spring Boot启动过程主要做了以下几件事情：</p>
<p>在SpringBoot中启动tomcat的工作在刷新上下文这一步</p>
<p>而tomcat的启动主要是实例化两个组件：Connector、Container</p>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2023/05/14/javaee/spring/SpringBootMybatis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><p>进一步对Spring中的操作进行封装，通过注解（@）取代xml文件进行自动配置，简化编程。</p>
<hr>
<h2 id="默认映射路径"><a href="#默认映射路径" class="headerlink" title="默认映射路径"></a>默认映射路径</h2><ul>
<li><code>classpath:/META-INF/resources/</code></li>
<li><code>classpath:/resources/</code></li>
<li><code>classpath:/static/</code> </li>
<li><code>classpath:/public/</code></li>
</ul>
<p>优先级顺序：META-INF/resources &gt; resources &gt; static &gt; public</p>
<hr>
<h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p>resources 文件夹下，支持以下两种格式。由 Spring Boot 自动加载。</p>
<ol>
<li>application.properties</li>
<li>application.yml</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口号</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="comment">#访问前缀</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#数据库驱动</span></span><br><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jc.jdbc.Driver</span></span><br><span class="line"><span class="comment">#数据库链接</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="comment">#数据库用户名</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment">#数据库密码</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">wdh19970506</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="comment">#配置文件路径</span></span><br><span class="line"><span class="attr">mybatis_config_file</span>=<span class="string">mybatis-config.xml</span></span><br><span class="line"><span class="comment">#SQL语句配置路径</span></span><br><span class="line"><span class="attr">mapper_path</span>=<span class="string">/mapper/**.xml</span></span><br><span class="line"><span class="comment">#实体类所在包</span></span><br><span class="line"><span class="attr">type_alias_package</span>=<span class="string">com.example.demo.entity</span></span><br></pre></td></tr></table></figure>

<p>JDBC连接Mysql5驱动： com.mysql.jdbc.Driver<br>JDBC连接Mysql6驱动： com.mysql.cj.jdbc.Driver, URL必须要指定时区serverTimezone！</p>
<hr>
<h2 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h2><p> <code>@SpringBootApplication</code> 类：作为程序入口，在创建 Spring Boot 项目时自动创建。</p>
<p> 等同于 <code>@Configuration</code> + <code>@EnableAutoConfiguration</code> + <code>@ComponentScan</code> ，会自动完成配置并扫描路径下所有包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DemoApplication.class</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><ul>
<li><code>@Configuration</code>：标注类为配置类</li>
<li><code>@Bean(name = &#39;bean&#39;)</code>：标注方法，IOC容器通过该方法生成bean</li>
<li><code>@AutoWired</code>：标注属性，由IOC容器自动装配并使用</li>
</ul>
<p>配置类内声明的Bean方法将生成实例纳入到spring容器中，并且实例名就是方法名。</p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul>
<li><code>@Component</code>: 标注类为工具类</li>
</ul>
<p>工具类声明后会自动生成bean实例纳入到spring容器中。</p>
<h3 id="异常处理类"><a href="#异常处理类" class="headerlink" title="异常处理类"></a>异常处理类</h3><ul>
<li><code>@ControllerAdvice</code>: 标注当前类为所有Controller类服务</li>
<li><code>@ExceptionHandler</code>: 标注当前方法处理异常（默认处理RuntimeException）<br><code>@ExceptionHandler(value = Exception.class)</code>: 处理所有异常</li>
<li><code>@ResponseBody</code>:将Controller类返回数据(通常为map)转码添加到response中(默认为json形式)</li>
</ul>
<hr>
<h2 id="数据访问层-DAO"><a href="#数据访问层-DAO" class="headerlink" title="数据访问层 DAO"></a>数据访问层 DAO</h2><p>和数据库建立连接，并定义和数据库之间的交互操作。</p>
<details>
<summary>1. 配置类：配置数据库连接</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DataSourceConfiguration.java</span></span><br><span class="line"><span class="comment">//创建DataSource Bean并交由Ioc容器管理，通过其与数据库进行连接</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.example.demo.dao&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//全局配置为属性赋值</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String jdbcDriver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcUsername;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建DataSource Bean并生成实例</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ComboPooledDataSource <span class="title function_">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException &#123;</span><br><span class="line">        <span class="comment">// 生成dataSource实例</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置数据库驱动</span></span><br><span class="line">        dataSource.setDriverClass(jdbcDriver);</span><br><span class="line">        <span class="comment">// 设置数据库连接URL</span></span><br><span class="line">        dataSource.setJdbcUrl(jdbcUrl);</span><br><span class="line">        <span class="comment">// 设置用户名</span></span><br><span class="line">        dataSource.setUser(jdbcUsername);</span><br><span class="line">        <span class="comment">// 设置用户密码</span></span><br><span class="line">        dataSource.setPassword(jdbcPassword);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 连接池最大线程数（需引入c3p0包）</span></span><br><span class="line">        dataSource.setMaxPoolSize(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 连接池最小线程数</span></span><br><span class="line">        dataSource.setMinPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 关闭连接后不自动提交</span></span><br><span class="line">        dataSource.setAutoCommitOnClose(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 连接超时时间</span></span><br><span class="line">        dataSource.setCheckoutTimeout(<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">// 连接失败重试次数</span></span><br><span class="line">        dataSource.setAcquireRetryAttempts(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>


<ul>
<li><code>@Mapper</code>：Mybatis注解，标注接口，编译时自动生成实现类（根据mapper/xml文件）</li>
<li><code>@MapperScan(&quot;package&quot;)</code>：Mybatis注解，标注接口所在包，编译时对接口自动生成实现类</li>
</ul>
<details>
<summary>2. 配置类：配置MyBatis</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SessionFactoryConfiguration.java(dao)</span></span><br><span class="line"><span class="comment">//MyBatis核心：自动创建Session Bean（封装JDBC连接），其实例可以直接执行被映射的SQL语句</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionFactoryConfiguration</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置mybatis相关路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mybatisConfigFile;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mybatis_config_file&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMybatisConfigFile</span><span class="params">(String mybatisConfigFile)</span> &#123;</span><br><span class="line">        SessionFactoryConfiguration.mybatisConfigFile = mybatisConfigFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String mapperPath;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mapper_path&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapperPath</span><span class="params">(String mapperPath)</span> &#123;</span><br><span class="line">        SessionFactoryConfiguration.mapperPath = mapperPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;type_alias_package&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String typeAliasPackage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入连接池</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建sqlSessionFactory Bean并生成实例</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">createSqlSessionFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 生成sqlSessionFactory实例</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 设置相关扫描路径和连接池</span></span><br><span class="line">        sqlSessionFactoryBean.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(mybatisConfigFile));</span><br><span class="line">        <span class="type">PathMatchingResourcePatternResolver</span> <span class="variable">pathMatchingResourcePatternResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">packageSearchPath</span> <span class="operator">=</span> ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + mapperPath;</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(pathMatchingResourcePatternResolver.getResources(packageSearchPath));</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(typeAliasPackage);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<details>
<summary>3. XML文件：配置mybatis全局属性（可选）</summary>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-config.xml(resources文件夹)--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置全局属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用jdbc的getGeneratedKeys获取数据库自增主键值--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--使用列标签替换列别名 默认:true--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--属性名和数据库参数名一致时，mybatis才会把从数据库参数自动转换为实体类属性。--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</details>

<details>
<summary>4. 定义实体类（略）</summary>
</details>
<details>
<summary>5. 定义接口类，规定对属性的存取操作</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//personDao.java(dao文件夹)</span></span><br><span class="line"><span class="comment">//接口类：规定对相关属性的数据库存取操作（由mybatis加载时自动配置实现类）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PersonDao</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 展示列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> personList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Person&gt; <span class="title function_">queryPerson</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据Id查找person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> person</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Person <span class="title function_">queryPersonById</span><span class="params">(<span class="type">int</span> ID)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insertPerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updatePerson</span><span class="params">(Person person)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除person信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deletePerson</span><span class="params">(<span class="type">int</span> ID)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ol>
<li>XML文件：设置执行方法的SQL语句<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--PersonDao.xml(resources/mapper文件夹)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--MyBatis会根据该文件自动配置对数据库操作的实现类--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.example.demo.dao.PersonDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryPerson&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		SELECT person_ID,person_name</span><br><span class="line">		FROM demo_person</span><br><span class="line">		ORDER BY person_ID</span><br><span class="line">		DESC</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryPersonById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		SELECT person_ID,person_name</span><br><span class="line">		FROM demo_person</span><br><span class="line">		where</span><br><span class="line">		person_ID= #&#123;person_ID&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--insert成功会返回一个名为ID的主键值，在数据库中为person_ID项--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertPerson&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;ID&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">keyColumn</span>=<span class="string">&quot;person_ID&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span></span><br><span class="line">		INSERT INTO</span><br><span class="line">		demo_person(person_ID,person_name)</span><br><span class="line">		VALUES</span><br><span class="line">		(#&#123;person_ID&#125;,#&#123;person_name&#125;)</span><br><span class="line">	<span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updatePerson&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.demo.entity.Person&quot;</span>&gt;</span>/</span><br><span class="line">		update demo_person</span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;person_name != null&quot;</span>&gt;</span>person_name=#&#123;person_name&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">		where person_id=#&#123;person_ID&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deletePerson&quot;</span>&gt;</span></span><br><span class="line">        DELETE FROM</span><br><span class="line">		demo_person</span><br><span class="line">		WHERE</span><br><span class="line">		person_id =</span><br><span class="line">		#&#123;person_ID&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="业务层-Service"><a href="#业务层-Service" class="headerlink" title="业务层 Service"></a>业务层 Service</h2><p>规定事务，保障事务的原子属性。</p>
<details>
<summary>1. 配置类：配置事务管理</summary>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TransactionManagementConfiguration.java(service)</span></span><br><span class="line"><span class="comment">//声明事务，通过其对事务进行管理</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManagementConfiguration</span> <span class="keyword">implements</span> <span class="title class_">TransactionManagementConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 注入连接池</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">annotationDrivenTransactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<ul>
<li><code>@EnableTransactionManagement</code>：开启事务管理（方法上添加注解 @Transactional）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PersonServiceImpl.java(service/impl文件夹内)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PersonService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Person&gt; <span class="title function_">getPersonList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 返回所有的区域信息</span></span><br><span class="line">        <span class="keyword">return</span> personDao.queryPerson();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">getPersonById</span><span class="params">(<span class="type">int</span> PersonId)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> personDao.queryPersonById(PersonId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addPerson</span><span class="params">(Person Person)</span> &#123;</span><br><span class="line">        <span class="comment">// 空值判断，主要是判断PersonName不为空</span></span><br><span class="line">        <span class="keyword">if</span> (Person.getName() != <span class="literal">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(Person.getName())) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.insertPerson(Person);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;添加信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;添加信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;信息不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">modifyPerson</span><span class="params">(Person Person)</span> &#123;</span><br><span class="line">        <span class="comment">// 空值判断，主要是PersonId不为空</span></span><br><span class="line">        <span class="keyword">if</span> (Person.getID() != <span class="literal">null</span> &amp;&amp; Person.getID() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置默认值</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 更新区域信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.updatePerson(Person);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;更新信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;更新信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;信息不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deletePerson</span><span class="params">(<span class="type">int</span> PersonId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (PersonId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 删除区域信息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">effectedNum</span> <span class="operator">=</span> personDao.deletePerson(PersonId);</span><br><span class="line">                <span class="keyword">if</span> (effectedNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除信息失败!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;删除信息失败:&quot;</span> + e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ID不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Transactional</code>：标记类/方法具有事务属性，默认出现RuntimeException则回滚。<br><code>@Transactional(rollbackFor = Exception.class)</code>  事务在遇到全部异常(Exception)均回滚。</li>
</ul>
<hr>
<h2 id="控制层-Controller"><a href="#控制层-Controller" class="headerlink" title="控制层 Controller"></a>控制层 Controller</h2><p>Spring Boot 内集成了 TomCat 服务器，通过控制层接收浏览器的 URL 请求进行操作并返回数据。</p>
<p>底层和浏览器的信息交互仍旧由 servlet 完成。</p>
<h3 id="控制层配置"><a href="#控制层配置" class="headerlink" title="控制层配置"></a>控制层配置</h3><p>配置文件继承 WebMvcConfigurerAdapter 类（已过时），通过重写以下几个方法管理控制层。</p>
<p>替代方案 直接实现 WebMvcConfigurer 接口或继承 WebMvcConfigurationSupport 类，这表明用户完全接管 spring MVC，会丢弃 SpringBoot 的默认设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** 解决跨域问题 **/</span><br><span class="line">public void addCorsMappings(CorsRegistry registry) ;</span><br><span class="line">/** 添加拦截器 **/</span><br><span class="line">void addInterceptors(InterceptorRegistry registry);</span><br><span class="line">/** 配置视图解析器 **/</span><br><span class="line">void configureViewResolvers(ViewResolverRegistry registry);</span><br><span class="line">/** 配置内容裁决选项 **/</span><br><span class="line">void configureContentNegotiation(ContentNegotiationConfigurer configurer);</span><br><span class="line">/** 视图跳转控制器 **/</span><br><span class="line">void addViewControllers(ViewControllerRegistry registry);</span><br><span class="line">/** 静态资源处理 **/</span><br><span class="line">void addResourceHandlers(ResourceHandlerRegistry registry);</span><br><span class="line">/** 默认静态资源处理器 **/</span><br><span class="line">void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer);</span><br></pre></td></tr></table></figure>


<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>否则返回数据会被浏览器拦截</p>
<p>public void addCorsMappings(CorsRegistry registry) {<br>        //添加映射路径<br>        registry.addMapping(“/**”)<br>                //放行哪些原始域<br>                .allowedOrigins(“<em>“)<br>                //是否发送Cookie信息<br>                .allowCredentials(true)<br>                //放行哪些原始域(请求方式)<br>                .allowedMethods(“GET”,”POST”, “PUT”, “DELETE”)<br>                //放行哪些原始域(头部信息)<br>                .allowedHeaders(“</em>“)<br>                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）<br>                .exposedHeaders(“Header1”, “Header2”);<br>    }</p>
<h4 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h4><p>Javaweb中，在执行Controller方法前后对Controller请求进行拦截和处理。</p>
<p>依赖于web框架(Spring配置)，在实现上基于Java的反射机制。</p>
<p><strong>过滤器(Filter)</strong></p>
<p>Javaweb中，在request/response传入Servlet前，过滤信息或设置参数。</p>
<p>它依赖于servlet容器(web.xml配置)。在实现上基于函数回调。</p>
<p><strong>两者常用于修改字符编码、删除无用参数、登录校验等。Spring框架中优先使用拦截器：功能接近、使用更加灵活。</strong></p>
<p>一个*：只匹配字符，不匹配路径（/）<br>两个**：匹配字符，和路径（/）</p>
<p><a href="https://www.cnblogs.com/kangkaii/p/9023751.html">https://www.cnblogs.com/kangkaii/p/9023751.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfiguration</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//路径映射，已在Controller中配置</span></span><br><span class="line">        <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">        public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);</span></span><br><span class="line"><span class="comment">            registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;success&quot;);</span></span><br><span class="line"><span class="comment">            registry.addResourceHandler(&quot;/webjars/**&quot;) .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//session ke</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载拦截器</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> SecurityInterceptor <span class="title function_">getSecurityInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SecurityInterceptor</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置拦截器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">            <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(getSecurityInterceptor());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排除配置</span></span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">            addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截配置</span></span><br><span class="line">            <span class="comment">//addInterceptor.excludePathPatterns(&quot;/**&quot;);</span></span><br><span class="line">            addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义拦截器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SecurityInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">                    <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">                <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 跳转登录</span></span><br><span class="line">                request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">                <span class="comment">// 请求转发请求转发是一个请求一次响应，而重定向是两次请求两次响应。请求转发地址不变化，而重定向会显示后一个请求的地址</span></span><br><span class="line">                request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p>Controller 类需要使用 <code>@RestController</code> 或 <code>@Controller</code> 注解标注。</p>
<ul>
<li><p><code>@Controller</code>：类中所有方法以 String 形式返回 classpath 路径下同名 html 页面。适用于 JSP/thymeleaf 等动态加载页面。</p>
</li>
<li><p><code>@RestController</code>：类中所有方法以 Map/List 等形式返回 JSON 数据。适用于前后端分离开发。</p>
</li>
</ul>
<p><code>@Controller</code> 类中标注 <code>@ResponseBody</code> 方法，可以起到和 <code>@RestController</code> 类相同的效果。</p>
<h4 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h4><p>Controller 类中的方法使用 <code>@RequestMapping</code> 注解标注，就可以将指定 URL 请求映射到方法上处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span>     <span class="comment">// 参数为 URL 路径和请求方式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span>                                         <span class="comment">// 默认接收所有请求方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>                                             <span class="comment">// 简写形式的 GET 请求</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/hello&quot;)</span>                                            <span class="comment">// 简写形式的 POST 请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵活映射</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/?/hello&quot;)</span>                                      <span class="comment">// ? 匹配单字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/*/hello&quot;)</span>`：                                    <span class="comment">// * 匹配任意数量字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/**/hello&quot;)</span>：                                    <span class="comment">// ** 匹配任意数量目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;ID&#125;/hello&quot;)</span>`                                   <span class="comment">// &#123;&#125; 读取 URL 路径中的参数</span></span><br></pre></td></tr></table></figure>

<p>Controller 类也可以通过 <code>@RequestMapping</code> 注解标注，表示路径下的 URL 请求在该类中寻找方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/speak&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpeakController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="参数接收"><a href="#参数接收" class="headerlink" title="参数接收"></a>参数接收</h4><p>对于请求 /test?username=mrjoker&amp;password=123456 ，有以下几种方式接收参数。</p>
<ol>
<li>直接获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 HttpServletRequest 类来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过自定义对象来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 RequestParam 注解来获取参数（实参值赋给形参）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String s1, <span class="meta">@RequestParam(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 PathVariable 注解来动态获取参数，对于请求 /test/mrjoker/123456</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&#123;username&#125;/&#123;password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String s1, <span class="meta">@PathVariable(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>通过 ModelAttribute 注解来获取其他方法返回值作为参数</li>
</ol>
<p><a href="https://blog.csdn.net/a532672728/article/details/78057218">https://blog.csdn.net/a532672728/article/details/78057218</a> 传递参数</p>
<h4 id="请求参数"><a href="#请求参数" class="headerlink" title="请求参数"></a>请求参数</h4><p>GET 请求请求参数直接附着在 URL 中。而 POST 请求请求参数放置在请求体中，其请求参数有以下两种格式：</p>
<p><strong>Form Data 格式</strong></p>
<p>请求的 Content-Type 为 application/x-www-form-urlencoded</p>
<p>示例：<code>username=mrjoker&amp;password=123456</code></p>
<p><strong>Request Payload 格式</strong></p>
<p>请求的 Content-Type 为 application/json 或者 multipart/form-data</p>
<p>示例：<code>&#123;&quot;username&quot;:&quot;mrjoker&quot;, &quot;password&quot;:&quot;123456&quot;&#125;</code></p>
<p>AJAX 提交 POST 请求默认使用 Form Data 格式，Spring MVC 会自动解析到对应的 bean 中并获取参数。但对于 Request Payload 请求，则必须进行处理：</p>
<ol>
<li>前端解决方案 axios 库可以使用 qs 库将 json 对象转化为 Form Data 格式。</li>
<li>后端解决方案 Spring Boot 在请求参数上加 <code>@RequestBody</code> 注解，将请求正文解析到对应的 bean 中获取参数。</li>
</ol>
<p>一个请求可以有多个 RequestParam，但只能有一个 RequestBody。如果 URL 内含有参数，两者也可以同时使用。</p>
<p>@RequestBody 可以直接以 String 接收前端传过来的 json 数据，也可以用对象自动解析前端传过来的 json 数据。对象里定义 List 属性，可用来接收多条 json 数据。</p>
<p>axios 中的 params与 data 传参的区别: params 传参，参数以 k=v&amp;k=v 格式放置在 url 中传递。data传参，参数会收到Request Header中的 Content-Type 类型的影响 data 的参数会在 form表单中。</p>
<p><a href="https://www.cnblogs.com/dw039/p/11104628.html">https://www.cnblogs.com/dw039/p/11104628.html</a></p>
<h4 id="局部跨域"><a href="#局部跨域" class="headerlink" title="局部跨域"></a>局部跨域</h4><p>在方法上（@RequestMapping）或者在控制器（@Controller）上使用注解 @CrossOrigin，可以实现局部跨域</p>
<p> @RequestMapping(“/hello”)<br>    @ResponseBody<br>    @CrossOrigin(“<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>)<br>    public String index( ){<br>        return “Hello World”;<br>    }</p>
<p>使用HttpServletResponse对象添加响应头（Access-Control-Allow-Origin）来授权原始域，这里Origin的值也可以设置为”*” ，表示全部放行。<br>@RequestMapping(“/hello”)<br>    @ResponseBody<br>    public String index(HttpServletResponse response){<br>        response.addHeader(“Access-Control-Allow-Origin”, “<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>);<br>        return “Hello World”;<br>    }</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PersonController.java（web文件夹内）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/superadmin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonService PersonService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/listPerson&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">listPerson</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        <span class="comment">// 获取列表</span></span><br><span class="line">        list = PersonService.getPersonList();</span><br><span class="line">        modelMap.put(<span class="string">&quot;PersonList&quot;</span>, list);</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过ID获取信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getPersonbyid&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">getPersonById</span><span class="params">(Integer PersonId)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 获取信息</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">Person</span> <span class="operator">=</span> PersonService.getPersonById(PersonId);</span><br><span class="line">        modelMap.put(<span class="string">&quot;Person&quot;</span>, Person);</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加信息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> PersonStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonMappingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/addPerson&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person Person)</span></span><br><span class="line">            <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 添加区域信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.addPerson(Person));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改信息，主要修改名字</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> PersonStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonMappingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JsonParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/modifyPerson&quot;, method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">modifyPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person Person)</span></span><br><span class="line">            <span class="keyword">throws</span> JsonParseException, JsonMappingException, IOException &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 修改信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.modifyPerson(Person));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/removePerson&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title function_">removePerson</span><span class="params">(Integer PersonId)</span> &#123;</span><br><span class="line">        Map&lt;String, Object&gt; modelMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 修改信息</span></span><br><span class="line">        modelMap.put(<span class="string">&quot;success&quot;</span>, PersonService.deletePerson(PersonId));</span><br><span class="line">        <span class="keyword">return</span> modelMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h4><p>1.请求转发（forward）:</p>
<p>当客户端（浏览器）向远程服务器发送一个URL请求后，服务器接收到请求后，会在服务器内部直接通过另外的一个URL获取资源并将此资源再响应给浏览器，请求转发整个过程是一次性的。</p>
<p>浏览器的URL地址仍然是原来的URL.</p>
<p>2.重定向（Redirect）:<br>    当客户端（浏览器）向服务器发送一个URL请求后，服务器会告诉浏览器，资源在另外一个URL地址上，此时浏览器会重新发送请求到新的资源地址。重定向发送了两次URL请求。</p>
<p>浏览器上面的URL已经换位了新的资源请求地址。</p>
<p><a href="https://www.cnblogs.com/javaxiaobu/p/11149151.html">https://www.cnblogs.com/javaxiaobu/p/11149151.html</a></p>
<hr>
<h3 id="Spring-Boot配置HTTPS"><a href="#Spring-Boot配置HTTPS" class="headerlink" title="Spring Boot配置HTTPS"></a>Spring Boot配置HTTPS</h3><p>####生成SSL证书</p>
<p><a href="https://www.cnblogs.com/benwu/articles/4891758.html">https://www.cnblogs.com/benwu/articles/4891758.html</a></p>
<p>JDK提供证书管理工具: JDK\bin\keytool.exe </p>
<p><font size =2 color = green>Tomcat使用Java提供的密码库，通过Java的Keytool工具生成JKS等格式的证书文件。<br>Apache使用OpenSSL提供的密码库，生成PEM、KEY、CRT等格式的证书文件。</font></p>
<p><strong>cmd命令(JDK\bin目录打开)</strong></p>
<p>密钥库: 保存密钥和对应的证书。【证书只含有公钥】</p>
<p><font size =2 color = blond>genkeypair 生成密钥对（非对称加密算法）<br>genseckey 生成密钥（对称加密算法）<br></font><br>创建名为tomcat的密钥对以及自签名的证书，放入mykeystore密钥库中（不存在则创建）<br><code>keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -validity 180 -keypass &quot;123456&quot; -keystore &quot;D:\mykeystore.keystore&quot; -storetype PKCS12 -storepass </code></p>
<ul>
<li>alias 证书别名</li>
<li>keyalg 加密算法，生成密钥对默认RSA</li>
<li>keysize 密钥键长，RSA默认2048</li>
<li>validity 证书有效期，默认90</li>
<li>keypass 证书密码</li>
<li>keystore 密钥库路径，默认创建在用户目录下</li>
<li>storetype 密钥库类型，默认JKS</li>
<li>storepass 密钥库密码</li>
</ul>
<p>查看密钥库<br><code>keytool -list -v -alias tomcat -keystore &quot;D:\mykeystore.keystore&quot; -storepass 123456 </code></p>
<p>将生成的证书文件拷贝到项目resources目录下</p>
<p>####修改全局配置文件</p>
<p>application.properties格式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span> = <span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span> = <span class="string">classpath:mykeystore.keystore</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span> = <span class="string">123456</span></span><br><span class="line"><span class="attr">server.ssl.keyStoreType</span> = <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.keyAlias</span> = <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>

<p>设置SSL后，默认使用HTTPS协议。访问localhost:8443，会出现证书安全提示，强行进入即可。<br><font size =2 color = brown>【未付费注册，不被数字认证机构CA认可：会被浏览器标记为不安全】</font></p>
<p>如果将服务器端口号设置成443端口,即https的默认访问端口,那么在进行https访问的时候可以不带端口号直接访问。</p>
<p><strong>修改入口文件</strong></p>
<p>如果访问<a href="http://localhost:8443，则提示需要TLS。">http://localhost:8443，则提示需要TLS。</a></p>
<p>》》将http连接自动转换为https连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSslApplication</span> &#123;</span><br><span class="line">    <span class="comment">//servlet容器，自己写的bean会覆盖自动配置的bean？</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        tomcat.addAdditionalTomcatConnectors(createStandardConnector());</span><br><span class="line">        <span class="keyword">return</span> tomcat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">// 新建connecter监听80端口，并重定向至8443</span></span><br><span class="line">    <span class="keyword">private</span> Connector <span class="title function_">createStandardConnector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">80</span>);</span><br><span class="line">        connector.setSecure(<span class="literal">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8443</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>重新配置Servlet容器(Tomcat)</p>
<p>自动配置类ServletWebServerFactoryAutoConfiguration会读取bean</p>
<p><a href="https://www.jianshu.com/p/017a7f40efff">https://www.jianshu.com/p/017a7f40efff</a></p>
<p><strong>衍生：Spring Boot是如何启动Tomcat的？</strong></p>
<p>tomcat最顶层容器是Server，代表着整个服务器，一个Server包含多个Service。Service主要包括多个Connector和一个Container。Connector用来处理连接相关的事情，并提供Socket到Request和Response相关转化。Container用于封装和管理Servlet，以及处理具体的Request请求。</p>
<hr>
<p>main方法： 实例化SpringApplication，执行run方法</p>
<p>run方法：<br>    配置属性、获取监听器，初始化输入参数、配置环境，输出banner<br>    创建上下文、预处理上下文、刷新上下文、再刷新上下文：context</p>
<p>refreshApplicationContext方法：通过ServletWebServerFactory接口定义了getwebServer方法，通过其创建webServer并返回（创建时做了两件重要的事情：把Connector对象添加到tomcat中，配置引擎）【TomcatServletWebServerFactory是接口其中一个实现类】</p>
<p>TomcatwebServer类中，规定了Tomcat服务器的启动和关闭方法。</p>
<p>Spring Boot启动过程主要做了以下几件事情：</p>
<p>在SpringBoot中启动tomcat的工作在刷新上下文这一步</p>
<p>而tomcat的启动主要是实例化两个组件：Connector、Container</p>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Controller</title>
    <url>/2023/05/14/javaee/spring/SpringController/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Controller"><a href="#Spring-Controller" class="headerlink" title="Spring Controller"></a>Spring Controller</h1><hr>
<h2 id="服务器控制"><a href="#服务器控制" class="headerlink" title="服务器控制"></a>服务器控制</h2><h3 id="响应架构"><a href="#响应架构" class="headerlink" title="响应架构"></a>响应架构</h3><p>Spring Boot 内集成了 Tomcat 服务器，也可以外接 Tomcat 服务器。通过控制层接收浏览器的 URL 请求进行操作并返回数据。</p>
<p>底层和浏览器的信息交互仍旧由 servlet 完成，服务器整体架构如下：</p>
<ul>
<li><p><strong>Server</strong>： Tomcat 最顶层容器，代表整个服务器。</p>
<ul>
<li><strong>Service</strong>：服务，对应不同的任务。<ul>
<li><strong>Connector</strong>：有多个，用来处理连接相关的事情，并提供 Socket 到 Request 和 Response 相关转化。</li>
<li><strong>Container</strong>：只有一个，用于封装和管理 Servlet ，以及处理具体的 Request 请求。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>main 方法： 实例化 SpringApplication ，执行run方法</p>
<p>run方法：<br>    配置属性、获取监听器，初始化输入参数、配置环境，输出banner<br>    创建上下文、预处理上下文、刷新上下文、再刷新上下文：context</p>
<p>refreshApplicationContext方法：通过ServletWebServerFactory接口定义了getwebServer方法，通过其创建webServer并返回（创建时做了两件重要的事情：把Connector对象添加到tomcat中，配置引擎）【TomcatServletWebServerFactory是接口其中一个实现类】</p>
<p>TomcatwebServer类中，规定了Tomcat服务器的启动和关闭方法。</p>
<p>而tomcat的启动主要是实例化两个组件：Connector、Container</p>
<hr>
<h2 id="Controller-实现"><a href="#Controller-实现" class="headerlink" title="Controller 实现"></a>Controller 实现</h2><p>Controller 类需要使用 <code>@RestController</code> 或 <code>@Controller</code> 注解标注。</p>
<ul>
<li><p><code>@Controller</code>：类中所有方法以 String 形式返回 classpath 路径下同名 html 页面。适用于 JSP/thymeleaf 等动态加载页面。</p>
</li>
<li><p><code>@RestController</code>：类中所有方法以 Map/List 等形式返回 JSON 数据。适用于前后端分离开发。</p>
</li>
</ul>
<p>P.S. <code>@Controller</code> 类中标注 <code>@ResponseBody</code> 的方法，可以起到和 <code>@RestController</code> 类相同的效果。</p>
<h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><ol>
<li>Controller 类中的方法使用 <code>@RequestMapping</code> 注解标注，就可以将指定 URL 请求映射到方法上处理。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET)</span>     <span class="comment">// 参数为 URL 路径和请求方式</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span>                                         <span class="comment">// 默认接收所有请求方式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span>                                             <span class="comment">// 简写形式的 GET 请求</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/hello&quot;)</span>                                            <span class="comment">// 简写形式的 POST 请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 灵活映射</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/?/hello&quot;)</span>                                       <span class="comment">// ? 匹配单字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/*/hello&quot;)</span>`：                                    <span class="comment">// * 匹配任意数量字符</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/**/hello&quot;)</span>：                                    <span class="comment">// ** 匹配任意数量目录</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&#123;ID&#125;/hello&quot;)</span>`                                   <span class="comment">// &#123;&#125; 自动读取 URL 路径动态参数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Controller 类也可以通过 <code>@RequestMapping</code> 注解标注，表示路径下的 URL 请求在该类中寻找方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/speak&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpeakController</span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="GET-请求参数"><a href="#GET-请求参数" class="headerlink" title="GET 请求参数"></a>GET 请求参数</h3><p>GET 请求参数直接附着在 URL 中。对于请求 <code>/test?username=mrjoker&amp;password=123456</code> ，Controller 方法有以下几种方式接收：</p>
<ol>
<li>直接获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过 HttpServletRequest 类来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过自定义对象来获取参数</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通过 RequestParam 注解来获取参数，实参值赋给形参。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestParam(value=&quot;username&quot;,required = false, defaultValue =&quot;mrjoker&quot;)</span> String s1, <span class="meta">@RequestParam(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>通过 PathVariable 注解来动态获取参数，参数直接附着在 URL 中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/test/&#123;username&#125;/&#123;password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@PathVariable(&quot;username&quot;)</span> String s1, <span class="meta">@PathVariable(&quot;password&quot;)</span> String s2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>通过 ModelAttribute 注解来获取其他方法返回值作为参数，被注释方法会在此 controller 中每个方法执行前被执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldController</span> &#123; </span><br><span class="line">    <span class="meta">@ModelAttribute</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">populateModel</span><span class="params">(<span class="meta">@RequestParam</span> String abc, Model model)</span> &#123; </span><br><span class="line">        model.addAttribute(<span class="string">&quot;attributeName&quot;</span>, abc); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/helloWorld&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">helloWorld</span><span class="params">()</span> &#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;helloWorld&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST-请求参数"><a href="#POST-请求参数" class="headerlink" title="POST 请求参数"></a>POST 请求参数</h3><p>POST 请求请求参数放置在请求体中，有以下两种格式：</p>
<ul>
<li><strong>Form Data 格式</strong></li>
</ul>
<p>请求的 Content-Type 为 application/x-www-form-urlencoded</p>
<p>示例：<code>username=mrjoker&amp;password=123456</code></p>
<ul>
<li><strong>Request Payload 格式</strong></li>
</ul>
<p>请求的 Content-Type 为 application/json 或者 multipart/form-data</p>
<p>示例：<code>&#123;&quot;username&quot;:&quot;mrjoker&quot;, &quot;password&quot;:&quot;123456&quot;&#125;</code></p>
<ol>
<li>AJAX 提交 POST 请求默认使用 Form Data 格式，Spring MVC 会自动解析到对应的 bean 中并获取参数。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 逐个参数接收</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/test&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析为整体接收</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/test&quot;, method=RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">test</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.getUsername() + user.getPassword();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Vue 提交 POST 请求默认使用 Request Payload 格式，Spring MVC 接收时必须进行处理：</p>
<ul>
<li>前端解决方案： axios 库可以使用 qs 库将 json 对象转化为 Form Data 格式。</li>
<li>后端解决方案： Spring Boot 在请求参数上加 <code>@RequestBody</code> 注解，将请求正文解析到对应的 bean 中获取参数。</li>
</ul>
</li>
</ol>
<p><code>@RequestBody</code> 可以直接以 String 接收前端传过来的 json 数据，也可以用对象自动解析前端传过来的 json 数据。对象里定义 List 属性，可用来接收多条 json 数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String 形式接收</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(<span class="meta">@RequestBody</span> String user)</span> &#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">userJson</span> <span class="operator">=</span> JSON.parseObject(user);</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> userJson.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> userJson.getString(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> username + password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析为对象接收</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/test&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateClusterIdByClientAndQueue</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> user.getUsername() + user.getPassword();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>一个请求可以有多个 <code>@RequestParam</code>，但只能有一个 <code>@RequestBody</code>。 URL 内含有参数时，两者可以同时使用。</p>
</blockquote>
<h3 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h3><ol>
<li><p><strong>请求转发（forward）</strong></p>
<p> 客户端（浏览器）向服务器 A 发送一个 URL 请求，服务器 A 会向另一台服务器 B 获取资源并将此资源响应给浏览器。浏览器的 URL 地址仍然是 A 。</p>
</li>
<li><p><strong>重定向（Redirect）</strong></p>
<p> 客户端（浏览器）向服务器 A 发送一个 URL 请求，服务器 A 告知浏览器资源在服务器 B，浏览器会重新发送请求到服务器 B。浏览器的 URL 地址切换为 B。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 请求转发</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&#x27;forward&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/test2?type=&quot;</span> + type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&#x27;redirect&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/test2?type=&quot;</span> + type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在拦截器中，常通过修改 HttpSevletRequest 对象实现请求转发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Controller-配置"><a href="#Controller-配置" class="headerlink" title="Controller 配置"></a>Controller 配置</h2><p>Spring 的 WebMvcConfigurer 接口定义了 Controller 层配置信息（默认为空实现）。</p>
<p>开发者可以通过实现 WebMvcConfigurer 接口或继承 WebMvcConfigurationSupport 类对以下方法进行重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMVCConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解决跨域问题 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">/** 添加拦截器 **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><p>配置如何处理跨域请求，否则返回数据会被浏览器拦截。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">            <span class="comment">// 添加映射路径（全部）</span></span><br><span class="line">    registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">            <span class="comment">// 放行哪些原始域</span></span><br><span class="line">            .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            <span class="comment">// 是否发送 Cookie 信息</span></span><br><span class="line">            .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">            <span class="comment">// 放行哪些原始域(请求方式)</span></span><br><span class="line">            .allowedMethods(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">            <span class="comment">// 放行哪些原始域(头部信息)</span></span><br><span class="line">            .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">            <span class="comment">// 暴露哪些头部信息</span></span><br><span class="line">            .exposedHeaders(<span class="string">&quot;Header1&quot;</span>, <span class="string">&quot;Header2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>局部跨域</strong></p>
<ol>
<li><code>@CrossOrigin</code> 注解：在方法上（@RequestMapping）或者在控制器（@Controller）上使用，可以实现局部跨域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@CrossOrigin(&quot;http://localhost:8080&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">( )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 HttpServletResponse 对象添加响应头实现局部跨域。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">    response.addHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>);         <span class="comment">// 指定端口放行</span></span><br><span class="line">    <span class="comment">// response.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);                             全部放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拦截器-amp-过滤器"><a href="#拦截器-amp-过滤器" class="headerlink" title="拦截器 &amp; 过滤器"></a>拦截器 &amp; 过滤器</h3><ul>
<li><strong>拦截器(Interceptor)</strong></li>
</ul>
<p>Java Web 中，在执行 Controller 方法前后对 Controller 请求进行拦截和处理。依赖于 web 框架，在 Spring 配置。在实现上基于 Java 的反射机制。</p>
<ul>
<li><strong>过滤器(Filter)</strong></li>
</ul>
<p>Java Web 中，在 request/response 传入 Servlet 前，过滤信息或设置参数。依赖于 servlet 容器，在 web.xml 配置。在实现上基于函数回调。</p>
<blockquote>
<p>两者常用于修改字符编码、删除无用参数、登录校验等。Spring 框架中优先使用拦截器：功能接近、使用更加灵活。</p>
</blockquote>
<p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在配置中引入拦截器对象（单独编写拦截器类）</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 导入拦截器对象，默认拦截全部</span></span><br><span class="line">    <span class="type">InterceptorRegistration</span> <span class="variable">addInterceptor</span> <span class="operator">=</span> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">myInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除配置</span></span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/error&quot;</span>,<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;/user/login&quot;</span>);               </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/asserts/**&quot;</span>);                       </span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/webjars/**&quot;</span>);</span><br><span class="line">    addInterceptor.excludePathPatterns(<span class="string">&quot;/public/**&quot;</span>);</span><br><span class="line">    <span class="comment">// 拦截配置</span></span><br><span class="line">    addInterceptor.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器类通过实现 HandlerInterceptor 接口或者继承 HandlerInterceptorAdapter 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myInterceptor</span> <span class="keyword">extends</span> <span class="title class_">HandlerInterceptorAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Session key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SESSION_KEY</span> <span class="operator">=</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle 预处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 检查 session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(SESSION_KEY) != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 重定向到登录页面</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;message&quot;</span>,<span class="string">&quot;登录失败，请先输入用户名和密码。&quot;</span>);</span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;login&quot;</span>).forward(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postHandle 善后处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="line"><span class="params">                           ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;INTERCEPTOR POSTHANDLE CALLED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过滤器类通过继承 Filter 类实现，直接添加注解即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>                                                                <span class="comment">// 作为组件，交给容器处理</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span>                                                     <span class="comment">// 扫描组件</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/login/*&quot;,filterName = &quot;loginFilter&quot;)</span>           <span class="comment">// 设定过滤路径和名称</span></span><br><span class="line"><span class="meta">@Order(1)</span>                                                                 <span class="comment">// 设定优先级（值小会优先执行）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 过滤器前执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行内部逻辑</span></span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        <span class="comment">// 过滤器后执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>调用顺序</strong></p>
<p><img src="/pic/filter.png" alt="filter"></p>
<hr>
<h3 id="Spring-Boot配置HTTPS"><a href="#Spring-Boot配置HTTPS" class="headerlink" title="Spring Boot配置HTTPS"></a>Spring Boot配置HTTPS</h3><p>####生成SSL证书</p>
<p><a href="https://www.cnblogs.com/benwu/articles/4891758.html">https://www.cnblogs.com/benwu/articles/4891758.html</a></p>
<p>JDK提供证书管理工具: JDK\bin\keytool.exe </p>
<p><font size =2 color = green>Tomcat使用Java提供的密码库，通过Java的Keytool工具生成JKS等格式的证书文件。<br>Apache使用OpenSSL提供的密码库，生成PEM、KEY、CRT等格式的证书文件。</font></p>
<p><strong>cmd命令(JDK\bin目录打开)</strong></p>
<p>密钥库: 保存密钥和对应的证书。【证书只含有公钥】</p>
<p><font size =2 color = blond>genkeypair 生成密钥对（非对称加密算法）<br>genseckey 生成密钥（对称加密算法）<br></font><br>创建名为tomcat的密钥对以及自签名的证书，放入mykeystore密钥库中（不存在则创建）<br><code>keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -validity 180 -keypass &quot;123456&quot; -keystore &quot;D:\mykeystore.keystore&quot; -storetype PKCS12 -storepass </code></p>
<ul>
<li>alias 证书别名</li>
<li>keyalg 加密算法，生成密钥对默认RSA</li>
<li>keysize 密钥键长，RSA默认2048</li>
<li>validity 证书有效期，默认90</li>
<li>keypass 证书密码</li>
<li>keystore 密钥库路径，默认创建在用户目录下</li>
<li>storetype 密钥库类型，默认JKS</li>
<li>storepass 密钥库密码</li>
</ul>
<p>查看密钥库<br><code>keytool -list -v -alias tomcat -keystore &quot;D:\mykeystore.keystore&quot; -storepass 123456 </code></p>
<p>将生成的证书文件拷贝到项目resources目录下</p>
<p>####修改全局配置文件</p>
<p>application.properties格式</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span> = <span class="string">8443</span></span><br><span class="line"><span class="attr">server.ssl.key-store</span> = <span class="string">classpath:mykeystore.keystore</span></span><br><span class="line"><span class="attr">server.ssl.key-store-password</span> = <span class="string">123456</span></span><br><span class="line"><span class="attr">server.ssl.keyStoreType</span> = <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">server.ssl.keyAlias</span> = <span class="string">tomcat</span></span><br></pre></td></tr></table></figure>

<p>设置SSL后，默认使用HTTPS协议。访问localhost:8443，会出现证书安全提示，强行进入即可。<br><font size =2 color = brown>【未付费注册，不被数字认证机构CA认可：会被浏览器标记为不安全】</font></p>
<p>如果将服务器端口号设置成443端口,即https的默认访问端口,那么在进行https访问的时候可以不带端口号直接访问。</p>
<p><strong>修改入口文件</strong></p>
<p>如果访问<a href="http://localhost:8443，则提示需要TLS。">http://localhost:8443，则提示需要TLS。</a></p>
<p>》》将http连接自动转换为https连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSslApplication</span> &#123;</span><br><span class="line">    <span class="comment">//servlet容器，自己写的bean会覆盖自动配置的bean？</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServletWebServerFactory <span class="title function_">servletContainer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TomcatServletWebServerFactory</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">        tomcat.addAdditionalTomcatConnectors(createStandardConnector());</span><br><span class="line">        <span class="keyword">return</span> tomcat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">　　<span class="comment">// 新建connecter监听80端口，并重定向至8443</span></span><br><span class="line">    <span class="keyword">private</span> Connector <span class="title function_">createStandardConnector</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        connector.setScheme(<span class="string">&quot;http&quot;</span>);</span><br><span class="line">        connector.setPort(<span class="number">80</span>);</span><br><span class="line">        connector.setSecure(<span class="literal">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8443</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>重新配置Servlet容器(Tomcat)</p>
<p>自动配置类ServletWebServerFactoryAutoConfiguration会读取bean</p>
<p><a href="https://www.jianshu.com/p/017a7f40efff">https://www.jianshu.com/p/017a7f40efff</a></p>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Session</title>
    <url>/2023/05/14/javaee/spring/SpringSession/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h1><h2 id="Session-共享问题"><a href="#Session-共享问题" class="headerlink" title="Session 共享问题"></a>Session 共享问题</h2><p>在 Web 项目开发中，Session 会话管理是一个很重要的部分，用于存储与记录用户的状态或相关的数据。</p>
<p>通常情况下 session 交由容器（tomcat）来负责存储和管理，但是如果项目部署在多台 tomcat 中，则 session 管理存在很大的问题：</p>
<ol>
<li><p>多台 tomcat 之间无法共享 session ，当负载均衡跳转到其它 tomcat 时，session 就失效了，用户就退出了登录。</p>
</li>
<li><p>一旦 tomcat 容器关闭或重启也会导致 session 会话失效。</p>
</li>
</ol>
<h2 id="Spring-Session-简介"><a href="#Spring-Session-简介" class="headerlink" title="Spring Session 简介"></a>Spring Session 简介</h2><p>Spring Session 是 Spring 家族中的一个子项目，Spring Session 提供了用于管理用户会话信息的 API 和实现。</p>
<p>它把 servlet 容器实现的 httpSession 替换为 spring-session ，Session 信息存储在 Redis 或其它数据库中统一管理，解决了 session 共享的问题。</p>
<h2 id="Spring-Session-实现"><a href="#Spring-Session-实现" class="headerlink" title="Spring Session 实现"></a>Spring Session 实现</h2><p>SessionRepositoryFilter 类是一个 Filter 过滤器，符合 Servlet 的规范定义，用来修改包装请求和响应。这里负责包装切换 HttpSession 至 Spring Session 的请求和响应。</p>
<p>在登录/登出时调用 session.setAttritube 和 session.removeAttritube 方法时，将切换为对 redis 中的 session 进行修改。</p>
<h2 id="Spring-Session-实现-1"><a href="#Spring-Session-实现-1" class="headerlink" title="Spring Session 实现"></a>Spring Session 实现</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot Redis 依赖  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件 <code>application.properties</code></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Spring Session 配置</span></span><br><span class="line"><span class="comment"># 数据源</span></span><br><span class="line"><span class="attr">spring.session.store-type</span>=<span class="string">redis</span></span><br><span class="line"><span class="comment"># redis 刷新模式</span></span><br><span class="line"><span class="attr">spring.session.redis.flush-mode</span>=<span class="string">on_save</span></span><br><span class="line"><span class="comment"># redis 命名空间</span></span><br><span class="line"><span class="attr">spring.session.redis.namespace</span>=<span class="string">test_session</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># session 过期时间</span></span><br><span class="line"><span class="attr">server.servlet.session.timeout</span>=<span class="string">3600s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 配置</span></span><br><span class="line"><span class="comment"># Redis数据库索引</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.0.1</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure>




<blockquote>
<p>参考链接 <a href="https://www.cnblogs.com/lxyit/p/9672097.html">https://www.cnblogs.com/lxyit/p/9672097.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC</title>
    <url>/2023/05/14/javaee/spring/SpringIOC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h1><p><a href="https://www.jianshu.com/p/ad05cfe7868e">https://www.jianshu.com/p/ad05cfe7868e</a></p>
<hr>
<h2 id="IOC-原理"><a href="#IOC-原理" class="headerlink" title="IOC 原理"></a>IOC 原理</h2><h3 id="代码耦合"><a href="#代码耦合" class="headerlink" title="代码耦合"></a>代码耦合</h3><p>实际开发中，我们如果在对象 A 内部去创建、修改或者注销另一个对象 B，这会导致对象之间非常复杂的依赖关系，不利于代码的维护更新。</p>
<p>比如我们直接在上层类内调用了底层类的构造方法，一旦底层类的构造方法发生改变，就必须修改所有上层类的代码。</p>
<p><img src="/pic/%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB.png"></p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>( Dependency Injection ) 我们用依赖注入的方式来降低耦合度。所谓依赖注入，就是把底层对象作为参数传入上层对象。避免底层类被修改后上层类代码也要随之改动。我们一般通过构造方法或者 setter 方法注入底层对象。</p>
<ol>
<li>设值注入：依赖的对象通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。</li>
<li>构造注入：依赖的对象是通过构造器传入，发生在实例化 Bean 的时候。</li>
</ol>
<p><em>主要采用设值注入，性能更好更易读。但对于依赖关系无需变化的 Bean 采用构造注入。所有的依赖关系全部在构造器内设定。</em></p>
<p><img src="%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.png"></p>
<p>优势：使用依赖注入后，即使底层类发生变化，上层类代码也不必改动，大大降低了代码的耦合度。</p>
<p>劣势：但这也导致了我们在初始化对象的过程中要书写复杂的代码。</p>
<h3 id="控制反转"><a href="#控制反转" class="headerlink" title="控制反转"></a>控制反转</h3><p>( Inversion of Control ) 控制反转，将对象的管理权交给 IOC 容器。</p>
<p>Spring 框架内会定义一个 IOC 容器类，通过其来统一管理对象的生命周期：创建、资源存取、注销；并自动维护对象间的依赖关系。用户只需要配置 XML 文件或者添加注解标明类之间的映射关系，初始化过程中的代码将由 IOC 容器自动完成。</p>
<p>IOC 容器底层通过工厂模式和 Java 反射机制来实现：</p>
<ol>
<li>IOC 容器根据 XML 配置文件或者注解读取 Bean 中保存的对象信息。</li>
<li>IOC 容器充当工厂类，利用 Java 反射机制读取需要生成哪些对象，来自动生成相应的对象。</li>
</ol>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h3><p>在 Spring 框架中已经定义了 ApplicationContext 和 BeanFactory 作为 IOC 容器类。其中 ApplicationContext是 BeanFactory 的子类，提供了事件发布、国际化信息支持等其他高级特性。</p>
<p>我们可以通过 IOC 容器类的 setBean 方法创建 Bean ，也可以通过 getBean 方法把 Bean 实例化并使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置文件，创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// IOC 容器根据 Bean 创建对象实例</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">newUser</span> <span class="operator">=</span> (Person) context.getBean(<span class="string">&quot;person&quot;</span>);</span><br><span class="line">    <span class="comment">// 调用对象方法</span></span><br><span class="line">    System.out.print(newUser.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Java-Bean"><a href="#Java-Bean" class="headerlink" title="Java Bean"></a>Java Bean</h3><p>Java Bean 就是程序中被管理的对象在 IOC 容器中的代理，记录了对象信息。</p>
<p>Bean 包含以下参数：Bean 名称(name) 、所代理的类(class) 、以及作用域(scope)。</p>
<h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><ul>
<li><strong>singleton 单例模式</strong>（默认）： 在整个 IoC 容器中，Bean 只有一个对象实例。</li>
<li><strong>prototype 原型模式</strong>： 每次调用 Ioc 容器的 getBean 方法，都将产生一个新的对象实例。</li>
<li><strong>request</strong>： 对于每次 HTTP 请求，Bean 都将产生一个新的对象实例。</li>
<li><strong>session</strong>： 对于每个 HTTP Session，Bean 都将产生一个新的对象实例。</li>
<li><strong>global session</strong>： 对于每个全局的 HTTP Session，Bean 都将产生一个新的对象实例。</li>
</ul>
<h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><p>Spring 对 Bean 方法进行了抽象和封装，开发者只需要进行配置和调用简单接口，具体实现都交付给 Spring 工厂来管理。</p>
<p>在调用 getBean 方法时，Spring 的工作流大致可分为以下两步：</p>
<ol>
<li>解析：读 xml 配置，扫描类文件，从配置或者注解中获取 Bean 的定义信息，注册一些扩展功能。</li>
<li>加载：通过解析完的定义信息获取 Bean 实例。</li>
</ol>
<p><img src="bean.png"></p>
<p>获取 BeanName，对传入的 name 进行解析，转化为可以从 Map 中获取到 BeanDefinition 的 bean name。<br>合并 Bean 定义，对父类的定义进行合并和覆盖，如果父类还有父类，会进行递归合并，以获取完整的 Bean 定义信息。<br>实例化，使用构造或者工厂方法创建 Bean 实例。<br>属性填充，寻找并且注入依赖，依赖的 Bean 还会递归调用 getBean 方法获取。<br>初始化，调用自定义的初始化方法。<br>获取最终的 Bean，如果是 FactoryBean 需要调用 getObject 方法，如果需要类型转换调用 TypeConverter 进行转化。</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>三个类 A、B、C，然后 A 关联 B，B 关联 C，C 又关联 A，这就形成了一个循环依赖。如果是方法调用是不算循环依赖的，循环依赖必须要持有引用。</p>
<ol>
<li>构造器循环依赖。依赖的对象是通过构造器传入的，发生在实例化 Bean 的时候。</li>
</ol>
<p>无法解决</p>
<ol start="2">
<li>设值循环依赖。依赖的对象是通过 setter 方法传入的，对象已经实例化，发生属性填充和依赖注入的时候。</li>
</ol>
<p>Spring 框架只支持单例下的设值循环依赖。原型模式检测到循环依赖会直接抛出 BeanCurrentlyInCreationException 异常。</p>
<p><a href="https://www.jianshu.com/p/9ea61d204559">https://www.jianshu.com/p/9ea61d204559</a></p>
<hr>
<h2 id="IOC-注解详解"><a href="#IOC-注解详解" class="headerlink" title="IOC 注解详解"></a>IOC 注解详解</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>为类添加 <code>@Configuration</code> 注解，表示该类为配置类。起到类似 XML 文件的作用，配置 IOC 容器用来管理 Bean。</p>
<h4 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h4><p>为配置类添加 <code>@ComponentScan</code> 注解，启用组件扫描。配置类将根据注解向 IOC 容器添加 Bean，默认扫描本类中的 @Bean 方法。</p>
<p>可以指定需要扫描的包，这会扫描包内的所有组件。如 <code>@ComponentScan(value=&quot;com.company.project&quot;)</code>。</p>
<h3 id="注册-setBean"><a href="#注册-setBean" class="headerlink" title="注册 (setBean)"></a>注册 (setBean)</h3><ul>
<li><strong>为类添加 <code>@Component</code> 注解</strong></li>
</ul>
<p>表示该类型被注册为 Bean 。Bean 的名称默认为类名的首字母小写，作用域默认为单例模式。</p>
<ol>
<li><p>可以为注册的 Bean 指定名称，等同于 <code>@Component(&quot;car&quot;)</code> 。</p>
</li>
<li><p>可以为注册的 Bean 指定作用域，如 <code>@Component(&quot;prototype&quot;)</code> 。</p>
</li>
</ol>
<p>在 Spring MVC 中，我们可以把 <code>@Component</code> 细化为：</p>
<ul>
<li><code>@Controller</code> 注解：表示展示层的 Bean</li>
<li><code>@Service</code> 注解：表示业务层的 Bean</li>
<li><code>@Repository</code> 注解：表示数据访问层的 Bean</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line">    <span class="meta">@AutoWired</span></span><br><span class="line">    <span class="keyword">private</span> FrameWork frameWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>为方法添加 <code>@Bean</code> 注解</strong></li>
</ul>
<p>方法返回类型将被注册为 Bean。Bean 的名称默认为方法名，作用域默认为单例模式。</p>
<ul>
<li><p>可以为注册的 Bean 指定名称，等同于 <code>@Bean(name = &quot;myFoo&quot;)</code> 。</p>
</li>
<li><p>主要用在 @Configuration 注解的类里，也可以用在 @Component 注解的类里。</p>
</li>
</ul>
<h3 id="装配-getBean"><a href="#装配-getBean" class="headerlink" title="装配 (getBean)"></a>装配 (getBean)</h3><ul>
<li><strong>为对象添加 <code>@Autowired</code> 注解</strong></li>
</ul>
<p>表示自动装配。在使用对象时 Spring 将<strong>根据类型</strong>自动查找 Bean 去创建对象，无法找到 Bean 则抛出异常。</p>
<ol>
<li><p>如果想要在无法找到 Bean 时返回 null 值，则将注解改为 <code>@Autowired(required=false)</code> 。</p>
</li>
<li><p>如果自动装配对象的类型是接口，而配置的实现类 Bean 有多个。则必须用 <code>@Qualifier</code> 注解来指定 Bean 的名称。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Vehicle vehicle;</span><br></pre></td></tr></table></figure>


<ul>
<li><strong>为对象添加 <code>@Resource</code> 注解</strong></li>
</ul>
<p>表示自动装配。默认按对象名称去查找 Bean，找不到再按类型去查找 Bean。</p>
<ol>
<li><p>注解可以指定按名称或者类型去查找 Bean，如 <code>@Resource(name=&quot;car&quot;)</code> 或者 <code>@Resource(type=Car.class)</code>。</p>
</li>
<li><p>也可以同时按名称和类型查找 Bean，任何一个不匹配都将报错。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name=&quot;car&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Vehicle vehicle;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>@Autowired 是 Spring 的注解，@Resource 是 J2EE 的注解。</p>
</blockquote>
]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Security</title>
    <url>/2023/05/14/javaee/spring/SpringSecurity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><p><a href="https://www.jianshu.com/p/4cee4b19ec40">https://www.jianshu.com/p/4cee4b19ec40</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>spring security 的核心功能主要包括：</p>
<p>认证 （你是谁）<br>授权 （你能干什么）<br>攻击防护 （防止伪造身份）</p>
<p>其核心就是一组过滤器链，项目启动后将会自动配置。最核心的就是 Basic Authentication Filter 用来认证用户的身份，一个在spring security中一种过滤器处理一种认证方式。</p>
<p><img src="/pic/filters.jpg"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Spring Security 的配置类，通过继承 <code>WebSecurityConfigurerAdapter</code> 类实现，可以重写一下三种方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//我代表代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//我代表代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//我代表代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置全局信息"><a href="#配置全局信息" class="headerlink" title="配置全局信息"></a>配置全局信息</h3><p><code>AuthenticationManagerBuilder</code> 类用来配置全局的认证相关的信息：</p>
<ol>
<li><code>AuthenticationProvider</code> ：认证服务提供者</li>
<li><code>UserDetailsService</code> ：认证用户（及其权限）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 添加后门</span></span><br><span class="line">    auth.authenticationProvider(backdoorAuthenticationProvider);</span><br><span class="line">    <span class="comment">// 自定义AuthenticationProvider实例加入AuthenticationManager</span></span><br><span class="line">    auth.userDetailsService(backendSysUserDetailsServiceImpl).passwordEncoder(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>());</span><br><span class="line">    auth.authenticationProvider(backendSysUserAuthenticationProvider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="权限控制"><a href="#权限控制" class="headerlink" title="权限控制"></a>权限控制</h3><p><code>HttpSecurity</code> 类负责具体的权限控制规则配置。每配置相当于 xml 配置中的一个标签。</p>
<p>各种具体的认证机制的相关配置，OpenIDLoginConfigurer、AnonymousConfigurer、FormLoginConfigurer、HttpBasicConfigurer<br>LogoutConfigurer<br>RequestMatcherConfigurer：spring mvc style、ant style、regex style<br>HeadersConfigurer：<br>CorsConfigurer、CsrfConfigurer<br>SessionManagementConfigurer：<br>PortMapperConfigurer：<br>JeeConfigurer：<br>X509Configurer：<br>RememberMeConfigurer：<br>ExpressionUrlAuthorizationConfigurer：<br>RequestCacheConfigurer：<br>ExceptionHandlingConfigurer：<br>SecurityContextConfigurer：<br>ServletApiConfigurer：<br>ChannelSecurityConfigurer：<br>此模块的authenticationProvider和userDetailsService；<br>SecurityFilterChain控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/index&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;/error&quot;</span></span><br><span class="line">            ).permitAll()</span><br><span class="line">            .antMatchers(<span class="string">&quot;/user/**&quot;</span>).hasRole(<span class="string">&quot;USER&quot;</span>)</span><br><span class="line">            .antMatchers(<span class="string">&quot;/admin/**&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .formLogin().loginPage(<span class="string">&quot;/login&quot;</span>).defaultSuccessUrl(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">            <span class="comment">//TODO 自定义参数名称，与login.html中的参数对应</span></span><br><span class="line">            .usernameParameter(<span class="string">&quot;myusername&quot;</span>).passwordParameter(<span class="string">&quot;mypassword&quot;</span>)</span><br><span class="line">            .and()</span><br><span class="line">            .logout().logoutUrl(<span class="string">&quot;/logout&quot;</span>).logoutSuccessUrl(<span class="string">&quot;/login&quot;</span>)</span><br><span class="line">            <span class="comment">//鉴权</span></span><br><span class="line">            .and()</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">            .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O object)</span> &#123;</span><br><span class="line">                    object.setSecurityMetadataSource(backendSysRoleSecurityMetadataSourceImpl);</span><br><span class="line">                    object.setAccessDecisionManager(backendSysRoleAccessDecisionManagerImpl);</span><br><span class="line">                    <span class="keyword">return</span> object;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="忽略规则配置"><a href="#忽略规则配置" class="headerlink" title="忽略规则配置"></a>忽略规则配置</h3><p><code>WebSecurity</code> 类负责全局请求忽略规则配置（比如静态文件、注册页面）、全局 HttpFirewall 配置、是否debug配置、全局SecurityFilterChain配置、privilegeEvaluator、expressionHandler、securityInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(WebSecurity web)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">     web.ignoring().antMatchers(<span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>javaee</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>javaee</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/hadoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="Hadoop-概念"><a href="#Hadoop-概念" class="headerlink" title="Hadoop 概念"></a>Hadoop 概念</h2><h3 id="Hadoop-简介"><a href="#Hadoop-简介" class="headerlink" title="Hadoop 简介"></a>Hadoop 简介</h3><p>Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有着高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上。而且它提供高传输率（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求（requirements）这样可以流的形式访问（streaming access）文件系统中的数据。</p>
<h3 id="Hadoop-架构"><a href="#Hadoop-架构" class="headerlink" title="Hadoop 架构"></a>Hadoop 架构</h3><p><img src="/pic/architecture.png"></p>
<ul>
<li>HDFS: 分布式文件存储</li>
<li>YARN: 分布式资源管理</li>
<li>MapReduce: 分布式计算</li>
<li>Others: 利用YARN的资源管理功能实现其他的数据处理方式</li>
</ul>
<p>内部各个节点基本都是采用Master-Woker架构</p>
<h2 id="分布式文件系统HDFS"><a href="#分布式文件系统HDFS" class="headerlink" title="分布式文件系统HDFS"></a>分布式文件系统HDFS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/pic/hadoop.png"></p>
<ul>
<li><strong>Block 数据块</strong></li>
</ul>
<p>基本存储和读写单位，一般大小为 64M（不同文件的块大小可以不一致）。大文件会被拆分成一个个的块，然后存储于不同的机器。</p>
<p>配置大的块主要是因为：</p>
<ol>
<li>减少搜寻时间，一般硬盘传输速率比寻道时间要快，大的块可以减少寻道时间；</li>
<li>减少管理块的数据开销，每个块都需要在NameNode上有对应的记录；</li>
<li>对数据块进行读写，减少建立网络的连接成本.</li>
</ol>
<ul>
<li><strong>DataNode</strong></li>
</ul>
<p>保存具体的 block 数据，负责数据的读写操作和复制操作。</p>
<ol>
<li>DataNode 启动时会向 NameNode 报告当前存储的数据块信息，后续也会定时报告修改信息。</li>
<li>DataNode 之间会进行通信，复制数据块，保证数据的冗余性</li>
</ol>
<ul>
<li><strong>NameNode</strong></li>
</ul>
<p>一个 Block 在 NameNode 中对应一条记录，保存数据块的具体存储信息，一般占用 150 字节。</p>
<p>运行时所有数据都保存到内存。数据会定时保存到本地磁盘，但不保存 block 的位置信息（DataNode 信息），而是由 DataNode 注册时上报和运行时维护，NameNode每次重启后动态重建。</p>
<p>NameNode 失效则整个 HDFS 都失效，所以使用 Secondary NameNode 定时与 NameNode 进行同步（定期合并文件系统镜像和编辑日志，然后把合并后的传给NameNode，替换其镜像，并清空编辑日志），但 NameNode 失效后仍需要手工将其设置成主机。</p>
<h3 id="Block-副本放置策略"><a href="#Block-副本放置策略" class="headerlink" title="Block 副本放置策略"></a>Block 副本放置策略</h3><p>每个块都会被复制到多台机器，默认复制3份.</p>
<p>第一个副本：放置在上传文件的DN；如果是集群外提交，则随机挑选一台磁盘不太满，CPU不太忙的节点。<br>第二个副本：放置在于第一个副本不同的 机架的节点上。<br>第三个副本：与第二个副本相同机架的其他节点。<br>更多副本：随机节点</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/rpc/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC(Remote Procedure Call)：远程过程调用，即通过网络从远程计算机程序上请求服务，更多技术思想而非一种规范或协议。而不需要了解底层网络技术。</p>
<h3 id="什么是垂直架构"><a href="#什么是垂直架构" class="headerlink" title="什么是垂直架构"></a>什么是垂直架构</h3><p>所有功能模块在一个项目中编写，并集中部署。</p>
<p>缺点：项目耦合度高，不利于团队开发，也不利于后期升级和维护。</p>
<h3 id="什么是-SOA-架构"><a href="#什么是-SOA-架构" class="headerlink" title="什么是 SOA 架构"></a>什么是 SOA 架构</h3><p>SOA：面向服务架构，也叫分布式架构。</p>
<p>将产品 Controller 层和 Service 层分离，其中每个功能模块都作为一个项目开发并单独部署，之间互不依赖，模块与模块之间通过服务的形式传递数据。</p>
<p>用户在访问前台系统(Tomcat) 时，接受相应的 Controller 会向指定的服务器调用相应的 Service 执行。</p>
<h3 id="集群和负载均衡"><a href="#集群和负载均衡" class="headerlink" title="集群和负载均衡"></a>集群和负载均衡</h3><p>当大量用户同时访问同一个系统时，系统会因为访问量过大而宕机。因此高并发的项目中，往往有多个相同功能的 Controller (Tomcat)部署在不同的服务器同时工作，形成系统集群。</p>
<p>为防止某一个系统因访问量过大而宕机，需要把所有的请求尽可能均匀地分配给所有的系统。这叫做负载均衡。</p>
<h3 id="如何做负载均衡"><a href="#如何做负载均衡" class="headerlink" title="如何做负载均衡"></a>如何做负载均衡</h3><p>Nginx 服务器对高并发非常擅长，多用于负载均衡。用户请求会先把请求发给 Nginx 负载均衡器，再将请求分配给合适的系统。</p>
<p>当并发量更大的时候，还需要在硬件层对用户请求进行负载均衡，再把请求转发给合适的 Nginx 负载均衡器。这需要的昂贵的专业仪器，而不由软件工程师负责。</p>
<h3 id="什么是-Dubbo"><a href="#什么是-Dubbo" class="headerlink" title="什么是 Dubbo"></a>什么是 Dubbo</h3><p>阿里巴巴开发的开源跨服务器调用服务，用于系统(controller)对服务(service)的远程调用。</p>
<p>Dubbo是基于RPC实现的：JDK底层的远程调用协议，由 Dubbo 实现。</p>
<p>【同类型的还有Spring Cloud。】</p>
<h3 id="Dubbo-的具体实现"><a href="#Dubbo-的具体实现" class="headerlink" title="Dubbo 的具体实现"></a>Dubbo 的具体实现</h3><ul>
<li>Controller层 使用 @reference 注解 (Dubbo包内！)</li>
<li>Service层 使用 @service 注解 (Dubbo包内！)</li>
</ul>
<p>注意 POJO 类的网络传输是序列化后完成的，所以实体类必须实现序列化。</p>
<h3 id="什么是-ZooKeeper"><a href="#什么是-ZooKeeper" class="headerlink" title="什么是 ZooKeeper"></a>什么是 ZooKeeper</h3><p>Service 服务启动后，会向 ZooKeeper 注册自己的IP和端口号。</p>
<p>Controller 系统通过访问 ZooKeeper 注册中心查找请求的服务IP和端口号，然后通过 Dubbo 实现对服务中方法的调用。</p>
<h3 id="Linux-下安装-ZooKeeper"><a href="#Linux-下安装-ZooKeeper" class="headerlink" title="Linux 下安装 ZooKeeper"></a>Linux 下安装 ZooKeeper</h3>]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>spark</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/spark/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="流处理器"><a href="#流处理器" class="headerlink" title="流处理器"></a>流处理器</h1><hr>
<h2 id="Spark-Streaming"><a href="#Spark-Streaming" class="headerlink" title="Spark Streaming"></a>Spark Streaming</h2><p>Spark 是一种快速、通用、可扩展的大数据分析引擎，已经发展成为一个包含多个子项目的集合。 Spark Streaming 是 Spark 的流处理部分。</p>
<p>Spark 的流处理是基于所谓微批处理的思想，把流处理看作是批处理的一种特殊形式，每次接收到一个时间间隔的数据才会去处理，所以天生很难在实时性上有所提升。</p>
<p>虽然在 Spark2.3 中提出了连续处理模型( Continuous Processing Model),但是现在只支持很有限的功能,并不能在大的项目中使用。 Spark还需要做出很大的努力才能改进现有的流处理模型想要在流处理的实时性上提升,就不能継续用微批处理的模式,而要想办法实现真正的流处理即每当有一条数据输入就立刻处理,不做等待。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>在内部，每个数据块就是一个 RDD，所以 spark streaming 有 RDD 所有优点，处理速度快，容错性好，支持高度并行计算。</p>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>第一，我们将Spark Streaming类名和StreamingContext的一些隐式转换导入到我们的环境中，以便将有用的方法添加到我们需要的其他类（如DStream）中。StreamingContext是所有流功能的主要入口点。我们创建一个带有两个执行线程的本地StreamingContext，批处理间隔为1秒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 工作环境</span></span><br><span class="line">    <span class="type">SparkConf</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SparkConf</span>().setMaster(<span class="string">&quot;local[2]&quot;</span>).setAppName(<span class="string">&quot;NetworkWordCount&quot;</span>);     <span class="comment">// 定义双线程 / APP 名称</span></span><br><span class="line">    <span class="type">JavaStreamingContext</span> <span class="variable">jssc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaStreamingContext</span>(conf, Durations.seconds(<span class="number">1</span>));          <span class="comment">// 定义批处理时间间隔 1s</span></span><br><span class="line">    <span class="comment">// 流创建（从源导入）</span></span><br><span class="line">    JavaReceiverInputDStream&lt;String&gt; lines = jssc.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">    <span class="comment">// 流处理（数据分离、统计并打印）</span></span><br><span class="line">    JavaDStream&lt;String&gt; words = lines.flatMap(x -&gt; Arrays.asList(x.split(<span class="string">&quot; &quot;</span>)).iterator());    </span><br><span class="line">    JavaPairDStream&lt;String, Integer&gt; pairs = words.mapToPair(s -&gt; <span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(s, <span class="number">1</span>));</span><br><span class="line">    JavaPairDStream&lt;String, Integer&gt; wordCounts = pairs.reduceByKey((i1, i2) -&gt; i1 + i2);</span><br><span class="line">    wordCounts.print();</span><br><span class="line">    <span class="comment">// 启动流运算</span></span><br><span class="line">    jssc.start();</span><br><span class="line">    jssc.awaitTermination();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="DStream-对象"><a href="#DStream-对象" class="headerlink" title="DStream 对象"></a>DStream 对象</h4><p>Spark Streaming 提供一个对于流数据的抽象 DStream。DStream 可以由来自 Apache Kafka、Flume 或者 HDFS 中的流数据生成，也可以由别的 DStream 经过各种转换操作得来。</p>
<p>底层 DStream 也是由很多个序列化的 RDD 构成，按时间片（比如一秒）切分成的每个数据单位都是一个 RDD。然后，Spark 核心引擎将对 DStream 的 Transformation 操作变为针对 Spark 中对 RDD 的 Transformation 操作，将 RDD 经过操作变成中间结果保存在内存中。</p>
<p>由于 Spark Streaming 将底层的细节封装起来了，所以对于开发者来说，只需要操作 DStream 就行。接下来，让我们一起学习 DStream 的结构以及它支持的转换操作。</p>
<h4 id="StreamingContext-对象"><a href="#StreamingContext-对象" class="headerlink" title="StreamingContext 对象"></a>StreamingContext 对象</h4><p>任何 Spark Streaming 的程序都要首先创建一个 StreamingContext 的对象，它是所有 Streaming 操作的入口。StreamingContext 中最重要的参数是批处理的时间间隔，即把流数据细分成数据块的粒度。</p>
<p>用 <code>streamingContext.start()</code> 来开始接收数据并处理它<br>用 <code>streamingContext.awaitTermination()</code> 等待处理停止（手动停止或由于任何错误）<br>用 <code>streamingContext.stop()</code> 可以手动停止</p>
<p>一旦启动上下文，就无法设置新的流计算或将其添加到该流计算中<br>上下文一旦停止，就无法重新启动<br>一个JVM中只能同时激活一个StreamingContext<br>StreamingContext中的stop()也会停止SparkContext。但如果要仅停止StreamingContext的话，设置stop(false)<br>只要在创建下一个StreamingContext之前停止了上一个StreamingContext（不停止SparkContext），就可以将SparkContext重用于创建多个StreamingContext</p>
<h2 id="Spark-操作-kafka"><a href="#Spark-操作-kafka" class="headerlink" title="Spark 操作 kafka"></a>Spark 操作 kafka</h2><p>Spark Streaming提供了两类内置的streaming源：</p>
<p>Basic sources ：直接在StreamingContext API中可用的源。例如，文件系统和socket连接<br>Advanced sources ：像Kafka，Flume，Kinesis等这样的源，可通过额外的程序类获得 </p>
<h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><ol>
<li>先把数据接收过来，转换为spark streaming中的数据结构Dstream。接收数据的方式有两种：1.利用Receiver接收数据，2.直接从kafka读取数据。</li>
</ol>
<p>在spark1.3之后，引入了Direct方式。不同于Receiver的方式，Direct方式没有receiver这一层，其会周期性的获取Kafka中每个topic的每个partition中的最新offsets，之后根据设定的maxRatePerPartition来处理每个batch。</p>
<p>0.10以后只保留了direct模式(Reveiver模式不适合生产环境)，并且0.10版本API有变化（更加强大）</p>
<h3 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h3><p>与读数据不同，Spark并没有提供统一的接口用于写入Kafka，所以我们需要使用底层Kafka接口进行包装。<br>最直接的做法我们可以想到如下这种方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">input.foreachRDD(rdd =&gt;</span><br><span class="line">  <span class="comment">// 不能在这里创建KafkaProducer</span></span><br><span class="line">  rdd.foreachPartition(partition =&gt;</span><br><span class="line">    partition.foreach&#123;</span><br><span class="line">      <span class="keyword">case</span> x:String=&gt;&#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>[String, Object]()</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, brokers)</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">          <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,</span><br><span class="line">          <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)</span><br><span class="line">        println(x)</span><br><span class="line">        <span class="type">val</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>[String,String](props)</span><br><span class="line">        val message=<span class="keyword">new</span> <span class="title class_">ProducerRecord</span>[String, String](<span class="string">&quot;output&quot;</span>,<span class="literal">null</span>,x)</span><br><span class="line">        producer.send(message)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>但是这种方式缺点很明显，对于每个partition的每条记录，我们都需要创建KafkaProducer，然后利用producer进行输出操作，注意这里我们并不能将KafkaProducer的新建任务放在foreachPartition外边，因为KafkaProducer是不可序列化的（not serializable）。显然这种做法是不灵活且低效的，因为每条记录都需要建立一次连接。如何解决呢？</p>
<p>首先，我们需要将KafkaProducer利用lazy val的方式进行包装如下：</p>
<hr>
<h2 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h2><p>目前唯一同时支持高吞吐、低延迟、高性能的分布式流式数据处理框架。像Apache Spark也只能兼顾高吞吐和高性能特性，主要因为在Spark Streaming流式计算中无法做到低延迟保障。</p>
<p><strong>优势</strong></p>
<ol>
<li><p>支持事件事件概念。</p>
</li>
<li><p>支持有状态计算，保持了事件原本产生的时序性，避免网络传输带来的影响。</p>
</li>
<li><p>支持高度灵活的窗口操作，Flink将窗口分为Time、Count、Session以及Data-driven等类型的窗口操作，可以灵活的处罚条件定制化来达到对复杂的流传输模式的支持。</p>
</li>
<li><p>基于轻量级分布式快照实现容错，将大型计算任务的流程拆解成小的计算过程，分布到并行节点上处理。并通过 Checkpoints 将执行过程中的状态信息进行持久化存储，可以自动恢复出现异常的任务。</p>
</li>
<li><p>基于 JVM 实现独立的内存管理。</p>
</li>
</ol>
<p><strong>运行环境</strong></p>
<ul>
<li>JDK 版本必须在 1.8 及以上</li>
<li>Maven 版本必须在 3.0.4 及以上</li>
<li>Hadoop 环境支持 hadoop 2.4、2.6、2.7、2.8 等主要版本</li>
</ul>
<p>Flink 支持使用 Java/Scala 开发，以下示例代码全部使用 Java .</p>
<h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><ol>
<li><p>Flink 架构体系基本上分三层（自顶向下）：</p>
<ul>
<li><p><strong>API &amp; Libraries 层</strong>： 提供支撑流计算和批计算的接口，，同时在此基础上抽象出不同的应用类型的组件库。</p>
</li>
<li><p><strong>Runtime 核心层</strong>：Flink分布式计算框架的核心实现层，负责分布式作业的执行、映射转换、任务调度等。将 DataStream 和 DataSet 转成同意的可执行的 Task Operator 。</p>
</li>
<li><p><strong>物理部署层</strong>：目前Flink支持本地、集群、云、容器部署，Flink通过盖层能够支持不同平台的部署，用户可以根据需要选择使用对应的部署模式。</p>
</li>
</ul>
</li>
<li><p>Flink 基本架构</p>
<ul>
<li><p><strong>Client 客户端</strong>：负责将任务提交到集群，与JobManager构建Akka连接，然后将任务提交到JobManager，通过和JobManager之间进行交互获取任务执行状态。</p>
</li>
<li><p><strong>JobManager</strong>：负责整个Flink集群任务的调度以及资源的管理</p>
</li>
<li><p><strong>TaskManager</strong>：相当于整个集群的Slave节点，负责具体的任务执行和对应任务在每个节点上的资源申请与管理。</p>
</li>
</ul>
</li>
</ol>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><ol>
<li> BasicTypeInfo 数据类型：支持任意 Java 原生基本类型或 String 类型。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接获取</span></span><br><span class="line">DataSource&lt;String&gt; inputStream= environment.fromElements(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从集合获取</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list2);</span><br><span class="line">DataSource&lt;String&gt; inputStream= environment.fromCollection(list);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>TupleTypeInfo 数据类型：标识 Tuple 类型数据。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource&lt;Tuple2&gt; inputStreamTuple = environment.fromElements(<span class="keyword">new</span> <span class="title class_">Tuple2</span>(<span class="string">&quot;fangpc&quot;</span>, <span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">Tuple2</span>(<span class="string">&quot;fangpengcheng&quot;</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>PojoTypeInfo 数据类型：描述任意的 POJOs ，字段类型必须是上述基础类型，拥有默认构造方法和 getter/setter 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">personStream</span> <span class="operator">=</span> environment.fromElements(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;fangpc&quot;</span>, <span class="number">24</span>), <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;fangpengcheng&quot;</span>, <span class="number">25</span>));</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><p>Value 数据类型：实现了org.apache.flink.types.Value，其中包括 read() 和 write() 两个方法完成序列化和反序列化操作，有着比较高效的性能。Flink 提供的内建 Value 类型有 IntValue、DoubleValue、StringValue 等。</p>
</li>
<li><p>特殊数据类型：</p>
<ul>
<li>Scala中的List、Map、Either、Option、Try数据类型</li>
<li>Java中Either</li>
<li>Hadoop的Writable数据类型</li>
</ul>
</li>
</ol>
<h3 id="操作流程-1"><a href="#操作流程-1" class="headerlink" title="操作流程"></a>操作流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamingJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建执行环境</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/******** 配置流过程 *********/</span></span><br><span class="line">        addSource();         <span class="comment">// 流创建</span></span><br><span class="line"></span><br><span class="line">                             <span class="comment">// 流转化</span></span><br><span class="line">        <span class="comment">/******** 配置流过程 *********/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        env.execute(<span class="string">&quot;Flink Streaming Java API Skeleton&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>DataStreamSource 对象</strong>是 DataStream 类的子类，代表着数据流的起始点。必须通过 addSource 方法生成, fromCollection/readTextFile 方法底层也会调用 addSource 方法。</p>
<p><strong>DataStream 对象</strong>代表着相同类型元素的流，可以通过转换（transformation）来实现转换为另一个 DataStream 对象。DataStrem 对象内部持有当前的 StreamExecutionEnvironment 对象和 DataTransformation 对象。</p>
<p><strong>StreamExecutionEnvironment 对象</strong>代表着当前流计算执行环境以及相关配置。每个 DataStream 类在做转换的时候，会首先创建转换对应的 DataTransformation 对象，最终形成一个 DataTransformation 链表被 StreamExecutionEnvironment 对象维护。</p>
<blockquote>
<p>Flink 在执行时，会把流拓扑（Source、Transformation、Sink）都转换为 DataFlow：由 Stream 和 Operator 组成，让 Stream在 Operator 中流动。</p>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>当在分布式系统中引入状态时，自然也引入了一致性问题。</p>
<p>在流处理中，一致性分为 3 个级别。</p>
<ul>
<li><p><strong>at-most-once</strong>：故障发生之后，计数结果可能丢失。</p>
</li>
<li><p><strong>at-least-once</strong>：这表示计数结果可能大于正确值，但绝不会小于正确值。也就是说，计数程序在发生故障后可能多算，但是绝不会少算。</p>
</li>
<li><p><strong>exactly-once</strong>：这指的是系统保证在发生故障后得到的计数结果与正确值一致。</p>
</li>
</ul>
<p>第一代流处理器（如 Storm 和 Samza）刚问世时只保证 at-least-once。最先保证 exactly-once 的系统（Storm Trident 和 Spark Streaming）在性能和表现力这两个方面付出了很大的代价。</p>
<hr>
<h2 id="Flink-操作-kafka"><a href="#Flink-操作-kafka" class="headerlink" title="Flink 操作 kafka"></a>Flink 操作 kafka</h2><p><a href="https://zhuanlan.zhihu.com/p/92289771">https://zhuanlan.zhihu.com/p/92289771</a></p>
<p>flink 提供了一个特有的 kafka connector 去读写 kafka topic 的数据。这样在 flink 消费 kafka 数据时，就可以通过 flink 内部去跟踪 offset 和设定 checkpoint 去实现 exactly-once 的语义。</p>
<p>在 Flink 中，我们作为 Consumer 时需要用 Source Connectors 代表连接数据源的连接器，作为 Producer 时需要用 Sink Connector 代表连接数据输出的连接器。</p>
<h3 id="Source-Connector"><a href="#Source-Connector" class="headerlink" title="Source Connector"></a>Source Connector</h3><p>Flink Kafka connector 以并行的方式读入事件流，每个并行的 source task 都可以从一个或多个 partition 读入数据。Task 对于每个它当前正在读的 partition 都会追踪当前的 offset ，并将这些 offset 数据存储到它的 checkpoint 中。当发生故障进行恢复时，offset 被取出并重置，使得数据可以在上次检查点时的 offset 继续读数据。<em>Flink Kafka connector 并不依赖于 Kafka 本身的 offset-tracking 机制（也就是consumer groups机制）。</em></p>
<p><img src="/pic/sources.png" alt="source"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设定配置</span></span><br><span class="line"><span class="type">val</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置消费者并添加源</span></span><br><span class="line">FlinkKafkaConsumer&lt;String&gt; myConsumer = <span class="keyword">new</span> <span class="title class_">FlinkKafkaConsumer</span>&lt;String&gt;(</span><br><span class="line">    <span class="string">&quot;topic&quot;</span>,                                 </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>(),                </span><br><span class="line">    properties))   </span><br><span class="line">);</span><br><span class="line">DataStream[String] stream = env.addSource(myConsumer);                    </span><br></pre></td></tr></table></figure>

<p><strong>初始化 FlinkKafkaConsumer 参数</strong></p>
<ol>
<li><strong>topic 名字</strong>，用来指定消费一个或者多个topic的数据，也可以是正则表达式。</li>
<li>**反序列化器(schema)**，对消费数据进行反序列化，转换成自定义的数据结构。</li>
<li><strong>kafka 配置信息</strong>：如 zk 地址端口，kafka 地址端口等。此对象至少要包含两个条目 <code>bootstrap.servers</code> 与 <code>group.id</code>。</li>
</ol>
<p>反序列化器主要通过实现 KeyedDeserializationSchema 或者 DeserializationSchema 接口来完成，flink 内置，也可以自定义。</p>
<ul>
<li>转化为 String 类型 <code>SimpleStringSchema</code></li>
<li>转化为其它类型 <code>TypeInformationSerializationSchema&lt;T&gt;</code></li>
<li>转化为键值对类型 <code>TypeInformationKeyValueSerializationSchema&lt;K, V&gt;</code></li>
<li>转化为 JSON 类型 <code>JSONKeyValueDeserializationSchema</code></li>
</ul>
<p><strong>消费起始位置</strong></p>
<p>Flink Kafka Consumer 可以配置指定的 Kafka Partition 的起始位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myConsumer.setStartFromEarliest()             <span class="comment">// start from the earliest record possible（默认）</span></span><br><span class="line">myConsumer.setStartFromLatest()               <span class="comment">// start from the latest record</span></span><br><span class="line">myConsumer.setStartFromTimestamp(...)         <span class="comment">// start from specified epoch timestamp (milliseconds)</span></span><br><span class="line">myConsumer.setStartFromGroupOffsets()         <span class="comment">// the default behaviour</span></span><br></pre></td></tr></table></figure>



<h3 id="Sink-Connector"><a href="#Sink-Connector" class="headerlink" title="Sink Connector"></a>Sink Connector</h3><p>Flink 提供为 Kafka 0.8 版本后所有 Kafka 版本的 sink connectors。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设定数据流</span></span><br><span class="line">DataStream[String] stream = environment.fromElements(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设置生产者并添加到 sink</span></span><br><span class="line">FlinkKafkaProducer&lt;String&gt; myProducer = <span class="keyword">new</span> <span class="title class_">FlinkKafkaProducer</span>&lt;String&gt;(</span><br><span class="line">  <span class="string">&quot;localhost:9092&quot;</span>,                            </span><br><span class="line">  <span class="string">&quot;topic&quot;</span>,                                     </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SimpleStringSchema</span>)                    </span><br><span class="line"> </span><br><span class="line">stream.addSink(myProducer)</span><br></pre></td></tr></table></figure>

<p><strong>初始化 FlinkKafkaProducer 参数</strong></p>
<ol>
<li><strong>broker 列表</strong>，要发往的 brokers , 用逗号分割。</li>
<li><strong>topic 名字</strong>，用来指定生产一个或者多个 topic 的数据，也可以是正则表达式。</li>
<li>**序列化器(schema)**，对消费数据进行序列化，将目标类型转换成字节数组。</li>
</ol>
<p>序列化器类比于反序列化器实现：</p>
<ul>
<li>转化为 String 类型 <code>SimpleStringSchema</code></li>
<li>转化为其它类型 <code>TypeInformationSerializationSchema&lt;T&gt;</code></li>
<li>转化为键值对类型 <code>TypeInformationKeyValueSerializationSchema&lt;K, V&gt;</code></li>
<li>转化为 JSON 类型 <code>JSONKeyValueDeserializationSchema</code></li>
</ul>
<h3 id="Kakfa-容错机制"><a href="#Kakfa-容错机制" class="headerlink" title="Kakfa 容错机制"></a>Kakfa 容错机制</h3><p>在 Kafka 0.9 之前不提供任何机制去保证 at-least-once 或 exactly-once 的语义。 但后续版本的 Kafka 可以通过以下方式来实现出错后恢复且不丢失数据：</p>
<ol>
<li><strong>启用 Checkpoint</strong></li>
</ol>
<p>在默认启用 Checkpoint 的状况下， FlinkKafkaConsumer 将消费来自 Topic 的记录，并以一致的方式周期性地 Checkpoint 其所有 Kafka Offset 以及其它操作的状态。万一作业失败，Flink 将把流失程序恢复到最新 Checkpoint的状态，并且重新消费 Kafka 中的数据。这确保了在 Kafka Broker 中所提交的 Offset 和 Checkpointed State 中的 Offset 是一致的。此时 FlinkKafkaProducer 可以提供 exactly-once 的投递语义。</p>
<p>如果 Checkpointing 没有启用，KafkaFlinkConsumer 将会周期性的提交 Offset 到 Zookeeper 中去。</p>
<ul>
<li><strong>配置 Semantic 参数</strong></li>
</ul>
<p>除了启用 Flink 的 Checkpointing，还可以通过传递恰当的 semantic 参数给 FlinkKafkaProducer 选择 3 种不同的操作模式:</p>
<ul>
<li><code>emantic.None</code> : Flink 什么也不会保证，所产生的记录可能会被丢失或者重复。</li>
<li><code>Semantic.AT_LEASET_ONCE</code>（默认）: Flink 保证 at-least-once ，没有记录会被丢失，但可能会重复。</li>
<li><code>Semantic.EXACTLY_ONCE</code> : 使用 Kafka 的事务机制来保证 exactly-once。</li>
</ul>
<p>Semantic.EXACTLY_ONCE 模式依赖于提交事务的能力，这些事务是在 taking a checkpoint 之前，从该 Checkpoint 恢复之后启动的。如果 Flink 应用崩溃且完成重启的时间比 Kafka 事务超时的时间大，则数据将会丢失（Kafka 将自动的终止超过超时时间的事务）。请务必根据预期的故障时间来配置你的事务超时。</p>
<h3 id="kafka-分区发现"><a href="#kafka-分区发现" class="headerlink" title="kafka 分区发现"></a>kafka 分区发现</h3><p>FlinkKafkaConsumer 支持发现动态创建的 Kafka Partition，并且以 exactly-once 语义保证来消费其中的数据。默认情况下分区发现是禁用的，要启用该特性在提供的属性配置中为参数 flink.partition-discovery.interval-millis 设置一个非负数的值，表示发现间隔（以毫秒为单位）。</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="消息系统之-Kafka"><a href="#消息系统之-Kafka" class="headerlink" title="消息系统之 Kafka"></a>消息系统之 Kafka</h1><hr>
<h2 id="什么是消息系统"><a href="#什么是消息系统" class="headerlink" title="什么是消息系统"></a>什么是消息系统</h2><p>消息系统是专用的中间件，负责将数据从一个应用传递到另外一个应用。使应用只需关注于数据，无需关注数据在两个或多个应用间是如何传递的。</p>
<p>消息系统一般基于可靠的消息队列来实现，使用点对点模式或发布订阅模式。数据实时在消息系统中传递，被看作流。</p>
<hr>
<h2 id="为什么使用消息系统"><a href="#为什么使用消息系统" class="headerlink" title="为什么使用消息系统"></a>为什么使用消息系统</h2><p>使用消息系统具有以下优势：</p>
<ol>
<li><strong>解耦</strong>：发送方和接收方统一使用消息系统提供的接口进行通信，易修改易扩展。</li>
<li><strong>持久化</strong>：传递过程中消息存储到本地磁盘，防止处理数据失败导致数据丢失。</li>
<li><strong>均衡负载</strong>：分布式系统能根据负载灵活调整机器数量，能够处理高吞吐量和流量突增的情况。</li>
</ol>
<p>除此之外，消息系统还可以保障：</p>
<ol start="4">
<li><strong>保障有序</strong>：数据处理的顺序不被打乱。</li>
<li><strong>传递加速</strong>：通过缓冲层控制和优化数据流经过系统的速度。</li>
<li><strong>延时处理</strong>：提供了异步处理机制，允许用户把消息放入队列，但并不立即处理它。</li>
</ol>
<hr>
<h2 id="什么是-Kafka"><a href="#什么是-Kafka" class="headerlink" title="什么是 Kafka"></a>什么是 Kafka</h2><p>Kafka 作为当前最常用的消息系统之一，一般用于日志收集的离线系统。采用发布订阅模式，由通过高性能 TCP 网络协议进行通信的服务器和客户端组成。</p>
<p>Kafka 使用 scala 开发，由 LinkedIn 开源，目前已捐献给 Apache 基金会。</p>
<blockquote>
<p>Kafka 官网 <a href="http://kafka.apache.org/">http://Kafka.apache.org/</a></p>
</blockquote>
<hr>
<h2 id="Kafka-的优劣势"><a href="#Kafka-的优劣势" class="headerlink" title="Kafka 的优劣势"></a>Kafka 的优劣势</h2><p><strong>优势</strong></p>
<ol>
<li>快速持久化，可以在O(1)的系统开销下进行消息持久化；</li>
<li>IO 吞吐量高，使用 partition 把队列流量均匀分散在多台机器上，单台服务器可以达到 10W/s 的吞吐速率。</li>
</ol>
<p><strong>劣势</strong></p>
<ol>
<li>不进行消息重复性检查，可能导致消费重复数据或者异常情况下的数据丢失。</li>
<li>实时性方面也存在少量延迟。</li>
</ol>
<hr>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者/消费者模式"></a>生产者/消费者模式</h2><p>Kafka 是一个分布式系统，由服务器和客户端组成，之间通过高性能 TCP 网络协议进行通信。</p>
<ol>
<li><p>服务器以 <code>Cluster</code> 为单位向外提供服务，由多个 <code>Broker</code> 组成。Broker 作为 Kafka 的服务节点，接收外部生产的数据，在本地磁盘对数据进行备份，并提供数据给指定的接收者。</p>
</li>
<li><p>客户端分为以下两种类型：</p>
<ul>
<li><code>Producer</code>: 数据生产者，向 Kafka 集群生产数据。</li>
<li><code>Consumer</code>：数据消费者，读取 Kafka 集群生产者生产的消息。</li>
</ul>
</li>
<li><p>组件之间通过 <code>Zookeeper</code> 进行协调。ZooKeeper 会保存 Broker 和 Consumer 的元数据信息，并进行数据变更的监控。并负责选举出 Cluster 内的 Controller （其中一个 Broker），管理 Zookeeper 上的元数据信息。</p>
</li>
</ol>
<hr>
<h2 id="数据分片模型"><a href="#数据分片模型" class="headerlink" title="数据分片模型"></a>数据分片模型</h2><p>Kafka 消息按照 <code>Topic</code> 进行数据的组织和隔离，Producer/Consumer 会向指定的 Topic 收发数据。</p>
<p>在服务器端，Topic 则按 <code>Patition</code> 进行分区，同一个 Topic 的 Partition 会散落在多个 Broker 上，存储为一个阻塞队列，从而达到了数据分布式存储的目的。Producer 可以指定发送的 Partition 以保证消息有序到达。</p>
<p><img src="/pic/Kafka.jpeg" alt="Kafka"></p>
<p>每个 <code>Consumer Group</code> 都会消费一个 Topic 全量的数据，彼此之间互不干扰。同一个 Consumer Group 下的 Consumer 只能消费到其中一部分 Partition ，通过多个 Consumer 可以达到并行消费的目的。Partition 数量推荐设为 Consumer 数量的整数倍，便于均分。</p>
<p><img src="/pic/group.jpeg" alt="group"></p>
<hr>
<h2 id="多副本模型"><a href="#多副本模型" class="headerlink" title="多副本模型"></a>多副本模型</h2><p>为了提高可用性，避免 Broker 损坏导致的 Partition 不可用或者丢失问题，Kafka 会对每个 Partition 提供多个副本（默认为 3 个），其中有且仅有一个作为 <code>Leader</code>，负责数据的读写。其他副本 <code>Follower</code> 将存放在不同的 Broker 上，通过接收 Leader 广播将数据同步到本地。</p>
<p>每个 Leader Partition 维护一个独立的 <code>ISR</code> 列表，记录当前同步的 Follower 集合：</p>
<ol>
<li>如果 Follower 不能及时同步（延迟时间高或延迟条数超过阈值）就会被暂时踢出 ISR 。</li>
<li>如果 Leader 不可用将从 ISR 中选出一个 Follower 担任 Leader 。</li>
</ol>
<hr>
<h2 id="消息定位"><a href="#消息定位" class="headerlink" title="消息定位"></a>消息定位</h2><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><p>kafka 用 <code>Offset</code> 表示 Message 在 Partition 中的偏移量，通过 Offset 可以唯一确定 Partition 中的一条 Message 。</p>
<ol>
<li><strong>生产者 Offset (current position)</strong></li>
</ol>
<p>每个 Partition 只有一个，表示当前消息生产到的位置。</p>
<ol start="2">
<li><strong>消费者 Offset (committed offset)</strong> </li>
</ol>
<p>每个 Partition 可以有多个，取决于消费的 ConsumeGroup 数量。消费者 Offset 会记录到 Kafka 自带 Topic(__consumer_offsets) 内，表示当前消费到的位置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Group</td>
<td>消费者组</td>
</tr>
<tr>
<td>Topic</td>
<td>topic 名称</td>
</tr>
<tr>
<td>Pid</td>
<td>partition ID</td>
</tr>
<tr>
<td>Offset</td>
<td>消费者在对应分区上已消费消息数</td>
</tr>
<tr>
<td>logSize</td>
<td>已经写到该分区的消息数</td>
</tr>
<tr>
<td>Lag</td>
<td>还有多少消息未读取（Lag = logSize - Offset）</td>
</tr>
<tr>
<td>Owner</td>
<td>分区所属 broker</td>
</tr>
</tbody></table>
<hr>
<h2 id="搭建-Broker"><a href="#搭建-Broker" class="headerlink" title="搭建 Broker"></a>搭建 Broker</h2><p>在服务器搭建 Broker ，需要通过指令来完成。本文所有的操作都是在MacOS系统上使用。如果是在Linux操作系统下进行实验，使用的命令是相同的；如果是在windows操作系统下进行实验，则需要使用对应的bin/windows目录下的bat文件。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最大offset</span></span><br><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic test_topic --time -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小offset</span></span><br><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic test_topic --time -2</span><br><span class="line"></span><br><span class="line"><span class="comment"># offset</span></span><br><span class="line">bin/kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic test_topic</span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前 kafka 所有的 topic</span></span><br><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 topic</span></span><br><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --topic test_topic --replication-factor 1 --partitions 1 </span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --topic test_topic --replication-factor 3 --partitions 10 --config cleanup.policy=compact</span><br><span class="line"></span><br><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181  --topic test_topic --partitions 1   --replication-factor 1 --config max.message.bytes=64000 --config flush.messages=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某 topic 具体情况</span></span><br><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --describe --topic test_topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 topic （分区数、特殊配置如compact属性、数据保留时间等）</span></span><br><span class="line">bin/kafka-topics.sh --zookeeper localhost:2181 --alter --partitions 3  --config cleanup.policy=compact --topic test_topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 topic （也可以用这种）</span></span><br><span class="line">bin/kafka-configs.sh --alter --zookeeper localhost:2181 --entity-name test_topic --entity-type topics --add-config cleanup.policy=compact</span><br><span class="line"> </span><br><span class="line">bin/kafka-configs.sh --alter --zookeeper localhost:2181 --entity-name test_topic --entity-type topics --delete-config cleanup.policy</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JAVA-生产信息"><a href="#JAVA-生产信息" class="headerlink" title="JAVA 生产信息"></a>JAVA 生产信息</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入 0.10.2 版本 Kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.Kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置生产者"><a href="#配置生产者" class="headerlink" title="配置生产者"></a>配置生产者</h3><p>在创建 Producer 对象前，必须配置以下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>bootstrap.servers</code></td>
<td>Kafka broker 地址</td>
<td>如果有多个地址用逗号分割</td>
</tr>
<tr>
<td><code>key.serializer</code></td>
<td>key 的序列化类</td>
<td>必须实现 Kafka 的 Serializer 接口</td>
</tr>
<tr>
<td><code>value.serializer</code></td>
<td>value 的序列化类</td>
<td>必须实现 Kafka 的 Serializer 接口</td>
</tr>
</tbody></table>
<p>开发者还可以选择配置如下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>request.required.acks</code></td>
<td>指定消息系统何时向生产者返回 ACK ： <code>0</code> 不需要、 <code>1</code> 主服务器收到后、 <code>-1</code> 所有服务器收到后。</td>
<td>选择不接收 ACK 时生产者能以最大速度发送消息，但如果 broker 没有收到消息，生产者将无感知。</td>
</tr>
<tr>
<td><code>producer.type</code></td>
<td>同步发送消息 <code>sync</code> 或异步发送消息 <code>async</code> 。</td>
<td>异步发送消息会被服务器暂存在一个阻塞队列中，被消费者拉取时再由线程取出并组装。</td>
</tr>
</tbody></table>
<p>通过读取配置，即可生成 Producer 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">KafkaProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">KafkaProps.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;broker1:port1, broker2:port2&quot;</span>);</span><br><span class="line">KafkaProps.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.Kafka.common.StringSerializer&quot;</span>);</span><br><span class="line">KafkaProps.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.Kafka.common.StringSerializer&quot;</span>);</span><br><span class="line">producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;String, String&gt;(KafkaProps);</span><br></pre></td></tr></table></figure>

<h3 id="构造消息"><a href="#构造消息" class="headerlink" title="构造消息"></a>构造消息</h3><p>实例化 ProducerRecord 类得到消息对象。</p>
<p>创建时必须指定消息所属 Topic 和消息值 Value 。消息发往哪个 Partition 通常由负载均衡机制随机选择。若指定了 Partition 则发送到指定的 Partition，如果没有指定 Partition 但指定了 Key，则由 hasy(key) 决定。</p>
<p>由于 Kafka 只能保证 Partition 内消息的有序性，如果需要保证消息有序到达，Producer 必须指定消息到达的 Partition ，这些消息最终只能被 ConsumeGroup 内的一个 Consumer 消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种构造方法</span></span><br><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, value);</span><br><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, key, value);</span><br><span class="line">ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;&gt;(topic, partition, key, value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给消息系统</span></span><br><span class="line">producer.send(record);</span><br></pre></td></tr></table></figure>


<h3 id="接收-ACK"><a href="#接收-ACK" class="headerlink" title="接收 ACK"></a>接收 ACK</h3><p>发送消息后，生产者有两种方式接收消息系统返回的 ACK :</p>
<ol>
<li>通过返回的 Future 判断已经发送成功，get 方法会阻塞线程。实现同步等待。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> producer.send(record); </span><br><span class="line">    future.get(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="2">
<li>发送消息时传递一个回调对象，实现 Kafka 的 Callback 接口，通过回调判断是否发送成功。实现异步等待。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.send(record, <span class="keyword">new</span> <span class="title class_">ProducerCallback</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ProducerCallback</span> <span class="keyword">implements</span> <span class="title class_">Callback</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCompletion</span><span class="params">(RecordMetadata recordMetadata, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>)  e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h3 id="生产示例"><a href="#生产示例" class="headerlink" title="生产示例"></a>生产示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.common.serialization.StringSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        p.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.23.76:9092,192.168.23.77:9092&quot;</span>);          </span><br><span class="line">        p.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);       </span><br><span class="line">        p.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);    </span><br><span class="line">        p.put(<span class="string">&quot;request.required.acks&quot;</span>, <span class="string">&quot;-1&quot;</span>);                        </span><br><span class="line">        p.put(<span class="string">&quot;producer.type&quot;</span>, <span class="string">&quot;async&quot;</span>);         </span><br><span class="line"></span><br><span class="line">        KafkaProducer&lt;String, String&gt; KafkaProducer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello,&quot;</span> + i;</span><br><span class="line">                ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> <span class="title class_">ProducerRecord</span>&lt;String, String&gt;(topic, msg);   </span><br><span class="line">                KafkaProducer.send(record);                                  </span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            KafkaProducer.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="JAVA-消费消息"><a href="#JAVA-消费消息" class="headerlink" title="JAVA 消费消息"></a>JAVA 消费消息</h2><h3 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入 0.10.2 版本 Kafka --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.Kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.10.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="配置消费者"><a href="#配置消费者" class="headerlink" title="配置消费者"></a>配置消费者</h3><p>在创建 Consumer 对象前，必须配置以下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>bootstrap.servers</code></td>
<td>Kafka broker 地址</td>
<td>如果有多个地址用逗号分割</td>
</tr>
<tr>
<td><code>group.id</code></td>
<td>所属消费组</td>
<td></td>
</tr>
<tr>
<td><code>key.deserializer</code></td>
<td>key 的反序列化类</td>
<td>必须实现 Kafka 的 Serializer 接口</td>
</tr>
<tr>
<td><code>value.deserializer</code></td>
<td>value 的反序列化类</td>
<td>必须实现 Kafka 的 Serializer 接口</td>
</tr>
</tbody></table>
<p>开发者还可以选择配置如下属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>fetch.max.bytes</code></td>
<td>consumer 端一次拉取数据的最大字节数</td>
<td></td>
</tr>
<tr>
<td><code>fetch.min.bytes</code></td>
<td>consumer 端一次拉取数据的最大字节数，默认为 1B。</td>
<td></td>
</tr>
<tr>
<td><code>max.poll.records</code></td>
<td>consumer 端一次拉取数据的最大条数，默认为 500。</td>
<td></td>
</tr>
<tr>
<td><code>fetch.max.wait.ms</code></td>
<td>服务器最大等待时间，默认为 500ms。超过时间后返回所有可用数据。</td>
<td></td>
</tr>
</tbody></table>
<p>通过读取配置，即可生成 Consumer 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">kafkaProps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">kafkaProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.23.76:9092&quot;</span>);                           </span><br><span class="line">kafkaProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);                 </span><br><span class="line">kafkaProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);                     </span><br><span class="line">kafkaProps.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;duanjt_test&quot;</span>);                                           </span><br><span class="line">KafkaConsumer&lt;String, String&gt; KafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(kafkaProps);</span><br></pre></td></tr></table></figure>


<h3 id="订阅消息"><a href="#订阅消息" class="headerlink" title="订阅消息"></a>订阅消息</h3><p>消费者可以通过以下两种方式订阅 Topic：</p>
<ol>
<li>subscribe 方法：动态调整组内各个消费者与分区的关系，实现负载均衡。</li>
<li>assign 方法：订阅确定的主题和分区。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">consumer.subscribe(Collections.singletonList(Producer.topic));</span><br><span class="line">consumer.assign(Collections.singletonList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(partitionInfo.topic(), partitionInfo.partition())));</span><br><span class="line"><span class="comment">// 解除订阅</span></span><br><span class="line">consumer.unsubscribe();</span><br></pre></td></tr></table></figure>


<h3 id="拉取消息"><a href="#拉取消息" class="headerlink" title="拉取消息"></a>拉取消息</h3><p>Kafka Consumer 采用主动拉取消息系统数据 poll 的方式进行消费，可以对服务器的数据进行延迟处理。以防止消息系统向 Consumer 推送数据过多，导致 Consumer 积压而不堪重负的情况。为避免在服务器无数据的时候一直轮询， Kafka 在 poll 方法有参数允许消费者请求在长轮询中阻塞，等待数据到达。</p>
<p>获取到消息组 ConsumerRecords 后，内部包含多个 ConsumerRecord 对象，记录消息的 topic/partition/offset/key/value 信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每隔 1s 拉取一次数据</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = KafkaConsumer.poll(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 打印数据</span></span><br><span class="line">records.foreach(record -&gt; &#123;</span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;topic:%s,offset:%d,消息:%s&quot;</span>, record.topic(), record.offset(), record.value()));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="提交-Offset"><a href="#提交-Offset" class="headerlink" title="提交 Offset"></a>提交 Offset</h3><p>对于消费者而言，异步模式下 committed offset 是落后于 current position 的。如果 consumer 挂掉，那么下一次消费数据又只会从 committed offset 的位置拉取数据，就会导致数据被重复消费。</p>
<p>消费者 offset 更新有以下两种方式：</p>
<ol>
<li><strong>自动提交 at-most-once</strong></li>
</ol>
<p>设置 enable.auto.commit=true（默认），更新的频率根据参数 auto.commit.interval.ms 来定，定时系统会根据当时 Consumer 收到的消息数量自动更新 offset 。</p>
<p>这可能导致两个问题：</p>
<ol>
<li><p>Consumer 程序崩溃，而 Offset 尚未更新。会重复消费部分数据。</p>
</li>
<li><p>Consumer 程序崩溃，但 Offset 已被更新。已收到但未消费的数据永久丢失。</p>
</li>
<li><p><strong>手动提交 at-least-once</strong></p>
</li>
</ol>
<p>设置 enable.auto.commit=false，Consumer 收到消息并消费后，再调用方法 consumer.commitSync() 手动更新 offset 。</p>
<p>如果消费失败，则 offset 也不会更新，此条消息会被重复消费。</p>
<h3 id="消费示例"><a href="#消费示例" class="headerlink" title="消费示例"></a>消费示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.Kafka.common.serialization.StringDeserializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        p.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">&quot;192.168.23.76:9092&quot;</span>);                           </span><br><span class="line">        p.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);                 </span><br><span class="line">        p.put(ConsumerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringDeserializer.class);                     </span><br><span class="line">        p.put(ConsumerConfig.GROUP_ID_CONFIG, <span class="string">&quot;duanjt_test&quot;</span>);                                           </span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; KafkaConsumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;String, String&gt;(p);</span><br><span class="line">        KafkaConsumer.subscribe(Collections.singletonList(<span class="string">&quot;test&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = KafkaConsumer.poll(<span class="number">100</span>);</span><br><span class="line">            records.foreach(record -&gt; &#123;</span><br><span class="line">                System.out.println(String.format(<span class="string">&quot;topic:%s,offset:%d,消息:%s&quot;</span>, record.topic(), record.offset(), record.value()));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>美团技术博客：<a href="https://blog.csdn.net/lizhitao/article/details/39499283">https://blog.csdn.net/lizhitao/article/details/39499283</a></p>
<p>常用指令一：<a href="https://www.cnblogs.com/itwild/p/12287850.html">https://www.cnblogs.com/itwild/p/12287850.html</a></p>
<p>常用指令二：<a href="https://blog.csdn.net/camel84/article/details/81879118">https://blog.csdn.net/camel84/article/details/81879118</a></p>
]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="分布式概念"><a href="#分布式概念" class="headerlink" title="分布式概念"></a>分布式概念</h1><p><a href="https://www.zhihu.com/question/65502802">https://www.zhihu.com/question/65502802</a></p>
<hr>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="垂直架构"><a href="#垂直架构" class="headerlink" title="垂直架构"></a>垂直架构</h3><p>所有功能模块在一个项目中编写，并集中部署。</p>
<ul>
<li>优点：实现简单。</li>
<li>缺点：项目耦合度高，牵一发而动全身，不利于团队开发，也不利于后期升级和维护。</li>
</ul>
<h3 id="SOA-amp-微服务架构"><a href="#SOA-amp-微服务架构" class="headerlink" title="SOA &amp; 微服务架构"></a>SOA &amp; 微服务架构</h3><p>**SOA(Service-Oriented Architecture) **</p>
<p>将应用程序不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。</p>
<p>SOA（面向服务架构）是一种思想，采用粗粒度、松耦合的服务架构，服务之间通过简单、精确定义的接口进行通讯，不涉及底层编程接口和通讯模型。</p>
<p><strong>微服务</strong></p>
<p>SOA 发展出来的产物。将应用程序分为更细粒度的服务，并分布式部署。使各个服务之间可独立维护。</p>
<ul>
<li>优点：SOA/微服务的引入，这使得整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。</li>
<li>缺点：但整个应用分散成多个服务使得整个系统变得更为复杂，也使得部署、管理、排障的工作量显著加大。</li>
</ul>
<h3 id="RPC-remote-procedure-call"><a href="#RPC-remote-procedure-call" class="headerlink" title="RPC(remote procedure call)"></a>RPC(remote procedure call)</h3><p>整个应用分散成多个服务使得整个系统变得更为复杂。我们需要在分布式开发中引入额外的技术，以解决服务之间交互和分布式部署导致的问题。</p>
<p>RPC（远程过程调用），即在本地调用远程机器的函数或者对象方法，使实际的体验和调用本地函数或者对象方法无异。</p>
<p>RPC 也是一种技术思想，HTTP 和 WebService 就是 RPC 思想的一种很好的体现方式，但 HTTP 已经满足不了企业内外部日益复杂的信息交互。因此许多优秀的 RPC 框架应运而生，比如著名的 Dubbo ，封装了一些像负载均衡、熔断降级、服务注册发现等面向对象的高级特性。</p>
<hr>
<h2 id="引入技术"><a href="#引入技术" class="headerlink" title="引入技术"></a>引入技术</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>使用专用的中间件在网络中传输数据。通常由专用的机器集群来实现，从发送方接收数据，再将数据转发给相应的接收方。</p>
<p>使用消息系统具有以下优势：</p>
<ol>
<li>将发送方和接收方解耦，统一使用消息系统提供的接口进行通信，易修改易扩展。</li>
<li>能够持久化保存数据，防止处理数据失败导致数据丢失。</li>
<li>分布式系统能够均衡负载，且能根据负载灵活调整机器数量，能够处理高吞吐量和流量突增的情况。</li>
</ol>
<p>目前主流的消息队列有 kafka、RocketMQ 等等。</p>
<h3 id="故障监控追踪"><a href="#故障监控追踪" class="headerlink" title="故障监控追踪"></a>故障监控追踪</h3><p>在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p>
<ol>
<li><p><strong>监控</strong>：微服务架构中组件繁多，各个组件所需要监控的指标不同。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</p>
</li>
<li><p><strong>追踪</strong>：在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。</p>
</li>
</ol>
<h3 id="日志检索分析"><a href="#日志检索分析" class="headerlink" title="日志检索分析"></a>日志检索分析</h3><p>当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。</p>
<p>在业界通常会使用大名鼎鼎的 ELK 日志分析组件：</p>
<ul>
<li>Elasticsearch：搜索引擎，同时也是日志的存储。</li>
<li>Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。</li>
<li>Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。</li>
</ul>
<h3 id="权限校验控制"><a href="#权限校验控制" class="headerlink" title="权限校验控制"></a>权限校验控制</h3><p>微服务架构中项目会出现大量的服务和接口，使得整个调用关系异常复杂。</p>
<p>网关负责把关微服务的调用。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。</p>
<p>一般的微服务架构里都有两层 API GetWay：</p>
<ol>
<li>外部 API GetWay，用于用户访问系统；</li>
<li>内部 API GetWay，解决的问题就是服务发现和服务注册。因此通信的方式要尽量单一，API GetWay 有一项工作就是协议转换。</li>
</ol>
<h3 id="服务注册发现"><a href="#服务注册发现" class="headerlink" title="服务注册发现"></a>服务注册发现</h3><p>在实际开发中我们往往需要根据业务需求的变化，动态地调整机器数量，以便能够提高性能和容错。</p>
<p>由于服务的地址可能会频繁地动态变化，在调用服务时就需要使用统一的注册中心来查找服务的地址信息：</p>
<ol>
<li>各个应用服务在启动时/定时将自动将自己注册到注册中心。</li>
<li>注册中心也会定期检查应用服务的健康状态，去掉不健康的实例地址。</li>
</ol>
<p>Apache ZooKeeper(ZK) 是一个广泛使用，为分布式应用提供高性能整合的服务。</p>
<h3 id="熔断-服务降级-限流"><a href="#熔断-服务降级-限流" class="headerlink" title="熔断/服务降级/限流"></a>熔断/服务降级/限流</h3><p>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p>
<p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p>
<p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列2</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%972/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Rocket-MQ"><a href="#Rocket-MQ" class="headerlink" title="Rocket MQ"></a>Rocket MQ</h1><p><a href="https://www.jianshu.com/p/0b4b1147366f">https://www.jianshu.com/p/0b4b1147366f</a></p>
<hr>
<h2 id="Rocket-MQ-1"><a href="#Rocket-MQ-1" class="headerlink" title="Rocket MQ"></a>Rocket MQ</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>阿里使用 Java 开发的开源消息中间件。被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。</p>
<ul>
<li><p><strong>优势</strong>：集群和 HA 实现都很简单。在保持一定的吞吐情况下，在发生宕机和其它故障时消息丢失率更低。因为无论是同步还是异步发送，生产者都会收到实时响应。适合处理高可靠性的数据。</p>
</li>
<li><p><strong>劣势</strong>：跟 kafka 相比吞吐率稍低。</p>
</li>
</ul>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="/pic/rmqa.png" alt="rmqa"></p>
<ul>
<li><p><code>Producer</code>: 数据生产者，向 RMQ 集群生产数据。</p>
</li>
<li><p><code>Consumer</code>：数据消费者，连接 Broker 读取生产者生产的消息。</p>
</li>
<li><p><code>Broker</code>: Kafka 的服务节点，负责接收 Producer 生产的数据，在本地磁盘对数据进行备份，并提供数据给 Consumer。为最大化吞吐量 Broker 往往只起到中转和存储的作用而不处理业务逻辑。</p>
</li>
<li><p><code>NameServer</code>: 所有机器定时向 NameServer 上报自己的状态（超时未发送被剔除），NameServer 内部通过 5 个 HashMap 保存全局信息，提供给其它机器查询。NameServer 可以部署多个，相互独立。机器需同时向多个 NameServer 上报状态信息，从而达到热备份的目的。因为结构简单，无需使用专门的 zookeeper 注册中心来提供协调服务。</p>
</li>
</ul>
<h3 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h3><p><img src="/pic/consumeModel.png" alt="rmqa"></p>
<p>RocketMQ 消息按照 <code>Topic</code> 和 <code>Tag</code> (可选)进行二级数据的组织和隔离，Producer/Consumer 会向指定的 Topic 甚至 Tag 收发数据。</p>
<p>Topic 可拥有若干个 <code>Queue</code> ，散落在不同的 Broker 上，从而达到了数据分布式存储的目的，具有水平扩展的能力。</p>
<p>消息均使用 message ID 唯一识别。 Rocket MQ 不对消息的格式做限制，消息 body 是二进制，需要用户完成序列化操作。用户在发送时可以设置 messageKey ，便于之后查询和跟踪。</p>
<p>在 RMQ 中消息的生产/消费均通过 Group （组）来完成，用来标记同一类生产/消费者，一般是集群部署。一个 Group 内可包含多个 Client （客户端）。</p>
<p>每个 <code>Consumer Group</code> 都会消费一个 Topic 全量的数据，彼此之间互不干扰。同一个 Consumer Group 下的 Consumer 只能消费到其中一部分 Partition ，通过多个 Consumer 可以达到并行消费的目的。Partition 数量推荐设为 Consumer 数量的整数倍，便于均分。</p>
<p><em>Consumer 获取消息后，只有在消息消费完成时才会向服务器返回 ack 。如果没有消费完成，则一定不会 ack 消息。</em></p>
<h3 id="多副本模式"><a href="#多副本模式" class="headerlink" title="多副本模式"></a>多副本模式</h3><p><img src="/pic/dleger.png" alt="rmqa"></p>
<p>RMQ 采用多副本模式，将集群分为多个 <code>dleger-group</code> ，每个 group 由 3 台或以上 broker 组成。默认使用同步复制同步刷盘，master 要将消息同步到 slave 才会返回成功，保证 master-slave 的 commitlog 一致性。</p>
<p>定时线程会检测各 broker 状态，当前 master 挂掉后，会触发自动选主保证集群的读写能力不受影响。选主基于 raft 协议，默认会选择 offset 较大的 slave 为主节点，防止消息丢失。</p>
<p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的Broker Name，不同的Broker Id来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。</p>
<p>每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)注册Topic信息到所有Name Server。Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接。</p>
<h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生产/消费客户端导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><h3 id="生产架构"><a href="#生产架构" class="headerlink" title="生产架构"></a>生产架构</h3><p>在 RMQ 中消息的生产通过 ProduceGroup （生产组）完成。用来标记同一类生产者，一般是集群部署。</p>
<p>一个 ProduceGroup 内可包含多个 Client （客户端）。这是一个逻辑上的概念，使用唯一标识 ClientID （ClientIP + InstanceName）来相互区分，默认为 IP 地址 + 端口号。</p>
<p>用户创建的 Producer 类，如果 ClientID 相同将被视为同一个 Client ，在 Broker 上共用一个内部实例处理。</p>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>在 DefaultMQProducer 类内，提供了以下参数给配置。</p>
<ol>
<li>继承 ClientConfig 类，和 Consumer 类互用。</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>String namesrvAddr</td>
<td>nameServer 地址列表</td>
<td>无</td>
<td>必填</td>
</tr>
<tr>
<td>String clientIP</td>
<td>Client IP</td>
<td>本机 IP</td>
<td></td>
</tr>
<tr>
<td>String instanceName</td>
<td>client 名称</td>
<td>当前进程号</td>
<td></td>
</tr>
<tr>
<td>int clientCallbackExecutorThreads</td>
<td>客户端收到请求处理线程数</td>
<td>CPU 核数</td>
<td>没什么用</td>
</tr>
<tr>
<td>int pollNameServerInterval</td>
<td>轮询 nameServer 时间</td>
<td>30000(ms)</td>
<td></td>
</tr>
<tr>
<td>int heartbeatBrokerInterval</td>
<td>向 broker 发送心跳时间</td>
<td>30000(ms)</td>
<td></td>
</tr>
<tr>
<td>int persistConsumerOffsetInterval</td>
<td>持久化消费进度间隔时间</td>
<td>5000(ms)</td>
<td></td>
</tr>
<tr>
<td>String groupName</td>
<td>组名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>String token</td>
<td>broker 认证 Client 身份</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>DefaultMQProducer 类独有</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>String producerGroup</td>
<td>生产组名</td>
<td></td>
<td>只在事务消息中有用</td>
</tr>
<tr>
<td>String createTopicKey</td>
<td>如果未找到 topic 需要自动创建，所用 topic key</td>
<td>“TBW102”</td>
<td>没什么用</td>
</tr>
<tr>
<td>int defaultTopicQueueNums</td>
<td>如果未找到 topic 需要自动创建，默认 queue 数量</td>
<td>4</td>
<td>没什么用</td>
</tr>
<tr>
<td>int sendMsgTimeout</td>
<td>发送超时时间，超出后抛出异常</td>
<td>3000(ms)</td>
<td></td>
</tr>
<tr>
<td>int compressMsgBodyOverHowmuch</td>
<td>超出大小对消息压缩</td>
<td>4096(B)</td>
<td></td>
</tr>
<tr>
<td>int retryTimesWhenSendFailed</td>
<td>普通消息重试次数</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>int retryTimesWhenSendAsyncFailed</td>
<td>异步消息重试次数</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>boolean retryAnotherBrokerWhenNotStoreOK</td>
<td>结果不是 SEND_OK 是否当作失败重发</td>
<td>false</td>
<td></td>
</tr>
<tr>
<td>int maxMessageSize</td>
<td>最大消息尺寸</td>
<td>4194304(128K)</td>
<td></td>
</tr>
</tbody></table>
<h3 id="生产方式"><a href="#生产方式" class="headerlink" title="生产方式"></a>生产方式</h3><p>生产者生产消息通常分为同步发送、异步发送、单向发送三种方式：</p>
<ol>
<li><strong>同步生产 SYNC</strong></li>
</ol>
<p>可靠性最强，但性能最低的发送方式。应用在发送消息后将等待返回值，再进行之后的处理。</p>
<p>常用于重要通知邮件、报名短信通知、营销短信系统等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaProducerExampleRMQ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定生产者</span></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;produceGroupName&quot;</span>);               <span class="comment">// 设定生产组名</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;nameServer_1:9876;nameServer_2:9876&quot;</span>);                       <span class="comment">// 设定 NameServer 地址</span></span><br><span class="line">        producer.setToken(<span class="string">&quot;token&quot;</span>);                                                           <span class="comment">// 设定 Token</span></span><br><span class="line">        producer.start(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息设定</span></span><br><span class="line">        List&lt;Message&gt; messageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic&quot;</span> ,                                               <span class="comment">// 设定 Topic </span></span><br><span class="line">                    <span class="string">&quot;tag&quot;</span>,                                                                    <span class="comment">// 设定 Tag（可选）</span></span><br><span class="line">                    <span class="string">&quot;ORDER-20170101-XXX&quot;</span>,                                                               <span class="comment">// 设定 Key ，用于消息查询（可选）</span></span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(<span class="string">&quot;UTF-8&quot;</span>)                                 <span class="comment">// 设定 Message body </span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 可以设定消息延迟发送，如超时未支付关闭订单</span></span><br><span class="line">            <span class="comment">// Level 从 1 - 18 依次为 1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br><span class="line">            message.setDelayTimeLevel(<span class="number">2</span>);                   </span><br><span class="line">            messageList.add(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息并接收结果</span></span><br><span class="line">        <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(messageList);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>异步生产 ASYNC</strong></li>
</ol>
<p>如果希望获取更好的性能，可以通过异步实现高并发。应用将不再等待返回值，而是通过回调触发相对应的业务。异步生产一旦发送失败，将不支持重试。且不保证消息发送严格有序。</p>
<p>可用于注册成功后通知积分系统发放优惠券。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncProducer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producerGroupName&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;nameServer:9876&quot;</span>);</span><br><span class="line">        producer.setToken(<span class="string">&quot;token&quot;</span>); </span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic&quot;</span></span><br><span class="line">            <span class="string">&quot;tag&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ORDER-20170101-XXX&quot;</span>, </span><br><span class="line">            (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步生产，发送但没有返回值，需要在回调函数上做业务处理</span></span><br><span class="line">        producer.send(msg, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                System.out.printf(sendResult.getMsgId());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="3">
<li><strong>一次发送 ONEWAY</strong></li>
</ol>
<p>如果对于性能十分敏感，且不需要消息回复。可以发送单向消息而不返回任何结果，不能保障可靠性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnewayProducer</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;producerGroupName&quot;</span>);</span><br><span class="line">       producer.setNamesrvAddr(<span class="string">&quot;nameServer:9876&quot;</span>);</span><br><span class="line">       producer.start();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;tag&quot;</span>, (<span class="string">&quot;rocketMQ&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">           <span class="comment">// 发送单向消息，没有返回值</span></span><br><span class="line">           producer.sendOneway(msg);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       producer.shutdown();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费架构"><a href="#消费架构" class="headerlink" title="消费架构"></a>消费架构</h3><p>在 RMQ 中消息的消费通过 ConsumeGroup （消费组）完成。Broker 要求同组的 Consumer 参数设置必须要一致，要不然会造成数据混乱。</p>
<p>一个 ConsumeGroup 内可包含多个 Client （客户端）。这是一个逻辑上的概念，使用唯一标识 ClientID （ClientIP + InstanceName）来相互区分，默认为 IP 地址 + 端口号。</p>
<p>用户创建的 Consumer 类，如果 ClientID 相同将视为同一个 Client ，在 Broker 上共用一个内部实例。</p>
<h3 id="参数配置-1"><a href="#参数配置-1" class="headerlink" title="参数配置"></a>参数配置</h3><p>在 DefaultMQPushConsumer 类内，提供了以下参数给配置。</p>
<ol>
<li>继承 ClientConfig 类，和 Consumer 类互用。</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>String namesrvAddr</td>
<td>nameServer 地址列表</td>
<td>无</td>
<td>必填</td>
</tr>
<tr>
<td>String clientIP</td>
<td>Client IP</td>
<td>本机 IP</td>
<td></td>
</tr>
<tr>
<td>String instanceName</td>
<td>client 名称</td>
<td>当前进程号</td>
<td></td>
</tr>
<tr>
<td>int clientCallbackExecutorThreads</td>
<td>客户端收到请求处理线程数</td>
<td>CPU 核数</td>
<td>没什么用</td>
</tr>
<tr>
<td>int pollNameServerInterval</td>
<td>轮询 nameServer 时间</td>
<td>30000(ms)</td>
<td></td>
</tr>
<tr>
<td>int heartbeatBrokerInterval</td>
<td>向 broker 发送心跳时间</td>
<td>30000(ms)</td>
<td></td>
</tr>
<tr>
<td>int persistConsumerOffsetInterval</td>
<td>持久化消费进度间隔时间</td>
<td>5000(ms)</td>
<td></td>
</tr>
<tr>
<td>String groupName</td>
<td>组名</td>
<td></td>
<td></td>
</tr>
<tr>
<td>String token</td>
<td>broker 认证 Client 身份</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ol start="2">
<li>DefaultMQPushConsumer 类独有</li>
</ol>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>默认值</th>
<th>备注</th>
</tr>
</thead>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DefaultMQPushConsumer 类默认配置（源码） */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQPushConsumer</span><span class="params">(String consumerGroup)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(consumerGroup, (RPCHook)<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AllocateMessageQueueAveragely</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultMQPushConsumer</span><span class="params">(String consumerGroup, RPCHook rpcHook, AllocateMessageQueueStrategy allocateMessageQueueStrategy)</span> &#123;</span><br><span class="line">    <span class="comment">// 消费方式： </span></span><br><span class="line">    <span class="comment">// 1. CLUSTERING 集群，组内所有消费者平均消费一组消息(支持消费失败重发，从而保证消息一定被消费；但消费者配置应一致)</span></span><br><span class="line">    <span class="comment">// 2. BROADCASTING 广播，组内所有消费者消费同样的消息</span></span><br><span class="line">    <span class="built_in">this</span>.messageModel = MessageModel.CLUSTERING;           </span><br><span class="line">    <span class="comment">// 消费者开始消费的位置：</span></span><br><span class="line">    <span class="comment">// 1. CONSUME_FROM_LAST_OFFSET：第一次启动从队列最后位置消费</span></span><br><span class="line">    <span class="comment">// 2. CONSUME_FROM_FIRST_OFFSET：第一次启动从队列初始位置消费</span></span><br><span class="line">    <span class="comment">// 3. CONSUME_FROM_TIMESTAMP：第一次启动从指定时间点位置消费</span></span><br><span class="line">    <span class="built_in">this</span>.consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line">    <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="built_in">this</span>.consumeTimestamp = UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - <span class="number">1800000L</span>);</span><br><span class="line">    <span class="comment">// 订阅 topic &amp; tag</span></span><br><span class="line">    <span class="built_in">this</span>.subscription = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="built_in">this</span>.consumeThreadMin = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.consumeThreadMax = <span class="number">64</span>;</span><br><span class="line">    <span class="built_in">this</span>.adjustThreadPoolNumsThreshold = <span class="number">100000L</span>;</span><br><span class="line">    <span class="comment">// 流量控制                             </span></span><br><span class="line">    <span class="built_in">this</span>.consumeConcurrentlyMaxSpan = <span class="number">2000</span>;                     <span class="comment">// 单队列并行消费最大跨度</span></span><br><span class="line">    <span class="built_in">this</span>.pullThresholdForQueue = <span class="number">1000</span>;                          <span class="comment">// 单队列最大消费消息个数</span></span><br><span class="line">    <span class="built_in">this</span>.pullThresholdSizeForQueue = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.pullThresholdForTopic = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.pullThresholdSizeForTopic = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.pullInterval = <span class="number">0L</span>;                                     <span class="comment">// 消息拉取时间间隔</span></span><br><span class="line">    <span class="built_in">this</span>.consumeMessageBatchMaxSize = <span class="number">1</span>;                        <span class="comment">// 线程从 consumer 单次拉取数量（顺序消费必须设为1）</span></span><br><span class="line">    <span class="built_in">this</span>.pullBatchSize = <span class="number">32</span>;                                    <span class="comment">// consumer 从 broker 单次拉取数量</span></span><br><span class="line">    <span class="built_in">this</span>.postSubscriptionWhenPull = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.unitMode = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">this</span>.suspendCurrentQueueTimeMillis = <span class="number">1000L</span>;</span><br><span class="line">    <span class="built_in">this</span>.consumeTimeout = <span class="number">15L</span>;</span><br><span class="line">    <span class="comment">// 消费组</span></span><br><span class="line">    <span class="built_in">this</span>.consumerGroup = consumerGroup;</span><br><span class="line">    <span class="built_in">this</span>.groupName = consumerGroup;</span><br><span class="line">    <span class="comment">// 集群模式下消息分配策略，默认平均分配</span></span><br><span class="line">    <span class="built_in">this</span>.allocateMessageQueueStrategy = allocateMessageQueueStrategy;</span><br><span class="line">    <span class="comment">// 实现类，负责具体功能实现</span></span><br><span class="line">    <span class="built_in">this</span>.defaultMQPushConsumerImpl = <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumerImpl</span>(<span class="built_in">this</span>, rpcHook);</span><br><span class="line">    <span class="built_in">this</span>.asyncTrackReporter = <span class="keyword">new</span> <span class="title class_">AsyncTrackReporter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费方式"><a href="#消费方式" class="headerlink" title="消费方式"></a>消费方式</h3><p>RocketMQ消息订阅有两种模式，一种是 Push 模式（MQPushConsumer），即 MQServer 主动向消费端推送；另外一种是 Pull 模式（MQPullConsumer），即消费端在需要时主动到 MQServer 拉取。</p>
<p>但在具体实现时，Push 和 Pull 模式都是采用消费端主动拉取的方式，即 consumer 轮询从 broker 拉取消息。</p>
<ol>
<li><strong>Push 方式</strong></li>
</ol>
<p>实现 DefaultMQPushConsumer 接口。客户端应用向 Consumer 对象注册一个 Listener 接口，Consumer 对象向 Broker 的轮询过程被封装，在收到消息后立刻回调 Listener 接口方法唤醒客户端应用来消费。对用户而言，感觉消息是被推送过来的，使用起来非常便捷。</p>
<p>Push 模式最大的问题是慢消费。如果消费者的速度比发送者的速度慢很多，势必造成消息在 Broker 的堆积。尤其是消息无法被 Consumer 处理时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConsumerExampleRMQ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设定消费者</span></span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;CG-consumer_test&quot;</span>);         <span class="comment">// 设定消费组名</span></span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;nameServer:9876;nameServer_2:9876&quot;</span>);                           <span class="comment">// 设定 NameServer 地址</span></span><br><span class="line">        consumer.setToken(<span class="string">&quot;Token&quot;</span>);                                                             <span class="comment">// 设定 Token</span></span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);               <span class="comment">// 设定从最开始处消费</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(<span class="number">10</span>);                                             <span class="comment">// 设定线程最大消费数量，默认为 1 （50 条消息将分给 5 个线程处理）</span></span><br><span class="line">        consumer.subscribe(<span class="string">&quot;stream_rmq_topic&quot;</span>, <span class="string">&quot;test&quot;</span>);                                         <span class="comment">// 设定订阅的 topic 和 tag（ * 表示全部）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册消息监听，输入参数类型</span></span><br><span class="line">        <span class="comment">// 1. MessageListenerConcurrently 接口：不保证顺序消费</span></span><br><span class="line">        <span class="comment">// 2. MessageListenerOrderly 接口：保证分区内消息被顺序消费</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerConcurrently</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Receive New Messages: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;exception happened&quot;</span>);</span><br><span class="line">                        logger.error(<span class="string">&quot;failed to process,msg:&#123;&#125;&quot;</span>,msg,throwable);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回成功，消息会被ACK</span></span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动订阅</span></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ol start="2">
<li><strong>Pull 方式</strong></li>
</ol>
<p>实现 DefaultMQPullConsumer 接口。应用主动调用 Consumer 的 pull 方法从 Broker 获取消息。需要自己维护 MessageQueue 与 Offset ，建议只有必要时使用。</p>
<p>Pull 方式下 Consumer 可以按需消费，不用频繁接收无法处理的消息。而 Broker 堆积消息也会相对简单，无需记录每一个要发送消息的状态，只需要维护所有消息的队列和偏移量就可以。所以对于慢消费，消息量有限且到来的速度不均匀的情况比较合适。</p>
<p>消息延迟与忙等是 Pull 模式最大的短板。业界较成熟的做法是从短时间开始（不会对 broker 有太大负担），然后指数级增长等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PullConsumer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;MessageQueue, Long&gt; OFFSET_TABLE = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="type">DefaultMQPullConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPullConsumer</span>(<span class="string">&quot;ConsumerGroupName&quot;</span>);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(<span class="string">&quot;TopicTest&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Consume from the queue: &quot;</span> + mq);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">PullResult</span> <span class="variable">pullResult</span> <span class="operator">=</span></span><br><span class="line">                        consumer.pullBlockIfNotFound(mq, <span class="literal">null</span>, getMessageQueueOffset(mq), <span class="number">32</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;Result: &quot;</span> + pullResult);</span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line">                    <span class="keyword">switch</span> (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> FOUND:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_MATCHED_MSG:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> NO_NEW_MSG:</span><br><span class="line">                            <span class="keyword">break</span> SINGLE_MQ;</span><br><span class="line">                        <span class="keyword">case</span> OFFSET_ILLEGAL:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getMessageQueueOffset</span><span class="params">(MessageQueue mq)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">offset</span> <span class="operator">=</span> OFFSET_TABLE.get(mq);</span><br><span class="line">        <span class="keyword">if</span> (offset != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> offset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">putMessageQueueOffset</span><span class="params">(MessageQueue mq, <span class="type">long</span> offset)</span> &#123;</span><br><span class="line">        OFFSET_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考资料</p>
<p><a href="https://dbaplus.cn/news-21-1123-1.html">https://dbaplus.cn/news-21-1123-1.html</a></p>
</blockquote>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>Consumer 启动后主要执行以下流程：</p>
<ol>
<li>初始化一个 RebalanceImpl 对象做 rebalance 操作：确认 consumer 负责处理哪些 queue 的消息，默认采用平均分配策略(AVG)。</li>
<li>RebalanceImpl 到 broker 拉取指定 queue 的消息，然后把消息按照 queueId 放到对应的本地的 ProcessQueue 缓存中。拉取消息实际是调用 DefaultMQPushConsumerImpl 类下的 pullMessage 方法进行消息的拉取。</li>
<li>ConsumeMessageService 调用 listener 处理消息，处理成功后清除掉。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException &#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="built_in">this</span>.serviceState) &#123;</span><br><span class="line">            <span class="keyword">case</span> CREATE_JUST:</span><br><span class="line">                <span class="built_in">this</span>.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                <span class="comment">//1、基本的参数检查，group name不能是DEFAULT_CONSUMER</span></span><br><span class="line">                <span class="built_in">this</span>.checkConfig();</span><br><span class="line">                <span class="comment">//2、将DefaultMQPushConsumer的订阅信息copy到RebalanceService中</span></span><br><span class="line">                <span class="comment">//如果是cluster模式，如果订阅了topic,则自动订阅%RETRY%topic</span></span><br><span class="line">                <span class="built_in">this</span>.copySubscription();</span><br><span class="line">                <span class="comment">//3、修改InstanceName参数值为PID</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4、新建一个MQClientInstance,客户端管理类，所有的i/o类操作由它管理</span></span><br><span class="line">                <span class="comment">//缓存客户端和topic信息，各种service</span></span><br><span class="line">                <span class="comment">//一个进程只有一个实例</span></span><br><span class="line">                <span class="built_in">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="built_in">this</span>.defaultMQPushConsumer, <span class="built_in">this</span>.rpcHook);</span><br><span class="line">                <span class="built_in">this</span>.rebalanceImpl.setConsumerGroup(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                <span class="built_in">this</span>.rebalanceImpl.setMessageModel(<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">                <span class="comment">//5、Queue分配策略，默认AVG</span></span><br><span class="line">                <span class="built_in">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="built_in">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">                <span class="built_in">this</span>.rebalanceImpl.setmQClientFactory(<span class="built_in">this</span>.mQClientFactory);</span><br><span class="line">                <span class="comment">//6、PullRequest封装实现类，封装了和broker的通信接口</span></span><br><span class="line">                <span class="built_in">this</span>.pullAPIWrapper = <span class="keyword">new</span> <span class="title class_">PullAPIWrapper</span>(</span><br><span class="line">                    mQClientFactory,</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">                <span class="comment">//7、消息被客户端过滤时会回调hook</span></span><br><span class="line">                <span class="built_in">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line">                <span class="comment">//8、consumer客户端消费offset持久化接口</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.offsetStore = <span class="built_in">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (<span class="built_in">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                        <span class="keyword">case</span> BROADCASTING:<span class="comment">//广播消息本地持久化offset</span></span><br><span class="line">                            <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">LocalFileOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> CLUSTERING:<span class="comment">//集群模式持久化到broker</span></span><br><span class="line">                            <span class="built_in">this</span>.offsetStore = <span class="keyword">new</span> <span class="title class_">RemoteBrokerOffsetStore</span>(<span class="built_in">this</span>.mQClientFactory, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">this</span>.defaultMQPushConsumer.setOffsetStore(<span class="built_in">this</span>.offsetStore);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//9、如果是本地持久化会从文件中load</span></span><br><span class="line">                <span class="built_in">this</span>.offsetStore.load();</span><br><span class="line">                <span class="comment">//10、消费服务，顺序和并发消息逻辑不同,接收消息并调用listener消费，处理消费结果</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.consumeOrderly = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ConsumeMessageOrderlyService</span>(<span class="built_in">this</span>, (MessageListenerOrderly) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.consumeOrderly = <span class="literal">false</span>;</span><br><span class="line">                    <span class="built_in">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ConsumeMessageConcurrentlyService</span>(<span class="built_in">this</span>, (MessageListenerConcurrently) <span class="built_in">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//11、只启动了清理等待处理消息服务</span></span><br><span class="line">                <span class="built_in">this</span>.consumeMessageService.start();</span><br><span class="line">                <span class="comment">//12、注册（缓存）consumer，保证CID单例</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">registerOK</span> <span class="operator">=</span> mQClientFactory.registerConsumer(<span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="built_in">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                    <span class="built_in">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MQClientException</span>(<span class="string">&quot;The consumer group[&quot;</span> + <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + <span class="string">&quot;] has been created before, specify another name please.&quot;</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        <span class="literal">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//13、启动MQClientInstance，会启动PullMessageService和RebalanceService</span></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">                log.info(<span class="string">&quot;the consumer [&#123;&#125;] start OK.&quot;</span>, <span class="built_in">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                <span class="built_in">this</span>.serviceState = ServiceState.RUNNING;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING:</span><br><span class="line">            <span class="keyword">case</span> START_FAILED:</span><br><span class="line">            <span class="keyword">case</span> SHUTDOWN_ALREADY:</span><br><span class="line">                ...</span><br><span class="line">                ...</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//14、从NameServer更新topic路由和订阅信息</span></span><br><span class="line">        <span class="built_in">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.checkClientInBroker();<span class="comment">//如果是SQL过滤，检查broker是否支持SQL过滤</span></span><br><span class="line">        <span class="comment">//15、发送心跳，同步consumer配置到broker,同步FilterClass到FilterServer(PushConsumer)</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">        <span class="comment">//16、做一次re-balance</span></span><br><span class="line">        <span class="built_in">this</span>.mQClientFactory.rebalanceImmediately();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>参考资料</p>
<ol>
<li>参数：<a href="https://blog.csdn.net/a417930422/article/details/50700281">https://blog.csdn.net/a417930422/article/details/50700281</a></li>
<li>过程：<a href="https://blog.csdn.net/meilong_whpu/article/details/77076298">https://blog.csdn.net/meilong_whpu/article/details/77076298</a></li>
</ol>
</blockquote>
<h2 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h2><h3 id="消费方式-1"><a href="#消费方式-1" class="headerlink" title="消费方式"></a>消费方式</h3><p>顺序消费场景：在网购的时候，我们需要下单，那么下单需要假如有三个顺序，第一、创建订单 ，第二：订单付款，第三：订单完成。也就是这个三个环节要有顺序，这个订单才有意义。</p>
<p>消费端消费的时候，会分配到多个 queue 同时拉取消费。RocketMQ 只能保证同一个 queue 内顺序消费，因此想要实现顺序消费，必须实现以下过程：</p>
<ol>
<li><strong>生产者</strong></li>
</ol>
<p>Producer 在发送消息的时候，通过选择器把应当按照顺序的消息发到同一个 Queue 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaProducerExampleRMQ2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;PG-stream_test&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;nameServer:9876;nameServer_2:9876&quot;</span>);    </span><br><span class="line">        producer.setToken(<span class="string">&quot;Token&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">orderId</span> <span class="operator">=</span> i % <span class="number">10</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;stream_rmq_topic&quot;</span> ,</span><br><span class="line">                    <span class="string">&quot;test&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;20200727&quot;</span>,</span><br><span class="line">                    (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// send 参数分别为 消息/选择器/ID</span></span><br><span class="line">            <span class="type">SendResult</span> <span class="variable">sendResult</span> <span class="operator">=</span> producer.send(msg, <span class="keyword">new</span> <span class="title class_">MessageQueueSelector</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> MessageQueue <span class="title function_">select</span><span class="params">(List&lt;MessageQueue&gt; mqs, Message msg, Object arg)</span> &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> (Integer) arg;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> id % mqs.size();</span><br><span class="line">                    <span class="keyword">return</span> mqs.get(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, orderId);</span><br><span class="line">            System.out.printf(<span class="string">&quot;返回结果：%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>消费者</strong></li>
</ol>
<p>消费者注册消息监听器为 MessageListenerOrderly ，即使有多个线程也保证消费端只有一个线程去消费消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConsumerExampleRMQ2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">DefaultMQPushConsumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQPushConsumer</span>(<span class="string">&quot;consumeGroupName&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;nameServer:9876;nameServer_2:9876&quot;</span>);   </span><br><span class="line">        consumer.setToken(<span class="string">&quot;Token&quot;</span>);</span><br><span class="line">        <span class="comment">// 必须设定为集群，广播本身就失去顺序保障</span></span><br><span class="line">        consumer.setMessageModel(MessageModel.CLUSTERING);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">        <span class="comment">// 必须设定为 1，保证有序不能一次性拉取多个</span></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(<span class="number">1</span>);       </span><br><span class="line">        consumer.subscribe(<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;tag&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息监听设定，MessageListenerOrderly 对象在有消费者读取时锁死队列</span></span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> <span class="title class_">MessageListenerOrderly</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> ConsumeOrderlyStatus <span class="title function_">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context)</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Receive New Messages: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(msg.getBody()));</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Throwable throwable)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;exception happened&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上锁机制"><a href="#上锁机制" class="headerlink" title="上锁机制"></a>上锁机制</h3><ol>
<li><strong>Broker 端</strong></li>
</ol>
<p>维护全局队列锁 ConcurrentHashMap mqLockTable , 对 ConsumeQueue 上锁。</p>
<p>Cosumer 会周期性的发送 lock queue 的命令给 Broker。顺序消费时 consumer 会在锁定 queue 成功后才开始消费，并且默认每 20 秒就会刷新一下锁。Broker 如果发现锁超过 1 分钟没有刷新，则会自动释放。</p>
<ol start="2">
<li><strong>Consumer 端</strong> </li>
</ol>
<p>维护当前 consumer 端的本地队列锁 MessageQueueLock messageQueueLock ，对本地缓存队列 ProcessQueue 上锁。</p>
<p>消息到达 consumer 后回被放进缓存队列 ProcessQueue 中。而对于顺序消息集群模式下，检查一下当前 ProcessQueue 是否仍然持有 queue 的锁，保障同一时间同一个 queue 只会有一个线程在处理。</p>
<p><em>顺序消息处理也必须在同一个 consumer 上，且同一个 queue 的消息只能单线程处理，存在消息堆积的可能。</em></p>
<h3 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h3><p>普通消息会有两种情况导致消息重新返还给 Broker 重新投递，一种是消息在 consumer 的缓存中等待时间过长，还有一种就是用户代码逻辑中处理失败。</p>
<p>顺序消息用户处理完毕后，只会返回两种结果：</p>
<ul>
<li><code>ConsumeOrderlyStatus.SUCCESS</code> （成功，准备提交）</li>
<li><code>ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT</code> （挂起，准备重试）</li>
</ul>
<p>因为对于顺序消息，消费处理失败不会返回给 Broker 重新投递，而是会放到本地的缓存队列中重新处理。直到到达重试次数之后，返回并放入 Broker 中的死信队列。不再会因为长时间在缓存中等待而重投，因为重投也不会再交给其它 Consumer 处理。</p>
<p>成功后（默认）会调用 ProcessQueue 的 commit 方法，把获取消息时创建的临时 map 清空，然后记录当前消费的 offset。最后把进度同步给 Broker。</p>
<p>失败后首先检查是否超过最大重试的次数，没超过会放回到 ProcessQueue 的 msgTreeMap 中重试。如果超过了则直接放入 Broker 的死信队列，清空本地缓存。</p>
<p><strong>AutoCommit</strong></p>
<p>可以通过 ConsumeOrderlyContext 类的 setAutoCommit 方法设定是否自动提交（默认为自动提交）。</p>
<ol>
<li>当结果为失败时，autoCommit 设置为 true 或者 false 没有区别。</li>
<li>当结果为成功时，autoCommit 设置为 true 时比设置为 false 多做了 2 个动作：<ul>
<li>删除 msgTreeMapTemp 里的消息，这是在上面消费时从 msgTreeMap 转移过来的。</li>
<li>把拉消息的偏移量更新到本地内存中，然后定时更新到 broker。      </li>
</ul>
</li>
</ol>
<p>否则随着消息的消费进行，msgTreeMapTemp 里的消息堆积越来越多，而消费消息的偏移量一直没有更新到 broker 导致 consumer 每次重新启动后都要从头开始重复消费。 </p>
<hr>
<h2 id="事务信息"><a href="#事务信息" class="headerlink" title="事务信息"></a>事务信息</h2><p>rocketMQ 从 4.1.3 版本开始支持事务信息，由 TransactionMQProducer 类提供</p>
<hr>
<h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>Broker收到消息后的处理线程只负责消息存储，不负责通知consumer或者其它逻辑，最大化消息吞吐量</p>
<p>每条消息存储时都会有一个offset，通过offset是定位到消息位置并获取消息详情的唯一办法，所有的消息查询操作最终都是转化成通过offset查询消息详情</p>
<h3 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h3><p>RocketMQ 的在 Broker 中的消息存储是由 consume queue 和 commit log 配合完成的。</p>
<p>consume queue 是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件commit log上的位置。</p>
<p>commit log 是存储的物理文件。</p>
<p><strong>ConsumeQueue</strong></p>
<p>Broker 在收到消息后，通过 MessageStore 将消息存储到 commitLog 中，但是 consumer 在消费消息的时候是按照 topic+queue 的维度来拉取消息的。为了方便读取，MessageStore 将 CommitLog 中消息的 offset 按照 topic+queueId 划分后，存储到不同的文件中，这就是 ConsumeQueue.</p>
<p>consumer来读取文件的时候，只要指定要读的topic和queueId，以及开始offset。因为每个CQUnit的大小是固定的，所以很容易就可以在文件中定位到。找到开始的位置后，只需要连续读取后面指定数量的Unit，然后根据Unit中存的CommitLog的offset就可以到CommitLog中读取消息详情了。</p>
<h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>Consumer 的时候说到消费消息分为 Pull 和 Push 两种模式，底层其实都是依靠 Pull 实现的。在 Broker 这端处理 PushConsumer 的 Pull 请求的时候，如果消息不存在，会 hold 住请求直到超时或者有新的消息到达Broker。</p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><ol>
<li>接收消息</li>
</ol>
<p>Broker提供的消息发送的接口有：单条消息、批量消息、RETRY消息。Retry消息即consumer消费失败，要求broker重发的消息。</p>
<p>消息重发是有次数限制的，默认是16次。这里会检查是否已经超过最大次数，超过的话将topic设置成DeadQueue会放入死信队列。</p>
<p>Producer或者consumer发送消息后，Broker通过SendMessageProcessor做接收和处理。一个消息的包可以只包含了一条消息，也可以包含多条消息。</p>
<ol start="2">
<li>存储消息</li>
</ol>
<p>首先判断broker是否是master，并且master当前是可写的。然后判断commitLog上次flush的时候是否超时，如果超时则返回OS_PAGECACHE_BUSY的错误。最终调用commitLog.putMessage()方法保存消息。下面看下CommitLog的方法实现</p>
<p>每条消息存储前都会产生一个Message ID，通过这个id可以快速的得到消息存储的broker和它在CommitLog中的offset</p>
<p>所有的消息在存储时都是按顺序存在一起的，不会按topic和queueId做物理隔离<br>每条消息存储时都会有一个offset，通过offset是定位到消息位置并获取消息详情的唯一办法，所有的消息查询操作最终都是转化成通过offset查询消息详情<br>每条消息存储前都会产生一个Message ID，通过这个id可以快速的得到消息存储的broker和它在CommitLog中的offset<br>Broker收到消息后的处理线程只负责消息存储，不负责通知consumer或者其它逻辑，最大化消息吞吐量<br>Broker返回成功不代表消息已经写入磁盘，如果对消息的可靠性要求高的话，可以将FlushDiskType设置成SYNC_FLUSH，这样每次收到消息写入文件后都会做flush操作。</p>
<p><a href="https://blog.csdn.net/guolong1983811/article/details/78821926">https://blog.csdn.net/guolong1983811/article/details/78821926</a></p>
]]></content>
      <categories>
        <category>其它</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/html/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>定义页面元素。浏览器加载 html 文件后，会将其解析为树形结构 DOM ：每个 html 标签和属性都作为一个 DOM 树节点。在全部代码（包含引入文件）解析完成后，将 DOM 树绘制并渲染为用户可见的页面。</p>
<hr>
<h2 id="html-页面根标签"><a href="#html-页面根标签" class="headerlink" title="html 页面根标签"></a>html 页面根标签</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--your code--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="head-页面头部"><a href="#head-页面头部" class="headerlink" title="head 页面头部"></a>head 页面头部</h2><h3 id="title-页面标题"><a href="#title-页面标题" class="headerlink" title="title 页面标题"></a>title 页面标题</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="meta-页面元数据"><a href="#meta-页面元数据" class="headerlink" title="meta 页面元数据"></a>meta 页面元数据</h3><p><em>页面作者 / 页面描述</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;MrJoker&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;这是你的页面。&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>页面类型 / 页面编码</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>http-equiv：元数据在 response 头部返回浏览器</li>
</ul>
<h3 id="link-外部资源链接"><a href="#link-外部资源链接" class="headerlink" title="link 外部资源链接"></a>link 外部资源链接</h3><p><em>引入 网页图标 / CSS</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/x-icon&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;asserts/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="style-页面样式"><a href="#style-页面样式" class="headerlink" title="style 页面样式"></a>style 页面样式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow&#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="script-执行脚本"><a href="#script-执行脚本" class="headerlink" title="script 执行脚本"></a>script 执行脚本</h3><ul>
<li>引入外部脚本文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>自定义脚本</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;demo&quot;</span>).<span class="property">innerHTML</span> = <span class="string">&quot;My first JavaScript&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="页面内容-body"><a href="#页面内容-body" class="headerlink" title="页面内容 body"></a>页面内容 body</h2><h3 id="div-span-区域"><a href="#div-span-区域" class="headerlink" title="div / span 区域"></a>div / span 区域</h3><ul>
<li><code>&lt;div&gt;</code> 为块状元素：独占一行</li>
<li><code>&lt;span&gt;</code> 为内联元素：和其他内联元素共享一行</li>
</ul>
<h3 id="h1-h6-标题"><a href="#h1-h6-标题" class="headerlink" title="h1 - h6 标题"></a>h1 - h6 标题</h3><p><code>&lt;h1&gt;Chapter 1&lt;/h1&gt;</code></p>
<h3 id="p-文本"><a href="#p-文本" class="headerlink" title="p 文本"></a>p 文本</h3><p><code>&lt;p&gt;This is my first paragraph.&lt;/p&gt;</code></p>
<h3 id="a-超链接"><a href="#a-超链接" class="headerlink" title="a 超链接"></a>a 超链接</h3><p><code>&lt;p href=&quot;www.baidu.com&quot;&gt;This is my second paragraph.&lt;/p&gt;</code></p>
<ul>
<li>href：跳转网址</li>
</ul>
<h3 id="img-图片"><a href="#img-图片" class="headerlink" title="img 图片"></a>img 图片</h3><p><code>&lt;img src=&quot;boat.gif&quot; alt=&quot;Big Boat&quot; /&gt;</code></p>
<ul>
<li>src：图片地址</li>
<li>alt：图片不能加载时的替代文本</li>
</ul>
<h3 id="table-表格"><a href="#table-表格" class="headerlink" title="table 表格"></a>table 表格</h3><ul>
<li>每个单元项表示为<code>&lt;tr&gt;</code></li>
<li>每个单元格表示为<code>&lt;td&gt;</code> ，标题单元格表示为<code>&lt;th&gt;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>0021<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>陈柏言<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>0022<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>邓怀瑾<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="form-表单"><a href="#form-表单" class="headerlink" title="form 表单"></a>form 表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;action_page.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;GET&quot;</span>&gt;</span></span><br><span class="line">  Name:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Input your nane&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  Sex:</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>action：请求发送地址(URL)</li>
<li>method：请求类型</li>
</ul>
<p><strong>提交按钮</strong></p>
<p><code>&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</code></p>
<p><strong>输入类型</strong></p>
<ul>
<li>输入框</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Username:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MrJoker&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Password:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ul>
<li>选择框</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Sex:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span>Male</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">Vehicle:</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bike&quot;</span>&gt;</span>I have a bike</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>I have a car</span><br></pre></td></tr></table></figure>

<ul>
<li>下拉菜单</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Your Car:</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;cars&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;volvo&quot;</span>&gt;</span>Volvo<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;saab&quot;</span>&gt;</span>Saab<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;fiat&quot;</span>&gt;</span>Fiat<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;audi&quot;</span>&gt;</span>Audi<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文本域</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span>&gt;</span>Descript your car here.<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/css/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><p>定义页面样式。浏览器在构造完成页面的 DOM 树后，会解析 css 代码以及引入的 css 文件，将定义的样式表规则添加到对应的 DOM 树节点上。在绘制并渲染为用户可见的页面时使用。</p>
<hr>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器确定 CSS 样式的作用范围。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;px&quot;</span> <span class="attr">id</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>first paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;px&quot;</span> <span class="attr">id</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>second paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./next.html&quot;</span>&gt;</span>next<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span> &#123; <span class="attribute">letter-spacing</span>:<span class="number">0.5em</span>; &#125;               <span class="comment">/* 简单选择器 */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.px</span> &#123; <span class="attribute">font-size</span>:<span class="number">20px</span>; &#125;                     <span class="comment">/* 类选择器 */</span> </span></span><br><span class="line"><span class="language-css"><span class="selector-id">#p1</span> &#123; <span class="attribute">color</span>:brown; &#125;                        <span class="comment">/* ID 选择器 */</span> </span></span><br><span class="line"><span class="language-css"><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span> &#123; <span class="attribute">display</span>:block; &#125;          <span class="comment">/* 属性选择器 */</span>             </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂类选择器</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;important welcome&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;warning&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>NO<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>STOP<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 多重条件触发 */</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.important</span><span class="selector-class">.welcome</span> &#123; <span class="attribute">background</span>:silver; &#125;</span></span><br><span class="line"><span class="language-css">  <span class="comment">/* 嵌套条件触发*/</span></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">div</span> <span class="selector-tag">h1</span> &#123; <span class="attribute">font-weight</span>:bold; &#125;    </span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.warning</span> <span class="selector-class">.text</span> &#123; <span class="attribute">background</span>:silver; &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h2><ol>
<li>静态定位(static)：默认情况，元素从上到下依次放入 html 页面。</li>
<li>相对定位(relative)：根据其正常位置偏移。</li>
<li>绝对定位(absolute)：根据首个非静态父元素位置偏移。</li>
<li>固定定位(fixed)：相对于浏览器窗口偏移，即使滚动窗口也不发生改变。</li>
</ol>
<ul>
<li><code>position:relative;</code> 设置元素为相对定位</li>
<li><code>position:absolute;</code> 设置元素为绝对定位</li>
<li><code>position:fixed;</code> 设置元素为固定定位</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 绝对定位到父元素左上角 */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">10px</span>;             <span class="comment">/* 同时设置 left 和 right 会强置元素宽度 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;              <span class="comment">/* 同时设置 top 和 bottom 会强置元素高度 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>子元素设置为 absolute 定位后，一般要把对应的父元素定位切换到 relative .</p>
</blockquote>
<hr>
<h2 id="元素框"><a href="#元素框" class="headerlink" title="元素框"></a>元素框</h2><p>元素从外到内依次为：<strong>外边距(margin) &gt; 边框(border) &gt; 内边距(padding) &gt; 内容(content)</strong></p>
<p><strong>外边距</strong></p>
<ol>
<li>默认透明。</li>
<li>上下两元素外边距取最大值：外边距重叠。</li>
<li>可以取负值：相邻两元素重叠。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#88b7e0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span> <span class="number">0</span> <span class="number">10px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">180px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当元素大小随父元素浮动时，可以为元素最大或最小尺寸。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">70px</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">280px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算元素尺寸时，可以使用四则运算式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">80px</span>);</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="元素放置"><a href="#元素放置" class="headerlink" title="元素放置"></a>元素放置</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><strong>块级元素</strong></li>
</ol>
<p>  独占一行，可任意规定宽高和内外边距大小。宽度默认是容器的100%，以容纳内联元素和其他块元素。</p>
<p>  常用的块状元素有：<code>&lt;div&gt;、&lt;p&gt;、&lt;h1&gt;...&lt;h6&gt;、&lt;ol&gt;、&lt;ul&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt; 、&lt;form&gt;</code></p>
<ol start="2">
<li><strong>内联元素</strong> </li>
</ol>
<p>  和其他内联元素分享一行，宽高随内容自动变化（无法设置），不可设置上下边距大小，但可以设置左右边距。行内元素内不能容纳块元素。</p>
<p>  常用的行内元素有：<code>&lt;a&gt;、&lt;span&gt;、、&lt;i&gt;、&lt;em&gt;、&lt;strong&gt;、&lt;label&gt;、&lt;q&gt;、&lt;var&gt;、&lt;cite&gt;、&lt;code&gt;</code></p>
<ol start="3">
<li><strong>行内块状元素</strong></li>
</ol>
<p>同时具备行内元素、块状元素的特点，和其他元素在同一行，高、宽和边距可以设置。</p>
<p>常用元素 <code>&lt;img&gt;、&lt;input&gt;</code></p>
<ul>
<li><code>display:block</code> 设置为块级元素</li>
<li><code>display:inline</code> 设置为内联元素</li>
<li><code>display:inline-block</code> 设置为行内块级元素</li>
<li><code>display:none</code> 不摆放该元素</li>
</ul>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><p>在父级父容器中让行内元素居中对齐：</p>
<ol>
<li><strong>水平居中</strong></li>
</ol>
<p>对于块状元素，只需要规定 <code>margin: 0 auto</code> ;</p>
<p>对于内联元素（如文本和链接），只需要在块级父容器中添加 <code>text-align: center</code> 。</p>
<ol start="2">
<li><strong>垂直居中</strong></li>
</ol>
<p>对于已知高度的块状元素，通过</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">position</span>: relative; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>; </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>; </span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于未知高度的块状元素，通过（该方法也适用于水平居中）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123; <span class="attribute">position</span>: relative; &#125; </span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>; </span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>); </span><br><span class="line">  <span class="comment">/* left:50%;</span></span><br><span class="line"><span class="comment">  transform: translate(-50%,-50%); */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于内联元素，只需为它们添加等值的 <code>padding-top</code> 和 <code>padding-bottom</code> 就可以实现垂直居中。</p>
<h3 id="可见"><a href="#可见" class="headerlink" title="可见"></a>可见</h3><p>隐藏元素共有三种方式，效果不同：</p>
<ul>
<li><code>display:none</code> 元素不摆放，等同于没有</li>
<li><code>visibility:hidden</code> 元素隐藏，不可用但仍占用布局空间</li>
<li><code>opacity:0</code> 元素透明，可用但不可见（不透明度0-1）</li>
</ul>
<p>当多个元素堆叠在同一个位置时，可以指定摆放层次：</p>
<ul>
<li><code>z-index: 5</code> 元素摆放在第 5 层，同位置元素数值较大者用户可见</li>
</ul>
<hr>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: white;                  <span class="comment">/* 字体颜色 */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">15px</span>;               <span class="comment">/* 字体大小 */</span></span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;       <span class="comment">/* 字体样式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h3><ul>
<li><p><code>letter-spacing:0.5em;</code> 字符间距</p>
</li>
<li><p><code>word-spacing:0.5em;</code> 单词间距（只对英文起作用）</p>
</li>
<li><p><code>text-indent: 2em;</code> 首行缩进，设置为2字符</p>
</li>
</ul>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><ul>
<li><code>overflow-x:hidden;</code>  水平方向：文本超出内容框后隐藏</li>
<li><code>overflow-y:auto;</code>  垂直方向：视情况提供滚动条</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>文本超出后会显示在内容框之外。</td>
</tr>
<tr>
<td>hidden</td>
<td>文本超出部分被裁剪。</td>
</tr>
<tr>
<td>scroll</td>
<td>提供滚动条。</td>
</tr>
<tr>
<td>auto</td>
<td>文本超出后提供滚动条。</td>
</tr>
<tr>
<td>no-display</td>
<td>如果内容不适合内容框，则删除整个框。</td>
</tr>
<tr>
<td>no-content</td>
<td>如果内容不适合内容框，则隐藏整个内容。</td>
</tr>
</tbody></table>
<hr>
<h2 id="图片样式"><a href="#图片样式" class="headerlink" title="图片样式"></a>图片样式</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>background: url(&quot;../assets/x.jpg&quot;) no-repeat left;</code> 背景图</p>
<hr>
<h2 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h2><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><strong><code>table</code> 有外边距(margin)，但有无内边(padding)距视情况而定：</strong></p>
<ol>
<li>【默认情况】单元格(td)分散</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: separate;       <span class="comment">/* 单元格分散，内边距有效 */</span></span><br><span class="line">  <span class="attribute">border</span>-space: <span class="number">0</span>;                 <span class="comment">/* 单元格间距，设为 0 起到紧贴效果 */</span> </span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1px</span>;                    <span class="comment">/* 单元格和表格外框间距 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>【常用情况】单元格(td)紧挨</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">table</span> &#123;</span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;       <span class="comment">/* 单元格紧贴，内边距无效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>tr</code> 和 <code>td/th</code> 作为内部元素无外边距(margin)。</p>
</blockquote>
<h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><ol>
<li><code>tr</code>：对指定行采用不同样式</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 奇数行元素 */</span></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(odd)&#123;           </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eeeff2</span>; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 偶数行元素 */</span></span><br><span class="line"><span class="selector-tag">table</span> <span class="selector-tag">tr</span><span class="selector-pseudo">:nth-child</span>(even)&#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#dfe1e7</span>; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>td</code>：对指定列采取不同样式</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 第3列以前的全部元素 */</span></span><br><span class="line"><span class="selector-tag">tr</span> <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child</span>(-n+<span class="number">3</span>)&#123; </span><br><span class="line">  <span class="attribute">text-align</span>:center; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* 第4列以后的全部元素 */</span></span><br><span class="line"><span class="selector-tag">tr</span> <span class="selector-tag">td</span><span class="selector-pseudo">:nth-child</span>(n+<span class="number">4</span>)&#123; </span><br><span class="line">  <span class="attribute">text-align</span>:center; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>其它</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/javascript/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>由浏览器（或者Node.js）执行的动态函数，解析后对 DOM 树元素进行动态修改，以实现页面的动态功能。</p>
<hr>
<h2 id="相等判定"><a href="#相等判定" class="headerlink" title="相等判定"></a>相等判定</h2><ul>
<li>== 值是否相等 <code>&#39;10&#39; == 10</code></li>
<li>=== 值及类型是否完全相等 <code>&#39;10&#39; !== 10</code></li>
</ul>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p><strong>var 变量</strong></p>
<p>如果定义在函数内，不能跨函数访问。</p>
<p><strong>let 块内变量</strong></p>
<p>不仅不能跨函数访问，如果定义在块内，也不能跨块访问。</p>
<p><strong>const 常量</strong></p>
<p>必须初始化(即必须赋值)，不能跨块访问，而且不能修改。</p>
<p><font size=2 color=brown>非基础类型的 const 对象实际是保存指向对象的指针，修改对象的内容是允许的。</font></p>
<h2 id="数据交互-Ajax"><a href="#数据交互-Ajax" class="headerlink" title="数据交互 Ajax"></a>数据交互 Ajax</h2><p>使用现有的 js 语法，通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。即在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>XMLHttpRequest 是 AJAX 的基础，通过其在后台和服务器间交换数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">loadXMLDoc</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//创建交互对象</span></span><br><span class="line">  <span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="comment">//修改页面数据</span></span><br><span class="line">  xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span>==<span class="number">200</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="property">innerHTML</span>=xmlhttp.<span class="property">responseText</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//发送请求（请求类型/URL/是否异步）</span></span><br><span class="line">  xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">  xmlhttp.<span class="title function_">send</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用jQuery可以实现，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">  $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;show.html&quot;</span>,    <span class="comment">//目标页面</span></span><br><span class="line">      <span class="attr">dataType</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">      <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">html</span>)&#123;</span><br><span class="line">        $(<span class="string">&quot;html&quot;</span>).<span class="title function_">html</span>(html);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/nodejs/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p><a href="https://www.runoob.com/nodejs/nodejs-tutorial.html">https://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>
<hr>
<h2 id="Node-js-1"><a href="#Node-js-1" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="Node-js-介绍"><a href="#Node-js-介绍" class="headerlink" title="Node.js 介绍"></a>Node.js 介绍</h3><p>Node.js 是一个 JavaScript 运行环境，运行在服务端（后端）。用户不再需要后台动态编程语言，只使用 JS 也可以创建自己的后台服务。</p>
<p>官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a> </p>
<blockquote>
<p>默认下载可执行程序版本，程序会自动配置环境变量，开发者可以直接使用。</p>
</blockquote>
<h3 id="Node-js-使用"><a href="#Node-js-使用" class="headerlink" title="Node.js 使用"></a>Node.js 使用</h3><p>安装 Node.js 成功后，通过控制台命令可以执行 JS 脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node --version             <span class="comment"># 查看 Node.js 版本</span></span><br><span class="line"></span><br><span class="line">node                       <span class="comment"># 进入 Node.js 运行环境，可以直接输入 JS 代码并执行</span></span><br><span class="line">node example.js            <span class="comment"># 执行指定的 JS 文件</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Node-js-模块"><a href="#Node-js-模块" class="headerlink" title="Node.js 模块"></a>Node.js 模块</h2><h3 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h3><p>根据主流的模块化规范 ES6 定义：一个 JS 文件就是一个模块。</p>
<p>模块之间必须通过规范的接口相互调用，目前最常使用的是 CommonJS 规范和 ES6 标准。</p>
<p><strong>CommonJS 规范</strong></p>
<ol>
<li>module.exports 导出接口，require 引入模块。</li>
<li>输出是值的拷贝。</li>
</ol>
<p><em>由于引擎尚不支持，我们在 node.js 中习惯使用 CommonJS 语法。</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">x</span>)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输出数据为&quot;</span> + x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">num</span> = num</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">test</span> = userTest           <span class="comment">// 可以写为 module.exports.test = useTest</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>)            <span class="comment">// 调用 a.useTest(a.num)   </span></span><br></pre></td></tr></table></figure>

<p><strong>ES6 语法</strong></p>
<ol>
<li>export 导出接口，import 引入模块。</li>
<li>输出是值的引用。</li>
</ol>
<p><em>我们在 vue 中通常使用 ES6 语法，但必须安装 babel 插件自动转码为 commonJS 语法执行。</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">x</span>)&#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;输出数据为&quot;</span> + x); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> num                  </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> test               <span class="comment">// 可以写为 export test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出接口</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;            </span><br><span class="line">  num,</span><br><span class="line">  test</span><br><span class="line">&#125;     </span><br><span class="line"></span><br><span class="line"><span class="comment">/*************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;num,test <span class="keyword">as</span> useTest&#125; <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>   <span class="comment">// 调用 useTest(num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 JS 文件全部导出</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>                  <span class="comment">// 调用 a.test(a.num)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 JS 文件默认导出</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&#x27;./a.js&#x27;</span>           </span><br></pre></td></tr></table></figure>


<h3 id="官方模块"><a href="#官方模块" class="headerlink" title="官方模块"></a>官方模块</h3><p>Node.js 提供了允许直接导入的官方模块，查询网址：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a></p>
<ul>
<li><strong>OS 模块</strong>：系统信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;主机名&#x27;</span> + os.<span class="title function_">hostname</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;操作系统&#x27;</span> + os.<span class="title function_">type</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;系统平台&#x27;</span> + os.<span class="title function_">platform</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;内存总量&#x27;</span> + os.<span class="title function_">totalmem</span>() + <span class="string">&#x27;字节&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可用内存&#x27;</span> + os.<span class="title function_">freemem</span>() + <span class="string">&#x27;字节&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Path 模块</strong>：路径信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;c:/myapp/index.html&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(data));          <span class="comment">// 输出 index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(data));           <span class="comment">// 输出 c:/myapp</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(<span class="title function_">dirname</span>(data))); <span class="comment">// 输出 myapp</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>URL 模块</strong>：URL 信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;http://test.com?name=王东浩&amp;age=22&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(data));             <span class="comment">// 输出 网址解析信息</span></span><br><span class="line"><span class="keyword">var</span> urlQuery = url.<span class="title function_">parse</span>(data, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlQuery.<span class="property">query</span>.<span class="property">name</span>);         <span class="comment">// 输出 王东浩</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>fs 模块</strong>：文件信息</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="string">&#x27;你好，我是王东浩&#x27;</span>, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./a.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(err)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>http / https 模块</strong>：服务器</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.<span class="title function_">createserver</span>();             <span class="comment">// 创建服务器</span></span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>)&#123;      <span class="comment">// 配置监听器，有请求则触发</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;收到用户请求，请求地址&#x27;</span> + req.<span class="property">url</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求方式&#x27;</span> + req.<span class="property">method</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(req.<span class="property">url</span> == <span class="string">&#x27;/&#x27;</span>)&#123; </span><br><span class="line">    $msg = <span class="string">&quot;&lt;a herf=&#x27;www.baidu.com&#x27;&gt;点击跳转&lt;/a&gt;&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    $msg = <span class="string">&quot;404 Not Found&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&#x27;text/html,charset=utf8&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>($msg);</span><br><span class="line">  res.<span class="property">end</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;               <span class="comment">// 启动服务器，监听端口</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;服务启动成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Node-js-项目"><a href="#Node-js-项目" class="headerlink" title="Node.js 项目"></a>Node.js 项目</h2><h3 id="包管理工具-npm"><a href="#包管理工具-npm" class="headerlink" title="包管理工具 npm"></a>包管理工具 npm</h3><p>用于 Node.js 项目的开发和管理，包括安装和卸载第三方模块。是非常强大和常用的 Node.js 工具。下载安装 Node.js 后，即可在控制台使用 npm 命令。</p>
<ul>
<li><strong>初始化项目</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm init -y                       <span class="comment"># 将当前目录初始化为项目，即生成 package.json 配置文件。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>package.json 配置文件负责管理 Node.js 项目。</p>
</blockquote>
<ul>
<li><strong>模块安装</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue/cli               <span class="comment"># 安装指定的 Node.js 模块</span></span><br><span class="line">npm uninstall vue/cli             <span class="comment"># 卸载指定的 Node.js 模块</span></span><br><span class="line"></span><br><span class="line">npm install                       <span class="comment"># 安装该项目 package.json 记录的所有模块</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>node_modules 文件夹负责存储当前 Node.js 项目要使用的模块。</p>
</blockquote>
<p>npm 下载模块时默认安装在本地，只允许当前目录的项目调用。我们可以对模块进行全局安装，允许所有项目调用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue/cli -g            <span class="comment"># 全局安装 Node.js 模块</span></span><br><span class="line">npm uninstall vue/cli -g          <span class="comment"># 全局卸载 Node.js 模块</span></span><br></pre></td></tr></table></figure>

<p>修改和查看 npm 下载地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org install express   <span class="comment"># 临时使用</span></span><br><span class="line"></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">npm config get registry </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>开发环境</strong></li>
</ul>
<p>npm 下载模块时默认为通用模块，可以在全部开发环境下使用。但我们在开发时可能需要引入部分模块，完成后不在生产环境引用。</p>
<p>在项目的 package.json 配置文件中，调用的通用模块会记录在 dependencies 参数中，而开发用模块会记录在 devdependencies 参数中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue/cli --save-dev           <span class="comment"># 安装指定的 Node.js 模块，并标记为开发专用</span></span><br><span class="line"></span><br><span class="line">npm install --production                 <span class="comment"># 安装该项目 package.json 记录的通用模块，但不安装开发用模块</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件-package"><a href="#配置文件-package" class="headerlink" title="配置文件 package"></a>配置文件 package</h3><p>package.json 配置文件负责记录 Node.js 项目信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;example&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="comment">// 项目版本</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 项目描述 </span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;我的 Node 项目&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;app.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 引入模块</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;koa&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;koa-router&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^7.4.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mysql&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.17.1&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 快捷命令</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node app.js&quot;</span>          </span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 作者和凭证</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MrJoker&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>入口文件</strong></li>
</ol>
<p>尝试启动项目时，系统会自动调用根目录下的入口文件执行。默认为 app.js 文件，在项目目录下控制台输入 <code>node app.js</code> 即可运行服务器。</p>
<ol start="2">
<li><strong>快捷命令</strong></li>
</ol>
<p>将 JS 脚本封装为 npm 命令，在项目目录下控制台输入 <code>npm run start</code> 即可运行服务器。</p>
<h3 id="打包工具-webpack"><a href="#打包工具-webpack" class="headerlink" title="打包工具 webpack"></a>打包工具 webpack</h3><p>webpack 是基于 Node.js 的自动化构建工具，对整个项目要请求的静态资源进行合并、封装、压缩、和自动转换。大大加快了请求静态资源页面加载速度，也解决了代码的兼容性问题。</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Restful 接口</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/restful/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Restful-接口"><a href="#Restful-接口" class="headerlink" title="Restful 接口"></a>Restful 接口</h1><p>设计项目资源的 URL</p>
<p> <strong>资源定位</strong></p>
<p>资源集合用一个 URL ，具体某个资源用一个 URL。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/employees         <span class="comment"># 资源集合的URL</span></span><br><span class="line">/employees/56      <span class="comment"># 具体某个资源的URL</span></span><br></pre></td></tr></table></figure>

<p> <strong>资源请求</strong></p>
<p>使用四种 HTTP 方法可以提供CRUD功能：</p>
<ul>
<li>获取：使用GET方法获取资源。</li>
<li>创建：使用POST创建新的资源。</li>
<li>更新：使用PUT更新现有资源。（和 POST 近似）</li>
<li>删除：使用DELETE删除现有资源。（和 GET 近似）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[GET] /employees           <span class="comment"># 获取全部雇员信息</span></span><br><span class="line">[GET] /employees/56        <span class="comment"># 获取指定雇员信息</span></span><br><span class="line">[POST] /employees          <span class="comment"># 提交雇员信息</span></span><br><span class="line">[PUT] /employees/56        <span class="comment"># 修改指定雇员信息</span></span><br></pre></td></tr></table></figure>

<p><strong>请求参数</strong></p>
<p>可选的、复杂的参数用查询字符串表示。<br>使用小驼峰命名法作为属性标识符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /employees?state=external</span><br><span class="line">GET /employees?state=internal&amp;maturity=senior</span><br></pre></td></tr></table></figure>



<p><strong>返回状态码</strong></p>
<p>RESTful Web服务应使用合适的HTTP状态码来响应客户端请求</p>
<p>2xx - 成功 - 一切都很好<br>4xx - 客户端错误 - 如果客户端发生错误（例如客户端发送无效请求或未被授权）<br>5xx – 服务器错误 - 如果服务器发生错误（例如，尝试处理请求时出错）</p>
<p>除了合适的状态码之外，还应该在HTTP响应正文中提供有用的错误提示和详细的描述。这是一个例子。请求：</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%89%8D%E7%AB%AF/vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><hr>
<h2 id="vue-概念"><a href="#vue-概念" class="headerlink" title="vue 概念"></a>vue 概念</h2><h3 id="前端框架"><a href="#前端框架" class="headerlink" title="前端框架"></a>前端框架</h3><p>前端开发进化过程： <strong>原生JS 》jQuery 等类库 》Vue 等前端框架</strong></p>
<ul>
<li>jQuery 等类库提供了已封装好的 JS 方法集合，用户在前端开发中可以直接调用（可以使用多个）。</li>
<li>Vue 等前端框架提供了完整的项目解决方案，用户在前端开发中必须按照特定框架规范进行开发（只能选择一个）。</li>
</ul>
<p>目前主流的前端框架有 Vue 、 React 、 Angular 。</p>
<h3 id="vue-特征"><a href="#vue-特征" class="headerlink" title="vue 特征"></a>vue 特征</h3><p>Vue 主要有以下两大特征：</p>
<ol>
<li>响应式数据绑定：数据发生改变，视图自动更新（开发者不再关注 dom 操作，进一步提高开发效率）。</li>
<li>可组合视图组件：视图按照功能切分成基本单元（易维护，易重用，易测试）。</li>
</ol>
<h3 id="vue-使用"><a href="#vue-使用" class="headerlink" title="vue 使用"></a>vue 使用</h3><ul>
<li><strong>引入外部文件(CDN)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化文件大小和响应速度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>命令行工具(CLI)</strong></li>
</ul>
<p>vue-cli 是基于 Node.js 的 vue 快捷开发工具，使用前首先要下载并安装 Node.js 开发环境。</p>
<ol>
<li>安装脚手架</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install @vue/cli -g          <span class="comment"># 全局安装安装 vue-cli 工具</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@vue/cli</code> 适用于 vue 2.X ，<code>vue-cli</code> 适用于旧版本。</p>
</blockquote>
<ol start="2">
<li>创建项目并使用</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">$ vue create project-name          <span class="comment"># 直接创建项目</span></span><br><span class="line">$ npm run dev                      <span class="comment"># 开发环境启动项目（可配置）        </span></span><br><span class="line">$ npm run build                    <span class="comment"># 运行环境启动项目（可配置）     </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">$ vue ui                           <span class="comment"># 开启图形化工具，用来创建和管理项目</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="vue-对象"><a href="#vue-对象" class="headerlink" title="vue 对象"></a>vue 对象</h2><p>vue 对象是管理 vue 的基本单元，开发者可以在 JS 代码中创建 vue 对象。</p>
<p>在 vue 对象中，必须通过 <code>el</code> 指定 vue 对象作用域。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var app = new Vue(&#123;</span><br><span class="line">      el: &#x27;#app&#x27;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数据显示"><a href="#数据显示" class="headerlink" title="数据显示"></a>数据显示</h3><p>在 vue 对象中，通过 <code>data</code> 存储 vue 对象中的数据。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>              <span class="comment">&lt;!-- v-text --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Word is &#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>          <span class="comment">&lt;!-- 插值表达式：可以对内容进行扩展 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-html</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span>              <span class="comment">&lt;!-- v-html: 可以直接插入 html 元素 --&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 数据</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;Hello Vue&#x27;</span>,         <span class="comment">// 数据</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: []                      <span class="comment">// 数组数据</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">    app.<span class="property">message</span>=<span class="string">&quot;GoodBye Vue.&quot;</span>;       <span class="comment">// vue 对象数据可以被 JS 代码更新</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><ul>
<li>在 vue 对象中，通过 <code>methods</code> 定义 vue 对象中的方法。</li>
<li>在 vue 对象中，通过 <code>computed</code> 定义计算属性，重复调用时会基于缓存直接返回之前的计算结果，提高效率。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;quit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showLog(&#x27;Hello&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span>        </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 方法</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        quit () &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">router</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        showLog (message) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">this</span>.<span class="property">message</span> = message</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      calc (data) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">num</span> + data</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>在 vue 对象中，通过 <code>created</code> 定义方法，会在创建 vue 对象时自动调用。在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>在 vue 对象中，通过 <code>mounted</code> 定义方法，会在创建 vue 对象时自动调用。在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 计算结果 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Word is &#123;&#123; calc(50) &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">num</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 创建方法</span></span></span><br><span class="line"><span class="language-javascript">    created () &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">num</span> = <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 计算属性</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="数据监听"><a href="#数据监听" class="headerlink" title="数据监听"></a>数据监听</h3><p>在 vue 对象中，通过监听器 <code>watch</code> 可以在数据发生变化时触发指定的事件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>: <span class="string">&#x27;MrJoker&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">num</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">a</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">b</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">c</span>: <span class="number">3</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">watch</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 监听一</span></span></span><br><span class="line"><span class="language-javascript">      name (newName, oldName) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(oldName + <span class="string">&#x27;&gt;&gt;&#x27;</span> + newName)</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 监听二</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">num</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">handler</span>(<span class="params">newNum, oldNum</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;num changed&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">immediate</span>: <span class="literal">true</span>,                      <span class="comment">// 创建数据时也会立即执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">deep</span>: <span class="literal">true</span>                            <span class="comment">// 深度监听下属所有数据</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 监听三</span></span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;num.a&#x27;</span>: &#123;      </span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">handler</span>(<span class="params">newName, oldName</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;obj.a changed&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h3><p>在 vue 对象中，通过过滤器 <code>filter</code> 可以对要显示的数据进行修饰。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;message | upper&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>                            <span class="comment">&lt;!-- 方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;id | upper&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>                        <span class="comment">&lt;!-- 方式二 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;id | upper2(2,&#x27;hello&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>            <span class="comment">&lt;!-- 使用过滤器并传递参数 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- vue 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">name</span>:<span class="string">&#x27;Vue&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello Vue&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>: []</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 过滤器</span></span></span><br><span class="line"><span class="language-javascript">    <span class="attr">filter</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">upper</span>: <span class="keyword">function</span>(<span class="params">val</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> val.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + val.<span class="title function_">slice</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 全局过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;upper2&#x27;</span>, <span class="keyword">function</span>(<span class="params">val,arg1,arg2</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg2);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> val.<span class="title function_">charAt</span>(arg1).<span class="title function_">toUpperCase</span>() + val.<span class="title function_">slice</span>(arg1 + <span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="vue-基础"><a href="#vue-基础" class="headerlink" title="vue 基础"></a>vue 基础</h2><h3 id="指令绑定"><a href="#指令绑定" class="headerlink" title="指令绑定"></a>指令绑定</h3><ul>
<li>vue 使用 <code>v-bind</code> 绑定属性，表示该属性内容从 vue-data 中加载。可以用 <code>:</code> 代替。</li>
<li>vue 使用 <code>v-on</code> 绑定事件，表示该事件从 vue-methods 中加载。可以用 <code>@</code> 代替。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">button</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">v-bind:title</span>=<span class="string">&quot;message&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- img 标签的 src 属性使用插值表达式绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;url&#125;&#125;&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 判断是否使用 textColor 和 textSize 类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;&#x27;textColor&#x27;:isColor, &#x27;textSize&#x27;:isSize&#125;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>JS 默认属性均为字符串，但 vue 绑定属性能自动识别数据为数值、布尔型、数组或对象。</em></p>
<p><strong>可绑定事件</strong></p>
<p><code>@click</code> 点击事件</p>
<p><strong>事件修饰符</strong></p>
<p>当父级元素和子级元素被同一个事件触发指令时，会先执行子级元素的指令，再执行父级元素的指令。</p>
<ul>
<li><code>.prevent</code> 阻止事件默认行为（比如超链接点击跳转，表单点击提交）。</li>
<li><code>.stop</code>  阻止冒泡调用，不再执行父级的指令。</li>
<li><code>.capture</code> 捕获调用，先执行父级的指令再执行子级的指令。</li>
<li><code>.self</code> 该指令只有元素本身被点击才执行，不会被子级的指令冒泡调用。</li>
<li><code>.once</code> 事件只触发一次，被触发后该指令无效。</li>
</ul>
<h3 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h3><p>Vue 使用单向绑定机制：后台数据发生改变后，页面显示会自动同步；但如果页面中表单输入发生变化，后台数据不会发生更新。</p>
<p>vue 使用 <code>v-model</code> 实现双向绑定。运用于表单输入元素，输入发生变化后台数据也会实时更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>表单域修饰符</strong></p>
<ul>
<li><code>number</code>  转化为数值</li>
<li><code>trim</code>  去掉首尾空格</li>
<li><code>lazy</code>  鼠标离开输入元素后才更新（验证用户名是否已被使用时常用）</li>
</ul>
<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>对于 布尔数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">existA</span>:<span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">existB</span>:<span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">surface</span>:<span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;existA&quot;</span>&gt;</span>你好，我是A<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;existB&quot;</span>&gt;</span>你好，我是B<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span> <span class="attr">v-show</span>=<span class="string">&quot;surface&quot;</span>&gt;</span>不好意思，A和B都不在<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>v-if: boolean 数据判断是否绘制元素</li>
<li>v-show: boolean 数据判断是否显示 / 隐藏元素</li>
</ul>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>对于 数组数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">list</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">user</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">id</span>:<span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&#x27;王东浩&#x27;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">userList</span>:[</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&#x27;zs1&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>:<span class="number">2</span>, <span class="attr">name</span>:<span class="string">&#x27;zs2&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">id</span>:<span class="number">3</span>, <span class="attr">name</span>:<span class="string">&#x27;zs3&#x27;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>v-for: 迭代显示列表(List)元素</p>
<ul>
<li>普通数组：<code>&lt;p v-for=&quot;(item,index) in list&quot;&gt;索引值是&#123;&#123;i&#125;&#125;，内容为&#123;&#123;item&#125;&#125;&lt;/p&gt;</code></li>
<li>对象键值对：<code>&lt;p v-for=&quot;(val,key,index) in user&quot;&gt;键是&#123;&#123;key&#125;&#125;，内容为&#123;&#123;val&#125;&#125;&lt;/p&gt;</code></li>
</ul>
</li>
</ul>
<p>数组 (item,index) 第一个属性为内容；第二个属性为索引。<br>键值 (val,key,index) 第一个属性为内容；第二个属性为键名；第三个属性为索引。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--对象数组--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">:key</span>=<span class="string">&#x27;user.id&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;user in userList&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.id&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;user.name&#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为方便管理元素，一般需要为每项绑定一个唯一的 key 属性：<br><code>&lt;p v-for=&quot;item in user&quot; :key=&quot;item.id&quot;&gt;用户的名字为&#123;&#123;item.name&#125;&#125;&lt;/p&gt;</code></p>
<p>可以用于循环固定次数：<code>&lt;p v-for=&quot;count in 10&quot;&gt;这是第&#123;&#123;count&#125;&#125;次循环&lt;/p&gt;</code></p>
<h3 id="数组数据更新操作-API"><a href="#数组数据更新操作-API" class="headerlink" title="数组数据更新操作(API)"></a>数组数据更新操作(API)</h3><ul>
<li>push</li>
<li>pop</li>
</ul>
<p>以上操作直接对原有数组进行修改，页面也会随数据变化实时更新。</p>
<ul>
<li>filter</li>
</ul>
<p>以上操作会产生新的数组，返回值需要重新赋值去更新页面。</p>
<p><code>Vue.set(vm.list,1,&#39;new data&#39;)</code> 或者 <code>Vm.$set(vm.list,1,&#39;new data&#39;)</code> </p>
<p>响应式修改数组元素</p>
<hr>
<h2 id="vue-组件"><a href="#vue-组件" class="headerlink" title="vue 组件"></a>vue 组件</h2><p>vue 前端框架的基本功能单元是组件，vue 对象本身也是一个组件（根组件）。</p>
<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p><code>Vue.component</code> 用于声明全局组件（不推荐）。</p>
<p>在 vue 中， <code>template</code> 表示组件模板，即组件要展示的内容。<strong>模板内只能含有一个根元素！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;greet-bar&quot;</span>,&#123;  </span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;大家好，我是&#123;&#123;name&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button value=&quot;改名&quot; v-on:click=&quot;changeName&quot;&gt;&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;王东浩&quot;</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="attr">changeName</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&quot;甘甜&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>全局注册的组件可以直接用在任何的 Vue 根实例 (new Vue) 的模板中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">greet-bar</span>&gt;</span><span class="tag">&lt;/<span class="name">greet-bar</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">greet-bar</span>&gt;</span><span class="tag">&lt;/<span class="name">greet-bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>html 文件元素名和属性名不区分大小写，因此不可采用驼峰形式。但在 vue 组件中可以作为驼峰形式识别，全局组件命名为 GreetBar 也能被读取。</p>
</blockquote>
<h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>为避免用户需要一次性加载过多组件，我们可以定义局部组件，只在指定的 vue 对象中使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> greetA = &#123;</span><br><span class="line">  <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;王东浩&quot;</span>&#125;</span><br><span class="line">  ,</span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;&lt;p&gt;hello &#123;&#123;name&#125;&#125;&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> greetB = &#123;</span><br><span class="line">  <span class="attr">data</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">name</span>:<span class="string">&quot;陈伯言&quot;</span>&#125;</span><br><span class="line">  ,</span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;&lt;p&gt;hello &#123;&#123;name&#125;&#125;&lt;/p&gt;&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在 vue 中声明要调用的组件，就可以在组件内完成调用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">greet-a</span>&gt;</span><span class="tag">&lt;/<span class="name">greet-a</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">greet-b</span>&gt;</span><span class="tag">&lt;/<span class="name">greet-b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">components</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;GreetA&#x27;</span>: <span class="title class_">GreetA</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;GreetB&#x27;</span>: <span class="title class_">GreetB</span></span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// components: &#123; GreetA, GreetB &#125;,  </span></span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="vue-单文件组件-vue"><a href="#vue-单文件组件-vue" class="headerlink" title="vue 单文件组件(.vue)"></a>vue 单文件组件(.vue)</h3><p>在实际项目开发中，我们往往为每一个组件创建一个单独的文件来定义。之间的相互调用统一交由 router 管理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  模板内容 html</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  业务逻辑 export</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  组件样式 css</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="组件交互"><a href="#组件交互" class="headerlink" title="组件交互"></a>组件交互</h2><h3 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h3><p>在 vue 中， <code>props</code> 是单向数据流，用于父组件向子组件传值。</p>
<ol>
<li>在父组件中定义数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">greet-bar</span> <span class="attr">:first-name</span>=<span class="string">&#x27;sname&#x27;</span> <span class="attr">last-name</span> = <span class="string">&#x27;赵四&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">greet-bar</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">data</span>:&#123;<span class="attr">sname</span>:<span class="string">&quot;尼古拉斯&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>子组件读取并显示</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&quot;greet-bar&quot;</span>,&#123;</span><br><span class="line">  <span class="attr">props</span>::[<span class="string">&#x27;first-name&#x27;</span>, <span class="string">&#x27;last-name&#x27;</span>],  <span class="comment">//也可以使用驼峰式接收 firstName</span></span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;大家好，我是&#123;&#123;first-name + &quot;·&quot; + last-name&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  &#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><ul>
<li><strong>子组件定义事件</strong></li>
</ul>
<p>子组件通过触发 <code>$emit</code> 事件向父组件传值。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- $emit 须设定事件标记和传递数值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&#x27;$emit(&quot;son-data&quot;, 0.1)&#x27;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>父组件监听事件</strong></li>
</ul>
<p>父组件文件中放置的子组件，可以根据事件标记监听事件并调用指定的方法处理。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- $event 为传递数值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> @<span class="attr">son-data</span>=<span class="string">&#x27;handle($event)&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可不含，等同于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> @<span class="attr">son-data</span>=<span class="string">&#x27;handle&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>父组件通过调用的方法，保存或使用子组件传来的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">handle</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sonData</span> = data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非父子组件传值"><a href="#非父子组件传值" class="headerlink" title="非父子组件传值"></a>非父子组件传值</h3><p>必须创建一个 vue 对象作为事件中心居中协调，监听两个子组件事件并通过 props 传递给另一个子组件。</p>
<h3 id="组件插槽"><a href="#组件插槽" class="headerlink" title="组件插槽"></a>组件插槽</h3><p>在组件的 template 中添加 <code>&lt;slot&gt;默认内容可选&lt;/slot&gt;</code></p>
<p>可以自动读取 <code>&lt;greet-bar&gt;内容&lt;/greet-bar&gt;</code> 中的内容并展示。</p>
<hr>
<h2 id="vue-前后端交互"><a href="#vue-前后端交互" class="headerlink" title="vue 前后端交互"></a>vue 前后端交互</h2><p>传统的原生 JS 开发和 jQuery 都使用 ajax 实现前后端交互，存在以下两个问题：</p>
<ol>
<li>仍需要处理 dom 操作，操作复杂。</li>
<li>交互为同步操作，可能导致一致性问题。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>:<span class="attr">function</span>:(data)&#123;</span><br><span class="line">    ret = data;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ret);             <span class="comment">// 打印更新后的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ret);                 <span class="comment">// 打印数据，由于同步操作可能数据尚未更新</span></span><br></pre></td></tr></table></figure>

<h3 id="promise-对象"><a href="#promise-对象" class="headerlink" title="promise 对象"></a>promise 对象</h3><p>在 JavaScript 最新版本标准 ES6 中， 定义了 promise 对象获取异步操作的消息。</p>
<ul>
<li>resolve 函数： 将 promise 对象的状态标记为成功。</li>
<li>reject 函数：将 promise 对象的状态标记为失败。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queryData</span>(<span class="params">url</span>)&#123;</span><br><span class="line">  <span class="comment">// 创建 promise 对象</span></span><br><span class="line">  <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(xhr.<span class="property">readyState</span> != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">if</span>(xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> ==<span class="number">200</span>)&#123;</span><br><span class="line">        <span class="comment">// 执行成功，执行 resolve</span></span><br><span class="line">        <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 执行失败，执行 reject</span></span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;服务器错误&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>,url);</span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送请求并获取处理结果</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="comment">// 成功执行前者，返回数据为 data</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">info</span>)&#123;</span><br><span class="line">  <span class="comment">// 失败执行后者，返回数据为 info (可不含)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(info);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>p.then</code> 获取异步正常执行结果</li>
<li><code>p.catch</code> 获取异常信息</li>
<li><code>p.finally</code> 无论正确与否都会触发</li>
</ul>
<p><strong>请求嵌套</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行并通过 then 获取处理结果</span></span><br><span class="line"><span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080/next1&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 执行第二次调用的返回数据</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>
<p><strong>批量处理</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080/data1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080/data2&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="title function_">queryData</span>(<span class="string">&#x27;http://localhost:8080/data3&#x27;</span>);</span><br><span class="line">...</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3]).<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">//所有任务都执行完才能返回结果</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([p1,p2,p3]).<span class="title function_">then</span>(</span><br><span class="line">  <span class="comment">//最先完成者就能返回结果</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="axios-库"><a href="#axios-库" class="headerlink" title="axios 库"></a>axios 库</h3><p>axios 是基于 promise 实现的 http 客户端。作为第三方库，比官方的 fetch 功能更为强大。</p>
<h4 id="引入-axios"><a href="#引入-axios" class="headerlink" title="引入 axios"></a>引入 axios</h4><ol>
<li>直接引入</li>
<li>在 vue ui 图形化工具中引入</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 axios --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--引入 qs , 一般用于处理提交数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/qs/6.7.0/qs.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>一般在 main.js 文件中设定，可作用于全局。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">defaults</span>.<span class="property">timeout</span> = <span class="number">3000</span>;                       <span class="comment">// 超时时间</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">baseURL</span> = <span class="string">&quot;http://localhost:8080&quot;</span>     <span class="comment">// 默认地址</span></span><br><span class="line">axios.<span class="property">defaults</span>.<span class="property">headers</span>[<span class="string">&#x27;mytoken&#x27;</span>] = <span class="string">&#x27;asaffdf123&#x27;</span>     <span class="comment">// 请求头</span></span><br></pre></td></tr></table></figure>

<h4 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h4><ol>
<li><strong>GET / DELETE 请求</strong>：输入 URL 和 params 参数，参数附着在 URL 上。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">params</span>:&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">ret</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ret.<span class="property">data</span>.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>POST / PUT 请求</strong>：输入 URL 和表单数据，数据以 json 形式传递。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>,&#123;</span><br><span class="line">  <span class="attr">uname</span>:<span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>:<span class="number">123456</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">ret</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ret.<span class="property">data</span>.<span class="property">message</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>axios 中的 params与 data 传参的区别:<br>    params 传参，参数以 k=v&amp;k=v 格式放置在 url 中传递。<br>    data 传参，参数会在 form 表单中。</p>
</blockquote>
<p><strong>对于返回响应结果 ret</strong> </p>
<ul>
<li><code>ret.data</code> : 响应返回数据，可读取返回数据中某一具体属性。</li>
<li><code>ret.headers</code> : 响应头信息</li>
<li><code>ret.status</code> : 响应状态码</li>
<li><code>ret.statusText</code> : 响应状态信息</li>
</ul>
<h4 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h4><p>不管是 fetch 和 axios 都是异步发送请求，这是前端界面通用做法。</p>
<p>使用 async/await 可以将 axios 异步请求同步化，async 函数会等待 await 返回数据后再向下执行。</p>
<p>通常放在 try 语句中，如果超时未获得数据则直接进入异常处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> getHistoryData (data) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/api/survey/list/&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">params</span>: data</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tableData</span> = res.<span class="property">data</span>.<span class="property">result</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>表单提交自带校验方法 <code>validate(callback)</code>{ 直接返回 Promise 对象}，默认 valid 为 true 通过。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于 ID 为 addFormRef 的表单</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">addFormRef</span>.<span class="title function_">validate</span>(<span class="keyword">async</span> valid =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!valid) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">$http</span>.<span class="title function_">post</span>(<span class="string">&#x27;adddevice&#x27;</span>, <span class="variable language_">this</span>.<span class="property">addForm</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="property">code</span> !== <span class="number">200</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">message</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(res.<span class="property">message</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure>


<p><strong>拦截器</strong></p>
<p>对请求或者响应进行加工处理。</p>
<ol>
<li>对请求加工处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">intercepter</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">config</span>)&#123;</span><br><span class="line">  <span class="comment">// 首个函数执行拦截修改功能</span></span><br><span class="line">  config.<span class="property">headers</span>.<span class="property">mytoken</span> = <span class="string">&#x27;nihao&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="comment">// 第二个函数 反馈错误信息</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>对响应结果加工处理</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">intercepter</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> data = res.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;,<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="vue-路由"><a href="#vue-路由" class="headerlink" title="vue 路由"></a>vue 路由</h2><h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h3><p>路由的作用：把用户远程请求映射到相应的网络资源。可采用以下两种方式：</p>
<ul>
<li>后端路由：服务器根据用户请求 URL 返回 html 页面，浏览器直接显示。（频繁刷新界面）</li>
<li>前端路由：服务器根据用户请求 URL 返回 json 数据，浏览根据用户触发事件更新 html 页面。（无法记录历史访问）</li>
</ul>
<p>现在主流开发使用基于前端路由的 SPA 技术：整个网站只有一个界面，使用 ajax 技术局部更新界面，同时支持浏览器界面的前进后退操作。</p>
<h3 id="vue-router-插件"><a href="#vue-router-插件" class="headerlink" title="vue router 插件"></a>vue router 插件</h3><p>vue 深度集成了官方路由管理器 vue router。可选【使用用户操作历史或哈希存储历史访问】.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 vue router--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发者在专用的路由 js 文件中定义路由规则。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">User</span> = &#123;...&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Register</span> = &#123;...&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 路由规则</span></span><br><span class="line">  <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">      &#123;<span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/user&#x27;</span>&#125;, <span class="comment">// 重定向</span></span><br><span class="line">      &#123;<span class="attr">path</span>:<span class="string">&#x27;/user&#x27;</span>,<span class="attr">component</span>:<span class="title class_">User</span>&#125;,</span><br><span class="line">      &#123;<span class="attr">path</span>:<span class="string">&#x27;/register&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Register</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">    <span class="title class_">Router</span>: router</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在 vue 组件中，点击 router-link 组件实现页面跳转，预留的 router-view 区域将显示指定组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--路由链接--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/register&quot;</span>&gt;</span>Register<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--路由占位符，显示位置--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Tab1</span> = &#123;...&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Tab2</span> = &#123;...&#125;;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Register</span> = &#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">&#x27;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to=&quot;/register/tab1&quot;&gt;Tab1&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-link to=&quot;/register/tab2&quot;&gt;Tab2&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">        &lt;router-view /&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">      &#123;<span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,<span class="attr">redirect</span>:<span class="string">&#x27;/user&#x27;</span>&#125;, <span class="comment">// 重定向</span></span><br><span class="line">      &#123;<span class="attr">path</span>:<span class="string">&#x27;/user&#x27;</span>,<span class="attr">component</span>:<span class="title class_">User</span>&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&#x27;/register&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Register</span>,</span><br><span class="line">        <span class="attr">children</span>:[</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&#x27;/register/tab1&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Tab1</span>&#125;,</span><br><span class="line">          &#123;<span class="attr">path</span>:<span class="string">&#x27;/register/tab2&#x27;</span>,<span class="attr">component</span>:<span class="title class_">Tab2</span>&#125;</span><br><span class="line">        ]&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;,</span><br><span class="line">    <span class="title class_">Router</span>: router</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>根据参数自动选择路由</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态路径</span></span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,<span class="attr">component</span>: <span class="title class_">User</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态显示内容</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;&lt;div&gt;User &#123;&#123;$route.params.id&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 $route 的方式传参高度耦合，一般使用 props 将组件和路由解耦。还可以对路由路径进行命名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>:[</span><br><span class="line">    &#123;<span class="attr">path</span>:<span class="string">&#x27;/user/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span>,  <span class="comment">// 路由命名</span></span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">User</span>, </span><br><span class="line">    <span class="attr">props</span>:<span class="literal">true</span>&#125;  <span class="comment">// 动态路径</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态显示内容</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">props</span>:[<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">  <span class="attr">template</span>:<span class="string">&#x27;&lt;div&gt;User &#123;&#123;id&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;router-link :to=&quot;&#123;name:&#39;user&#39;,params:&#123;id:3&#125;&#125;&quot;&gt;User&lt;/router-link&gt;</code></p>
<h3 id="路由语句执行"><a href="#路由语句执行" class="headerlink" title="路由语句执行"></a>路由语句执行</h3><h4 id="查询路由信息"><a href="#查询路由信息" class="headerlink" title="查询路由信息"></a>查询路由信息</h4><p>在 vue 组件中，可以通过 <code>$route</code> 查询当前路由的详细信息。在组件内，即 this.$route 。</p>
<p>对于路由 /list/type/11?favorite=yes </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/list/type/:id&#x27;</span>,</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span>,  <span class="comment">// 路由命名</span></span><br><span class="line">  <span class="attr">component</span>: <span class="title class_">User</span>, </span><br><span class="line">  <span class="attr">props</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">path</span><span class="string">`  （字符串）返回绝对路径  $route.path=&#x27;/list/type/11&#x27;</span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">params</span><span class="string">` （对象）动态路径键值对   $route.params.id == 11 </span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">query</span><span class="string">`  （对象）查询参数键值对  $route.query.favorite == &#x27;yes&#x27; </span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">name</span><span class="string">`   （对象）路径名，没有则为空。 $route.name == &#x27;user&#x27;</span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">router</span><span class="string">`    路由规则所属的路由器（以及其所属的组件）。</span></span><br><span class="line"><span class="string">- `</span>$route.<span class="property">matched</span><span class="string">`    数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 执行路由跳转</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在 vue 组件中，可以通过调用全局路由对象 `</span>$router<span class="string">` 查的方法实现页面跳转。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 方法和 &lt;router-link :to=&quot;...&quot;&gt; 等同，执行时跳转指定页面。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;home&#x27;</span>)                                                /home</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)                                      /home</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)               /home?plan=<span class="number">123</span>（附带查询参数）</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">123</span> &#125;&#125;)                  /list/type/<span class="number">123</span>（根据命名跳转可以附带动态路径）</span><br></pre></td></tr></table></figure>


<p>go 方法根据历史记录，跳转上一个或下一个页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(-<span class="number">1</span>)                  返回之前的页面</span><br></pre></td></tr></table></figure>

<p>replace 方法替换当前的页面，和 push 方法的不同在于不会历史记录（一般用于 404 页面）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(<span class="string">&#x27;/&#x27;</span>)</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="vue-项目结构"><a href="#vue-项目结构" class="headerlink" title="vue 项目结构"></a>vue 项目结构</h2><p>vue 项目由上述两种方式自动创建，其项目结构如下：</p>
<ul>
<li><p><strong>node_module 文件夹</strong>  / 依赖包目录</p>
</li>
<li><p><strong>public 文件夹</strong> /  静态资源，外部可直接访问</p>
<ul>
<li><strong>index.html</strong> / 输出界面</li>
<li><strong>favicon.ico</strong> / 图标</li>
</ul>
</li>
<li><p><strong>src 文件夹</strong> / 组件等资源，由静态资源加载</p>
<ul>
<li><strong>asserts 文件夹</strong> / css、img 文件</li>
<li><strong>components 文件夹</strong> / vue 文件</li>
</ul>
</li>
<li><p><strong>plugins 文件夹</strong> / 插件文件</p>
</li>
<li><p><strong>router 文件夹</strong> / 路由文件</p>
</li>
<li><p><strong>App.vue</strong> / 核心组件</p>
</li>
<li><p><strong>main.js</strong> / 入口文件</p>
</li>
</ul>
<p>还有一些其他配置文件，比如项目配置文件 package.json。<br>用户可以创建 vue.config.js 对 vue 进行自定义配置，默认覆盖原配置。</p>
<h2 id="vue-常用插件"><a href="#vue-常用插件" class="headerlink" title="vue 常用插件"></a>vue 常用插件</h2><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p>不用自己画组件，可以使网站快速成型。推荐直接在图形化工具内导入。</p>
<p>导入 element-ui 等桌面组件库，bootstrap 等移动端组件库。</p>
<h3 id="Element-UI-组件库"><a href="#Element-UI-组件库" class="headerlink" title="Element UI 组件库"></a>Element UI 组件库</h3><p>官网：<a href="https://element.eleme.cn/#/zh-CN/component/installation">https://element.eleme.cn/#/zh-CN/component/installation</a></p>
<ol>
<li>安装依赖包 </li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install element-ui -S</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>main.js</code> 导入资源</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>; </span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br></pre></td></tr></table></figure>



<p><code>$</code> 符用来绑定事件。</p>
<p>this.$refs.tree.getCheckedKeys());  </p>
<p>$refs代表一个引用：tree表示组件中某个元素（ref属性设为tree）,然后我们可以通过对象调用方法。</p>
<p><a href="https://www.cnblogs.com/my466879168/p/12091439.html">https://www.cnblogs.com/my466879168/p/12091439.html</a> 局部修改css 样式</p>
<style lang="scss">
@import '../../styles/custom-menu.scss';
  .menu-form .el-form-item__label {
      text-align: left!important;
      font-size: 20px!important;
      color: #000!important;
      font-weight: normal!important;
}
</style>








<p>在属性前加冒号，表示此属性的值是变量或表达式，如果不加，就认为是字符串，所以抛错。!!!!!!!!</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%B7%A5%E5%85%B7/docker/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h3><p>传统应用直接部署在物理服务器的操作系统上，成本高昂、资源闲置、难以迁移和扩展。</p>
<ul>
<li><strong>虚拟化技术</strong></li>
</ul>
<p>隔离底层硬件和上层应用，使物理服务器上可以部署多个虚拟机，每个虚拟机都是一个单独的操作系统，每个应用运行在一个单独的虚拟机中。</p>
<p>资源易调配，易扩展，不用考虑底层机器，很容易上云。</p>
<p>缺点：</p>
<ol>
<li>每一个虚拟机都是一个完整的操作系统，需要分配和消耗资源。</li>
<li>开发和运维使用的语言和工具极多，难以使用和维护。需要打包。 </li>
</ol>
<ul>
<li><strong>容器技术</strong></li>
</ul>
<p>提供了开发、打包、应用 APP 的平台。</p>
<p>将软件和依赖整体打包，在操作系统上划分多个容器，实现了应用之间的隔离，能够运行到任何环境上。</p>
<p>在开发和运维之间搭建了桥梁。</p>
<p>简化配置，打包到容器运行到不同的环境。<br>快速部署</p>
<h3 id="Docker-介绍"><a href="#Docker-介绍" class="headerlink" title="Docker 介绍"></a>Docker 介绍</h3><p>kubernetes(k8s)  容器编排工具 连接 api 和 。。。<br> docker</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%B7%A5%E5%85%B7/git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Git 是用来对代码进行版本管理和多人协作的代码仓库。</p>
<blockquote>
<p>Git 不区分文件名大小写，这在重命名文件时（仅更新文件名大小写）可能会造成隐患。</p>
</blockquote>
<h3 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h3><p><img src="/pic/git.png" alt="git"></p>
<ul>
<li><p><strong>Workspace 工作区</strong> </p>
<p>当前开发者正在进行编写的代码版本。</p>
</li>
<li><p><strong>Index 暂存区</strong> </p>
<p>【目录树结构】记录要进行版本管理的文件名、文件状态信息以及指向文件的索引。</p>
<p>通过使用时间戳、文件长度等状态信息，可以快速判断工作区文件是否被修改。</p>
</li>
<li><p><strong>Repository 仓库区</strong> </p>
<p>【日志结构】记录所有版本提交的历史更改，保存在 Git 对象库（.git/objects）中。</p>
<p>通过读取仓库区，可以将工作区代码回退到任意版本。</p>
</li>
<li><p><strong>Remote 远程仓库</strong></p>
<p>【日志结构】将本地仓库保存在远程服务器中，如 Github/Gitlab/Gitee 等知名第三方代码托管网站。</p>
<p>通过同步远程仓库，可以便捷地进行远程开发和多人协作。</p>
</li>
</ul>
<hr>
<h2 id="初始配置"><a href="#初始配置" class="headerlink" title="初始配置"></a>初始配置</h2><h3 id="安装本地仓库"><a href="#安装本地仓库" class="headerlink" title="安装本地仓库"></a>安装本地仓库</h3><p>点击下方链接下载 Git ，即可通过 Git Bash 工具使用 Git 命令。</p>
<blockquote>
<p>下载地址：<a href="https://git-scm.com/">https://git-scm.com/</a></p>
</blockquote>
<p><em>如果想要直接在控制台使用 git 命令，还需要配置环境变量：在 Path 中添加 Git/cmd 文件夹路径。</em></p>
<h3 id="链接远程仓库"><a href="#链接远程仓库" class="headerlink" title="链接远程仓库"></a>链接远程仓库</h3><p>如果想通过远程仓库托管代码，还需要将本地 Git 链接到第三方的远程仓库中，如 Github/Gitlab/Gitee 等知名第三方代码托管网站。</p>
<blockquote>
<p>Github 官方网址：<a href="https://github.com/">https://github.com/</a></p>
</blockquote>
<p>本地 Git 尝试对远程仓库修改时必须持有密钥，否则远程仓库将拒绝访问。</p>
<p>通过 Git Bash 命令生成本地密钥，然后添加到 Github 账号 SSH and GPG keys 选项中即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;email@example.com&quot;</span>        <span class="comment"># 生成密钥</span></span><br><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub                                <span class="comment"># 将密钥复制到剪切板</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="本地创建"><a href="#本地创建" class="headerlink" title="本地创建"></a>本地创建</h3><p>如果要使用 Git 管理目录内的文件，需要将目录创建为 Git 代码仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init                             <span class="comment"># 在现有目录创建 git </span></span><br><span class="line">git init myProject                   <span class="comment"># 创建子目录并为子目录创建 git</span></span><br></pre></td></tr></table></figure>

<p>为已创建的本地仓库链接远程仓库，每个远程仓库链接都有独立的标识。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:account/project.git      <span class="comment"># 绑定远程仓库，命名为 origin</span></span><br><span class="line">git remote <span class="built_in">rm</span> origin                                          <span class="comment"># 移除远程仓库 origin</span></span><br><span class="line">git remote -v                                                 <span class="comment"># 查看绑定的远程仓库</span></span><br></pre></td></tr></table></figure>

<h3 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h3><p>远程仓库中的项目拥有唯一的标识 SSH: 如 <code>git@github.com:account/project.git</code> 。用户可以直接拷贝到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:account/project.git                  <span class="comment"># 拷贝项目到本地，并自动链接远程仓库</span></span><br></pre></td></tr></table></figure>


<hr>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="暂存文件-add"><a href="#暂存文件-add" class="headerlink" title="暂存文件 add"></a>暂存文件 add</h3><p>需要进行版本管理的代码文件应首先放入暂存区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README.md                          <span class="comment"># 将指定文件放入暂存区</span></span><br><span class="line">git add .                                  <span class="comment"># 将全部文件放入暂存区</span></span><br><span class="line"></span><br><span class="line">git diff                                   <span class="comment"># 查看工作区更新（相对于暂存区）</span></span><br><span class="line">git diff master                            <span class="comment"># 查看工作区更新（相对于 master 分支）</span></span><br><span class="line">git status                                 <span class="comment"># 查看文件是否被暂存或提交</span></span><br><span class="line"></span><br><span class="line">git checkout .                             <span class="comment"># 放弃工作区修改（但不会删除新建文件）</span></span><br><span class="line">git reset HEAD .                           <span class="comment"># 放弃暂存区修改（但不会改变工作区）</span></span><br></pre></td></tr></table></figure>

<p>在执行 add 操作时，开发者往往想要忽略一些特定的文件或目录。</p>
<p>我们可以通过在项目根目录下创建 <code>.gitignore</code> 文件记录忽略项的方式来实现，Git 在执行 add 操作时会自动跳过这些文件。
 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># .gitignore 文件</span></span><br><span class="line"></span><br><span class="line">*.a                         <span class="comment"># 忽略所有 .a 结尾的文件</span></span><br><span class="line">!lib.a                      <span class="comment"># 但 lib.a 除外</span></span><br><span class="line"></span><br><span class="line">/TODO                       <span class="comment"># 忽略项目根目录下的 TODO 文件</span></span><br><span class="line"></span><br><span class="line">node_modules                <span class="comment"># 忽略指定文件夹</span></span><br><span class="line">.project</span><br><span class="line">.vscode</span><br><span class="line"></span><br><span class="line">build/                      <span class="comment"># 忽略 build/ 目录下的所有文件</span></span><br><span class="line">doc/*.txt                   <span class="comment"># 忽略 doc/ 目录下的 txt 文件</span></span><br></pre></td></tr></table></figure>

<p>尽管已更新了 <code>.gitignore</code> 文件，但暂存区仍可能保有历史文件的缓存数据。已提交过的文件如果想取消版本管理，要首先清除缓存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">rm</span> -r --cached .idea                   <span class="comment"># 从暂存区删除文件夹</span></span><br><span class="line">git <span class="built_in">rm</span> -r --cached .                       <span class="comment"># 从暂存区删除全部文件 </span></span><br></pre></td></tr></table></figure>

<h3 id="提交版本-commit"><a href="#提交版本-commit" class="headerlink" title="提交版本 commit"></a>提交版本 commit</h3><p>通过执行 commit 操作，将暂存区中托管的文件数据存储到本地仓库保存。</p>
<p>commit 操作执行完毕后，暂存区数据会被清空。每次 commit 操作前都应执行 add 操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Your commit&quot;</span>                <span class="comment"># 提交文件，放入 git 仓库保存</span></span><br><span class="line"></span><br><span class="line">git diff --staged                          <span class="comment"># 查看当前分支暂存区更新（相对于提交版本）</span></span><br><span class="line">git status                                 <span class="comment"># 查看文件是否被暂存或提交</span></span><br></pre></td></tr></table></figure>

<p>执行 commit 操作后（版本号 A）并尝试 push 到远程仓库，如果远程仓库已经被更新就会遭到拒绝。此时必须通过 pull 获取更新到本地然后合并（版本号 B）才能 push 代码，但是会提交两个版本更新。</p>
<p>此时可以改用 stash 操作对本地更改进行缓存，但不会产生新的提交对象（无论是否 add 默认情况下都会被缓存）。再执行 pull 操作时会直接读取远程仓库的版本，然后通过 stash pop 操作读取缓存并合并（版本号 B）。之后再进行 commit 和 push 操作，就只会提交一个版本更新。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash                                  <span class="comment"># 将更改放入堆栈缓存</span></span><br><span class="line">git stash save <span class="string">&quot;save message&quot;</span>              <span class="comment"># 将更改放入堆栈缓存并命名</span></span><br><span class="line">  </span><br><span class="line">git stash apply                            <span class="comment"># 应用堆栈缓存中的更改但不清除</span></span><br><span class="line">git stash pop                              <span class="comment"># 读取堆栈缓存中的更改</span></span><br><span class="line"></span><br><span class="line">git stash list                             <span class="comment"># 查看堆栈缓存</span></span><br><span class="line">git stash show <span class="string">&quot;save message&quot;</span>              <span class="comment"># 查看指定堆栈缓存</span></span><br><span class="line">git stash clear                            <span class="comment"># 清空堆栈缓存</span></span><br></pre></td></tr></table></figure>


<h3 id="管理分支-branch"><a href="#管理分支-branch" class="headerlink" title="管理分支 branch"></a>管理分支 branch</h3><p>在创建仓库的时候，会默认创建主分支 master。HEAD 则始终指向当前分支。</p>
<p>在开发功能、修复 BUG 时，我们通常都会创建分支来进行操作，直到完成开发后再合并到主分支上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch                                 <span class="comment"># 列出本地分支（HEAD 指向当前分支）</span></span><br><span class="line">git branch -r                              <span class="comment"># 列出远程分支 </span></span><br><span class="line"></span><br><span class="line">git branch <span class="built_in">test</span>                            <span class="comment"># 创建 test 分支（但不切换）</span></span><br><span class="line">git checkout <span class="built_in">test</span>                          <span class="comment"># 切换到 test 分支</span></span><br><span class="line">git checkout -b <span class="built_in">test</span>                       <span class="comment"># 创建并切换到 test 分支</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前分支未被修改时，merge 和 rebase 无区别</span></span><br><span class="line">git merge <span class="built_in">test</span>                             <span class="comment"># test 分支合并到当前分支（将两个分支合并，新建一个 commit）</span></span><br><span class="line">git merge origin/master                    <span class="comment"># origin/master 合并到当前分支   </span></span><br><span class="line">git rebase master                          <span class="comment"># master 分支合并到当前分支（当前分支重新执行另一个分支的全部 commit）</span></span><br><span class="line"></span><br><span class="line">git branch -D <span class="built_in">test</span>                         <span class="comment"># 删除分支</span></span><br></pre></td></tr></table></figure>

<p>当合并分支或者导入远程仓库分支时，常常会出现同一个文件被多个分支修改的情况。这个时候工作区文件会同时记录多个版本的代码，需要开发者通过编辑器解决冲突。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status                                                        <span class="comment"># 查看工作区和缓存区差异</span></span><br><span class="line">git <span class="built_in">log</span> -p master..origin/master                                  <span class="comment"># 查看两分支提交版本之间差异</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>                                                           <span class="comment"># 查看提交历史（会显示 commit ID）</span></span><br><span class="line">git <span class="built_in">log</span> README.txt                                                <span class="comment"># 查看指定文件提交历史（会显示 commit ID）</span></span><br><span class="line"></span><br><span class="line">git reset --hard f687a6de307a598d375bc1b6433dfe667c551f87         <span class="comment"># 版本回退（根据 commit ID）</span></span><br><span class="line">git reset f687a6de307a598d375bc1b6433dfe667c551f87 README.txt     <span class="comment"># 对指定文件版本回退（根据 commit ID）</span></span><br></pre></td></tr></table></figure>


<h3 id="远程同步-push-pull"><a href="#远程同步-push-pull" class="headerlink" title="远程同步 push / pull"></a>远程同步 push / pull</h3><p>本地仓库和远程仓库链接后，且本地 Git 绑定的 GitHub 账户具备对远程仓库的操作权限，用户就可以通过以下指令同步远程代码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin master                                     <span class="comment"># master 分支上传到远程仓库 origin（上传新分支会在远程仓库也创建新分支）</span></span><br><span class="line">git push -f origin master                                     <span class="comment"># master 分支强制上传到远程仓库 origin（适用于版本回退后远程同步）</span></span><br><span class="line"></span><br><span class="line">git pull origin master                                        <span class="comment"># 从远端仓库 origin 获取代码并自动合并到主分支</span></span><br><span class="line">git status                                                    <span class="comment"># 导入后工作区更新，查看和之前版本的差异</span></span><br><span class="line"></span><br><span class="line">git fetch origin master                                       <span class="comment"># 从远端仓库 origin 获取 origin/master 分支</span></span><br><span class="line">git <span class="built_in">log</span> -p master..origin/master                              <span class="comment"># 查看分支差异</span></span><br><span class="line">git merge origin/master                                       <span class="comment"># 合并分支</span></span><br></pre></td></tr></table></figure>


<h3 id="合作开发-fork"><a href="#合作开发-fork" class="headerlink" title="合作开发 fork"></a>合作开发 fork</h3><p>Github 等远程仓库支持多人对同一项目进行协同开发，主要有以下两种形式。</p>
<ul>
<li><p><strong>collaborators 模式</strong></p>
<p>适用于小组合作开发。</p>
<ol>
<li>仓库所有者进入仓库设置，在 Collaborators 选项添加合作者。</li>
<li>合作者有权限对直接对指定的远程仓库进行修改。</li>
</ol>
</li>
<li><p><strong>fork 模式</strong></p>
<p>适用于开源或大型项目。</p>
<ol>
<li><p>开发者选择 Fork 原仓库，复制得到自己持有的镜像仓库。</p>
</li>
<li><p>开发者对镜像仓库进行修改后，可以发送 Pull Request 询问原仓库拥有者是否想要该修改。</p>
</li>
<li><p>原仓库拥有者同意后，镜像仓库的修改会合并到原仓库中。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>协助开发者可以在本地仓库同时链接两个远程仓库：如 origin 自己持有的镜像仓库 &amp; upstream 原始仓库。本地仓库从 upstream 获取代码，更新后上传到 origin 并发送 Pull Request 请求。</p>
</blockquote>
]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E5%B7%A5%E5%85%B7/maven/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><hr>
<h2 id="第三方文件"><a href="#第三方文件" class="headerlink" title="第三方文件"></a>第三方文件</h2><h3 id="Libraries-库"><a href="#Libraries-库" class="headerlink" title="Libraries 库"></a>Libraries 库</h3><p>在 Java 项目开发中，我们需要大量导入其他开发者已经完成的 Java 文件供自己使用。</p>
<p>为便于开发，我们把所有导入的第三方文件放入项目的 Libraries 库中， Java 程序通过 <code>import</code> 语句可以直接调用。</p>
<p><em>指定 JDK 版本和文件储存位置后，JDK 文件也保存在 Libraries 库中。</em></p>
<h3 id="JAR-文件"><a href="#JAR-文件" class="headerlink" title="JAR 文件"></a>JAR 文件</h3><p>(Java Archive File) Java 的一种文档格式。实际是 Java 文件压缩后的 ZIP 文件，又名文件包。</p>
<p>Libraries 库里的第三方文件都是以 jar 文件形式保存，Java 程序导入时会自动解析其中的 Java 代码并使用。</p>
<hr>
<h2 id="Maven-1"><a href="#Maven-1" class="headerlink" title="Maven"></a>Maven</h2><h3 id="Maven-功能"><a href="#Maven-功能" class="headerlink" title="Maven 功能"></a>Maven 功能</h3><p>项目管理工具，为项目自动加载需要的 Jar 包。</p>
<p>用户只需要在配置文件中注明所需要的第三方文件和路径，Maven 会自动将 JAR 文件导入到项目的 Libraries 库中。</p>
<h3 id="Maven-配置"><a href="#Maven-配置" class="headerlink" title="Maven 配置"></a>Maven 配置</h3><p>在 IDEA 的 Settings/Maven 中，可以对 Maven 进行配置：</p>
<ol>
<li><strong>Maven 安装位置</strong>：默认为 IDEA 自带，可配置为本地安装。</li>
<li><strong>XML 配置文件位置</strong></li>
<li><strong>Libraries 库位置</strong></li>
</ol>
<p><img src="/pic/mavenset.png" alt="mavenidea"></p>
<h3 id="XML-文件"><a href="#XML-文件" class="headerlink" title="XML 文件"></a>XML 文件</h3><p>Maven 采用 XML 配置文件来注明项目所需要的第三方文件和路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 父项目坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stream-platform<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.stream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--项目标识符（生成路径）和 构件标识符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.company.stream<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>stream-platform-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置：可在其它位置导入。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">datatables.version</span>&gt;</span>1.10.16<span class="tag">&lt;/<span class="name">datatables.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">font-awesome.version</span>&gt;</span>4.7.0<span class="tag">&lt;/<span class="name">font-awesome.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bootstrap.version</span>&gt;</span>3.3.7<span class="tag">&lt;/<span class="name">bootstrap.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jquery.version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">jquery.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">locator.version</span>&gt;</span>0.32<span class="tag">&lt;/<span class="name">locator.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql-connector.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">mysql-connector.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.13<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">c3p0.version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">c3p0.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.16.20<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 资源仓库：依赖下载地址。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>libs-release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jfrog.cloud.company.domain/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-release-company-maven-release<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>libs-release-company-maven-release<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jfrog.cloud.company.domain/company-maven-cloudservice<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>libs-snapshot<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>libs-snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jfrog.cloud.company.domain/libs-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理：规定依赖的版本、类型等信息，但不会下载依赖。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.webjars<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>datatables<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;datatables.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.promeg<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tinypinyin-lexicons-java-cncity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tinypinyin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zkclient.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 依赖：Maven 将从仓库自动下载以下依赖。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span> </span><br><span class="line">                            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>在 IDEA 界面右侧 MAVEN 选项，可将当前 MAVEN 项目模块发布到本地。 </p>
<p>名称和版本号为 pom.xml 中配置。</p>
<ul>
<li><code>validate</code> 验证项目是否正确以及必须的信息是否可用</li>
<li><code>compile</code> 编译源代码</li>
<li><code>test</code> 测试编译后的代码，即执行单元测试代码</li>
<li><code>package</code> 打包编译后的代码，在target目录下生成package文件(jar)</li>
<li><code>integration-test</code> 处理package以便需要时可以部署到集成测试环境</li>
<li><code>verify</code> 检验package是否有效并且达到质量标准</li>
<li><code>install</code> 安装package到本地仓库，方便本地其它项目使用</li>
<li><code>deploy</code> 部署，拷贝最终的package到远程仓库和替他开发这或项目共享，在集成或发布环境完成</li>
</ul>
<h2 id="maven插件：exec-maven-plugin"><a href="#maven插件：exec-maven-plugin" class="headerlink" title="maven插件：exec-maven-plugin"></a>maven插件：exec-maven-plugin</h2><p>在执行 maven 命令时，我们可能还需要插入 Java 语句或者打包 npm 等，使用exec-maven-plugin 插件可插入。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>exec-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;exec.maven.plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>npm install<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    <span class="comment">&lt;!-- 指令标识 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>   <span class="comment">&lt;!-- Java 还是 exec --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 要执行的命令 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executable</span>&gt;</span>npm<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arguments</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">argument</span>&gt;</span>install<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">argument</span>&gt;</span>--verbose<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>npm run build<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executable</span>&gt;</span>npm<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">arguments</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">argument</span>&gt;</span>run<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">argument</span>&gt;</span>build<span class="tag">&lt;/<span class="name">argument</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">arguments</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其它</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><hr>
<h2 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h2><h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a>服务器类型</h3><p>服务器根据静态和动态加载数据，分为 web 服务器和应用服务器两种。</p>
<h4 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h4><p>提供代理服务，负责接收 HTTP 请求并返回 HTTP 响应。</p>
<p><strong>web 服务器可以访问本地磁盘上所有的资源文件，但不能对 HTTP 请求/响应进行动态加载！</strong> web 服务器接收的 HTTP 资源请求路径必须是固定且明确的，如指向服务器根路径下的 index.html 。web 服务器数据会直接把 index.html 的数据装入 HTTP 响应返回，而不能对其进行修改。</p>
<h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a><strong>应用服务器</strong></h4><p>对远程请求进行逻辑处理，读取 HTTP 请求参数、将后台数据动态加载到页面中。</p>
<p><strong>应用服务器只能访问部署在服务器中的项目资源文件，用来实现对 HTTP 请求/响应的动态加载。</strong> web 服务器接收到路径不固定的 HTTP 请求后（不指向某个具体的文件），应用服务器可以对其进行解析并进行相应的逻辑处理。应用服务器往往在读取后端数据后通过 JSP 等技术对页面实现动态修改，再交给 web 服务器将数据装入 HTTP 响应返回。</p>
<blockquote>
<p>通过 Java 语言实现动态加载的服务器，底层对数据库数据的调用都是通过 servlet 技术实现，因此也叫做 servlet 引擎。</p>
</blockquote>
<h3 id="常用服务器"><a href="#常用服务器" class="headerlink" title="常用服务器"></a>常用服务器</h3><ul>
<li><strong>Apache</strong> </li>
</ul>
<p>最经典的 web 服务器，用于接收 HTTP 请求并返回 HTTP 响应。</p>
<p>由于 web 服务器只能返回静态数据，如果想要根据后端语言对页面进行动态修改，需要安装 PHP/Java 等语言的 Apache 插件。</p>
<ul>
<li><strong>Tomcat</strong> </li>
</ul>
<p>目前最常使用的 Java web 应用服务器，支持 Java 语言在后端对页面进行动态加载。</p>
<p>免费易用、生态完善。且内置了 Apache 服务器，可以直接部署并使用。</p>
<ul>
<li><strong>Jetty</strong> </li>
</ul>
<p>轻量级的 Java web 应用服务器，适合处理长连接。常用于移动端 APP 开发应用服务器。</p>
<ul>
<li><strong>基于 Netty 技术自研</strong></li>
</ul>
<p>满足对性能、实时性、并发的特殊需求。如实时聊天服务器、视频云平台服务器。</p>
<ul>
<li><strong>Nginx</strong></li>
</ul>
<p>性能优异的 web 服务器。常用于和其它应用服务器协同，负责缓存静态文件、负载均衡和反向代理，缓解应用服务器的负载压力。</p>
<hr>
<h2 id="Tomcat-服务器"><a href="#Tomcat-服务器" class="headerlink" title="Tomcat 服务器"></a>Tomcat 服务器</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>Tomcat 是最著名的 java web 应用服务器，支持用 java 语言对返回页面进行动态处理。但现在一般使用前后端分离的方式，只返回数据。</p>
<ol>
<li>Spring Boot 内置 Tomcat 服务器，直接运行启动器即可。</li>
</ol>
<h2 id="常用服务器-1"><a href="#常用服务器-1" class="headerlink" title="常用服务器"></a>常用服务器</h2><p>一般在web项目开发 中，apache+tomcat+nginx联合使用，访问静态资源时用apache解析，访问动态资源时用tomcat解析，nginx作为反向代理服务器，同时支持高并发。</p>
<p>apache 是最常见的 web 服务器。不能动态处理页面！如果想脱离应用服务器直接使用，必须通过安装 php 插件等其他方式来修改页面。</p>
<p>nginx 是 Apache 提供的 web 服务器，nginx是一款高性能、轻量级的web服务器和反向代理服务器以及邮件代理服务器。支持高并发，并发量50000 。nginx不能解析动态的jsp页面。</p>
]]></content>
      <categories>
        <category>其它</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%9C%8D%E5%8A%A1%E5%99%A8/nginx/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>其它</category>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL1</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL-概念"><a href="#MySQL-概念" class="headerlink" title="MySQL 概念"></a>MySQL 概念</h1><hr>
<h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h2><p>MySQL 是一种关系型数据库。开源免费，并且方便扩展。在 Java 开发中常用于保存和管理数据。默认端口号 3306。</p>
<p>MySQL 数据库主要分为 Server 和存储引擎两部分，现在最常用的存储引擎是 InnoDB。</p>
<hr>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>MySQL 数据库接收到用户指令后，首先由 Server 负责对数据操作的分析、处理和优化，再交给存储引擎执行数据存取操作。</p>
<h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器负责用户登录数据库时的身份认证，校验账户密码。校验通过后连接器会连接到权限表，并读取该用户的所有权限。如果连接未断开，即使该用户权限被管理员修改也不受影响。</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><del>查询缓存</del></h3><p>缓存 SELECT 语句以及返回的结果。收到查询语句会首先和缓存比对，如果相同就直接从查询缓存里返回数据。</p>
<p>更新表后，这个表上的所有的查询缓存都会被清空。这导致实际使用场景中查询缓存的作用非常少，在 MySQL 8.0 版本后移除。</p>
<h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>如果查询语句未命中缓存，或者是更新语句，那么将由分析器负责分析 SQL 语句的用途。</p>
<ol>
<li><p>词法分析：提取关键字，提取 SQL 语句的关键元素，明确 SQL 语句的功能。</p>
</li>
<li><p>语法分析：判断 SQL 语句是否正确，是否符合 MySQL 的语法。如果不符合语法则返回错误信息。</p>
</li>
</ol>
<h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>明确 SQL 语句功能后，由优化器负责选择尽可能最优的执行方案。比如多个索引的时候选择索引，多表查询的时候选择关联顺序。</p>
<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>确定执行方案后，由执行器负责校验该用户有没有权限，并交由存储引擎执行语句，然后从存储引擎返回数据。</p>
<hr>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>实际执行对数据库数据的存取。目前 MySQL 默认使用 InnoDB 引擎。相比于过去使用 MyISAM 引擎，有以下几个优势：</p>
<ol>
<li>索引：数据文件本身是主索引。</li>
<li>外键：支持外键。</li>
<li>事务：添加本地日志，支持安全恢复；支持行级锁，提高并发度。</li>
<li>并发：支持多版本并发控制，提升性能。</li>
</ol>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>MySQL 数据库使用以下两种数据结构存储和查找数据：</p>
<ol>
<li><strong>B+ 树</strong>：（默认）适用于连续查询多条数据。</li>
<li><strong>哈希表</strong>：适用于查询单条数据。</li>
</ol>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>索引名称|索引类型|字段类型|备注<br>-|-|-<br>PRIMARY KEY|主索引|主键|字段值不能重复，也不能为空。<br>INDEX|普通索引|自定义字段|无，效率低。<br>UNIQUE|唯一索引|自定义字段|字段值不能重复，效率高。<br>FULLTEXT|文本索引|自定义字段|无，用于文本检索。</p>
<ul>
<li><strong>主索引</strong></li>
</ul>
<p>在 InnoDB 存储引擎中数据文件本身就是主索引（聚簇索引）：数据以 B+ 树形式存储，根据主键值进行排序。</p>
<p>我们可以为其他字段建立辅助索引（非聚簇索引），以提高对字段的查询速度，但同时会降低表的更新速度。在辅助索引中记录主键值而不是字段地址：根据辅助索引查找后，仍需要根据主键值在主索引中查询数据。</p>
<ul>
<li><strong>组合索引</strong></li>
</ul>
<p>索引内可以包含多个字段，N 个字段的组合索引实际建立了 N 个索引。</p>
<p>对 a/b/c 三个字段建立的组合索引，实际会先在 a 索引中查找，再到 a/b 索引中查找，最后在 a/b/c 索引中查找。</p>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是一个虚拟表，不实际存储数据。其内容会通过查询其他表得到，在引用视图时动态生成。</p>
<ol>
<li>权限管理：表的权限管理不能限制到具体的行和列，但通过视图则可以限制用户能得到的结果集。</li>
<li>数据独立：表的结构发生变化，不会对用户使用视图查询到的数据产生影响。</li>
</ol>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>从表通过外键关联到主表的主键，建立数据表之间的关系。</p>
<ul>
<li>优点：保障数据的一致性和完整性。</li>
<li>缺点：增加数据之间的耦合度，难以集群。<strong>因此不推荐使用外键。</strong></li>
</ul>
<h4 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h4><p>对主表的数据进行 UPDATE/DELETE 操作时，将会会影响到关联的从表。</p>
<table>
<thead>
<tr>
<th>外键模式</th>
<th>删除策略</th>
</tr>
</thead>
<tbody><tr>
<td>RESTRICT</td>
<td>（默认）从表有相关数据时，主表不能更新/删除。</td>
</tr>
<tr>
<td>CASCADE</td>
<td>主表记录更新/删除时，从表相关记录也会被更新/删除。</td>
</tr>
<tr>
<td>SET NULL</td>
<td>主表数据更新/删除时，从表相关记录的外键值被设为 NULL。</td>
</tr>
<tr>
<td>NO ACTION</td>
<td>啥也不做</td>
</tr>
</tbody></table>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>当数据库数据发生更改时，用日志记录数据库操作。当发生错误或者冲突时，可以进行回滚。保证数据的一致性。</p>
<h4 id="bin-log-归档日志"><a href="#bin-log-归档日志" class="headerlink" title="bin log 归档日志"></a>bin log 归档日志</h4><p>最开始 MySQL 并没与 InnoDB 引擎，其他存储引擎只有通用的 bin 日志用来归档（位于 server 层）。</p>
<p>InnoDB 引擎完成主存数据更新后向执行器提交，由 bin 日志记录操作。如果主存数据已更新，且 bin 日志没有被写入时数据库崩溃，后续进行机器备份的时候就会丢失原有数据。这导致数据没有安全恢复的能力：一旦数据库发生异常重启，之前提交的记录都会丢失。</p>
<h4 id="redolog-重做日志"><a href="#redolog-重做日志" class="headerlink" title="redolog 重做日志"></a>redolog 重做日志</h4><p>MySQL 引入 InnoDB 引擎后，自带了 redo 日志。用于数据库发生异常重启时系统记录的恢复。</p>
<ol>
<li>InnoDB 引擎完成主存数据更新但还未提交时，由 redo 日志记录操作并进入 prepare 状态。</li>
<li>InnoDB 引擎向执行器提交时，由 bin 日志记录操作。</li>
<li>提交完成后执行器通知 InnoDB 引擎，redo 日志进入 commit 状态。</li>
</ol>
<p>如果 bin 日志没有被写入时数据库崩溃，后续进行机器备份的时候就会按照 redo 日志恢复数据。</p>
<p>如果 bin 日志已经写完但 redo 日志还处于 prepare 状态时数据库崩溃。MySQL 会判断 redo 日志是否完整，如果完整就立即提交。否则再判断 bin 日志是否完整，如果完整就提交 redo 日志，不完整就回滚事务。这样就解决了数据一致性的问题。</p>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。保障数据之间的同步。</p>
<h3 id="事务特性-ACID"><a href="#事务特性-ACID" class="headerlink" title="事务特性 ACID"></a>事务特性 ACID</h3><ul>
<li><strong>原子性</strong>： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性</strong>： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="并发事务潜在问题"><a href="#并发事务潜在问题" class="headerlink" title="并发事务潜在问题"></a>并发事务潜在问题</h3><ul>
<li><strong>丢失修改</strong></li>
</ul>
<p>事务（T1）修改数据的过程中，另一个并发事务（T2）也修改了该数据。导致事务（T1）对数据的修改丢失。</p>
<ul>
<li><strong>脏读</strong></li>
</ul>
<p>事务（T1）修改数据但还未写入数据库时，另一个并发事务（T2）使用了该数据。导致事务（T2）读取数据可能是不正确的。</p>
<ul>
<li><strong>不可重复读</strong></li>
</ul>
<p>事务（T1）两次读取数据的过程中，另一个并发事务（T2）修改了该数据。导致事务（T1）两次读取数据的结果不同。</p>
<ul>
<li><strong>幻读</strong></li>
</ul>
<p>事务（T1）两次读取数据集合的过程中，另一个并发事务（T2）插入或删除了部分数据。导致事务（T1）两次读取数据的结果不同。</p>
<h3 id="数据锁"><a href="#数据锁" class="headerlink" title="数据锁"></a>数据锁</h3><p>存储引擎通过给数据加锁来保障事务性。MyISAM 引擎只支持表级锁，而 InnoDB 存储引擎支持行级锁和表级锁，默认为行级锁。</p>
<ul>
<li><p><strong>表级锁</strong>：对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。但触发锁冲突的概率最高，并发度低。</p>
</li>
<li><p><strong>行级锁</strong>：只针对当前操作的数据行加锁。大大减少数据库操作的冲突，并发度高。但加锁的开销也最大，可能会出现死锁。</p>
</li>
</ul>
<p>InnoDB支持三种行锁定方式：</p>
<ul>
<li><strong>间隙锁</strong>：锁定索引的记录间隙，确保索引记录的间隙不变。</li>
</ul>
<p>Next-Key Lock 是行级锁和间隙锁的组合使用。当 InnoDB 扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。其他事务就不能在这个间隙修改或者插入记录。间隙锁是针对事务隔离级别为可重复读或以上级别，可以有效防止幻读的发生。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><ul>
<li><strong>READ-UNCOMMITTED(RU) 读取未提交</strong> </li>
</ul>
<p>事务进行读操作时允许其他事务访问，事务进行写操作将会禁止其他事务写。</p>
<ul>
<li><strong>READ-COMMITTED(RC) 读取已提交</strong></li>
</ul>
<p>事务进行读操作时允许其他事务访问，事务进行写操作将会禁止其他事务读写。</p>
<ul>
<li><strong>REPEATABLE-READ(RR) 可重复读</strong></li>
</ul>
<p>事务进行读操作时会禁止其他事务写，事务进行写操作将会禁止其他事务读写。</p>
<ul>
<li><strong>SERIALIZABLE 可串行化</strong></li>
</ul>
<p>事务进行读写操作时，都会禁止其他事务读写。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失修改</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>READ-UNCOMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<ol>
<li>InnoDB 存储引擎默认支持的隔离级别是 REPEATABLE-READ(RR) ，且 InnoDB 在该事务隔离级别下使用 Next-Key Lock 锁算法，可以避免幻读。</li>
<li>InnoDB 存储引擎在分布式事务情况下一般会用到 SERIALIZABLE 隔离级别。</li>
</ol>
<hr>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="MVCC-概念"><a href="#MVCC-概念" class="headerlink" title="MVCC 概念"></a>MVCC 概念</h3><p>MVCC 即多版本并发控制，维持一个数据的多个版本，使得读写操作没有冲突。从而提高数据库并发性能，做到即使有读写冲突时，也能不加锁非阻塞并发读。</p>
<p>是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。</p>
<h3 id="读类型"><a href="#读类型" class="headerlink" title="读类型"></a>读类型</h3><ul>
<li>当前读</li>
</ul>
<p> 读取的是记录最新版本，同时会对读取的记录进行加锁保证其他并发事务不能修改<br>select lock in share mode(共享锁), select for update ; update, insert ,delete</p>
<ul>
<li>快照读</li>
</ul>
<p>可能读到的是数据之前的历史版本.在很多情况下，避免了加锁操作，降低了开销；</p>
<p>像不加锁的select操作就是快照。但如果隔离级别是最高级串行化，快照读会退化成当前读。</p>
<h3 id="MVCC-实现"><a href="#MVCC-实现" class="headerlink" title="MVCC 实现"></a>MVCC 实现</h3><p>在 InnoDB 存储引擎中，每行记录除了我们自定义的字段外，还会隐式记录：</p>
<ol>
<li>最近修改：记录创建这条记录/最后一次修改该记录的事务ID</li>
<li>回滚指针：指向这条记录的上一个版本，存储于 rollback segment 里。</li>
<li>隐藏主键：如果数据表没有主键，InnoDB 会自动产生一个自增的聚簇索引。</li>
<li>删除标记：标记该记录是否已被删除。</li>
</ol>
<p>事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。</p>
<p>InnoDB 会根据读取事务 ID 判断应该都什么时间段的数据。</p>
<p>在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View。</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>常用的字符串类型有定长字符串 CHAR 和变长字符串 VARCHAR 两种，必须用数字注明可容纳的字符数。</p>
<ul>
<li>CHAR(n) 表示固定容纳 n 个字符，当少于 n 个字符时，会使用空格填充。</li>
<li>VARCHAR(n) 表示最多容纳 n 个字符，当少于 n 个字符时不会补空。起始位和结束位需要额外 3 字节。</li>
</ul>
<blockquote>
<p>英文字母单个字符占 1 字节。汉字单个字符 UTF-8 编码占 3 字节，GBK 编码占 2 字节。</p>
</blockquote>
<p>对于长字符串数据可以用 TEXT 或 BLOB 类型存储，固定占用 65535 字节。其中 TEXT 保存文本格式，BLOB 保存二进制格式。如果需要存储更短或更长的字符串类型数据，可以使用 TEXT/BLOB 的扩充类型：如 TINYTEXT、MEDIUMTEXT 和 LONGTEXT。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>大小（字节）</th>
<th>数据库类型</th>
<th>JAVA 类型</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(n)</td>
<td>N(0-255)</td>
<td>CHAR</td>
<td>String</td>
</tr>
<tr>
<td>VARCHAR(n)</td>
<td>N+3(0-65535)</td>
<td>VARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>TEXT</td>
<td>65535</td>
<td>VARCHAR</td>
<td>String</td>
</tr>
<tr>
<td>BLOB</td>
<td>65535</td>
<td>BLOB</td>
<td>byte[]</td>
</tr>
</tbody></table>
<p>CHAR 类型最大只能容纳 255 字节数据，已不推荐使用。目前 VARCHAR 支持容纳最大 65535 字节数据，且长度不固定能有效节省数据库空间，推荐尽量使用 VARCHAR 数据类型取代 TEXT。</p>
<p>TEXT/BLOB 等大数据类型不支持 MySQL 内存临时表，进行排序等操作必须在磁盘中进行。尽量不要使用，一定要用建议单独建表。</p>
<h3 id="整型-amp-浮点型"><a href="#整型-amp-浮点型" class="headerlink" title="整型 &amp; 浮点型"></a>整型 &amp; 浮点型</h3><h4 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h4><p>布尔型数据用 BIT 表示。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>大小（字节）</th>
<th>取值</th>
<th>JAVA 类型</th>
</tr>
</thead>
<tbody><tr>
<td>BIT</td>
<td>1</td>
<td>0 or 1</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整形数据一般用 INT/INTEGER 表示，固定占用 4 字节。如果需要存储更短或更长的整型数据，可以使用 INT 的扩充类型：如 TINYINT、SMALLTEXT 和 MEDIUMTEXT 和 BIGINT。</p>
<p>在声明整型数据时也可以注明显示位宽，如 int(n)。在整形数据不足 n 位时会自动补零，几乎没有任何用处。</p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>大小（字节）</th>
<th>表示范围</th>
<th>JAVA 类型</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>(-128，127)    (0，255)</td>
<td>Integer</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>(-32 768，32 767)(0，65 535)</td>
<td>Integer</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>(-8 388 608，8 388 607)(0，16 777 215)</td>
<td>Integer</td>
</tr>
<tr>
<td>INT/INTEGER</td>
<td>4</td>
<td>(-2 147 483 648，2 147 483 647)    (0，4 294 967 295)</td>
<td>Integer</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>非常大</td>
<td>BigInteger</td>
</tr>
</tbody></table>
<h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>常用的浮点型数据类型有 FLOAT/DOUBLE ，FLOAT 类型固定占用 4 字节，DOUBLE 类型固定占用 8 字节。但 FLOAT/DOUBLE 只是近似存储，在数据库中我们常用 DECIMAL 类型记录金额，在数据库中实际以字符串形式存储，以确保不会产生任何误差。</p>
<ul>
<li>DECIMAL(M,D) M 表示最大位数，D 表示小数点右侧的位数。如 DECIMAL(5,2) ，小数点前 3 位，小数点后 2 位。</li>
</ul>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>大小（字节）</th>
<th>表示范围</th>
<th>JAVA 类型</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>4</td>
<td></td>
<td>Float</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td></td>
<td>Double</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>M + 2</td>
<td></td>
<td>BigDecimal</td>
</tr>
</tbody></table>
<h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><p>java.sql 包内有专用 Java 类型匹配，注意数据类型必须是 <code>java.sql.Date</code>，而不是 <code>java.util.Date</code> 。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小（字节）</th>
<th>格式</th>
<th>表示范围</th>
<th>JAVA 类型</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>1</td>
<td><code>YYYY</code></td>
<td><code>1901/2155</code></td>
<td>Date</td>
</tr>
<tr>
<td>DATE</td>
<td>3</td>
<td><code>YYYY-MM-DD</code></td>
<td><code>1000-01-01/9999-12-31</code></td>
<td>Date</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td><code>HH:MM:SS</code></td>
<td><code>-838:59:59&#39;/&#39;838:59:59</code></td>
<td>Time</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4</td>
<td><code>YYYY-MM-DD HH:MM:SS</code></td>
<td><code>1970-01-01 00:00:00/2038-1-19 11:14:07</code></td>
<td>Timestamp</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td><code>YYYY-MM-DD HH:MM:SS</code></td>
<td><code>1000-01-01 00:00:00/9999-12-31 23:59:59</code></td>
<td>Timestamp</td>
</tr>
</tbody></table>
<h3 id="枚举-amp-集合"><a href="#枚举-amp-集合" class="headerlink" title="枚举 &amp; 集合"></a>枚举 &amp; 集合</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab(  </span><br><span class="line">   gender enum(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;remale&#x27;</span>,<span class="string">&#x27;secret&#x27;</span>)            <span class="comment">-- gender 属性为枚举类型</span></span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="string">&#x27;remale&#x27;</span>);  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab <span class="keyword">where</span> gender<span class="operator">=</span><span class="number">2</span>;                  <span class="comment">-- 两者等价</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tab <span class="keyword">where</span> gender<span class="operator">=</span> <span class="string">&#x27;remale&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>记录字符串，但底层数据实际以2个字节的整型(smallint)保存。</p>
<p>在已知的值中进行单选。最大数量为65535.按保存的位置顺序，从1开始逐一递增。</p>
<p>NULL值的索引是NULL。空字符串错误值的索引值是0。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab(  </span><br><span class="line">   gender <span class="keyword">set</span>(<span class="string">&#x27;male&#x27;</span>,<span class="string">&#x27;remale&#x27;</span>,<span class="string">&#x27;secret&#x27;</span>)            <span class="comment">-- gender 属性为集合类型</span></span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tab <span class="keyword">values</span> (<span class="string">&#x27;male&#x27;</span>, <span class="string">&#x27;remale&#x27;</span>);  </span><br></pre></td></tr></table></figure>

<p>记录字符串，但底层数据实际以8个字节的整型(bigint)保存。</p>
<p>在已知的值中进行多选。最多有 64 个成员。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 flag 字段包含 a,b 的字段</span></span><br><span class="line">mysql <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> FIND_IN_SET(<span class="string">&#x27;a,d&#x27;</span>, flag);</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>其它</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL2</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL-指令"><a href="#MySQL-指令" class="headerlink" title="MySQL 指令"></a>MySQL 指令</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="SQL-指令"><a href="#SQL-指令" class="headerlink" title="SQL 指令"></a>SQL 指令</h3><p>SQL 指令是用于访问和处理数据库的标准的计算机语言。对于 MySQL 等常用数据库都可以通过使用 SQL 访问和处理数据系统中的数据。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>SQL 对大小写不敏感。</li>
<li>标识符应避免与关键字重名！可用反引号（`）为标识符包裹。</li>
<li>注释<ul>
<li>单行注释： <code># 注释内容</code></li>
<li>多行注释： <code>/* 注释内容 */</code></li>
<li>单行注释： <code>-- 注释内容</code> </li>
</ul>
</li>
<li>模式通配符<ul>
<li>匹配任意单个字符： <code>_</code></li>
<li>匹配任意数量字符，包括 0 个：<code>%</code></li>
<li>单引号需要进行转义： <code>\&#39;</code> </li>
</ul>
</li>
<li>清除已有语句：<code>\c</code></li>
</ol>
<hr>
<h2 id="服务指令"><a href="#服务指令" class="headerlink" title="服务指令"></a>服务指令</h2><h3 id="启动-终止服务"><a href="#启动-终止服务" class="headerlink" title="启动/终止服务"></a>启动/终止服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql           <span class="comment"># 启动本机 MySQL 运行</span></span><br><span class="line">net stop mysql            <span class="comment"># 终止本机 MySQL 运行</span></span><br></pre></td></tr></table></figure>

<h3 id="连接-断开服务"><a href="#连接-断开服务" class="headerlink" title="连接/断开服务"></a>连接/断开服务</h3><p>MySQL 服务运行时，输入连接指令即可连接 MySQL 数据库。</p>
<p>需要输入的属性分别为 (h)IP 地址、(P)端口号、(u)用户名、(p)密码。 端口号若为 3306 可省略，密码可空缺。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地连接</span></span><br><span class="line">mysql -h localhost -u root -p </span><br><span class="line"></span><br><span class="line"><span class="comment"># 远程连接</span></span><br><span class="line">mysql -h 10.0.0.51 -P 3306 -u root -p 123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开连接</span></span><br><span class="line">mysql&gt; <span class="built_in">exit</span></span><br><span class="line">mysql&gt; quit</span><br><span class="line">mysql&gt; /p</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="管理指令"><a href="#管理指令" class="headerlink" title="管理指令"></a>管理指令</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>MySQL 数据库的全部用户信息保存在 <code>mysql 库 / user 表</code>内，用户含有以下属性：</p>
<ul>
<li><strong>user 属性</strong>：用户名</li>
<li><strong>host 属性</strong>：允许用户登入的网络</li>
<li><strong>authentication_string 属性</strong>：密码</li>
</ul>
<h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><p>能够对用户进行增删改查操作，需要当前用户拥有非常高的数据库权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加用户(CREATE)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;&#x27;</span>;                <span class="comment">-- 创建用户 boy 允许从本地网络登录</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;girl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;          <span class="comment">-- 创建用户 girl 允许从特定网络登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户(DROP)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;girl&#x27;</span>@<span class="string">&#x27;10.0.0.%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改用户(ALTER)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名用户(RENAME)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> RENAME <span class="keyword">USER</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">TO</span> <span class="string">&#x27;man&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置密码</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>);                              <span class="comment">-- 为当前用户设置密码</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>);        <span class="comment">-- 为指定用户设置密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询全部用户信息(DESC/SELECT)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> mysql.user;                                            </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">user</span>,host,authentication_string <span class="keyword">FROM</span> mysql.user     </span><br></pre></td></tr></table></figure>


<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><p>用户权限分为非常多种，包括全局权限、库权限、表权限、列权限等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 赋予权限(GRANT)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span>             <span class="comment">-- 赋予用户选择插入权限（所有库的所有表）</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>                   <span class="comment">-- 不存在将新建用户</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>                 </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;                     <span class="comment">-- （可选）允许用户转授权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤消权限(REVOKE)</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">REVOKE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> <span class="string">&#x27;boy&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看权限</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> Host,<span class="keyword">User</span>,Select_priv,Grant_priv</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> mysql.user</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;testUser&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><p>MySQL 内划分为多个互相独立的数据存储区域，调用数据库指令时必须提前声明要使用的数据库。</p>
<ul>
<li><strong>数据库选项信息</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CHARACTER SET</td>
<td>编码方式</td>
<td>默认为 utf8mb4</td>
</tr>
<tr>
<td>COLLATE</td>
<td>校对规则</td>
<td>默认为 utf8mb4_general_ci</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有数据库</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进入/切换数据库</span></span><br><span class="line">mysql<span class="operator">&gt;</span> USE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前数据库</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] mydb;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] mydb <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> DATABASE [IF <span class="keyword">EXISTS</span>] mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据库选项信息</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE mydb;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据库选项信息</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> DATABASE mydb <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8;</span><br></pre></td></tr></table></figure>

<h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><ul>
<li><strong>表属性</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>CHARSET</td>
<td>字符集</td>
<td>默认使用数据库字符集</td>
</tr>
<tr>
<td>ENGINE</td>
<td>存储引擎</td>
<td>默认为 InnoDB</td>
</tr>
<tr>
<td>DATA DIRECTORY</td>
<td>数据文件目录</td>
<td></td>
</tr>
<tr>
<td>INDEX DIRECTORY</td>
<td>索引文件目录</td>
<td></td>
</tr>
<tr>
<td>COMMENT</td>
<td>表注释</td>
<td></td>
</tr>
</tbody></table>
<p><em>如果表标记为 TEMPORARY 则为临时表，在连接断开时表会消失。</em></p>
<ul>
<li><strong>列属性</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>主键</td>
<td>标识记录的字段。可以为字段组合，不能为空且不能重复。</td>
</tr>
<tr>
<td>INDEX</td>
<td>普通索引</td>
<td>可以为字段组合，建立普通索引。</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一索引</td>
<td>可以为字段组合，不能重复，建立唯一索引。</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>非空</td>
<td>（推荐）不允许字段值为空。</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认值</td>
<td>设置当前字段的默认值。</td>
</tr>
<tr>
<td>AUTO_INCREMENt</td>
<td>自动增长</td>
<td>字段无需赋值，从指定值（默认 1）开始自动增长。表内只能存在一个且必须为索引。</td>
</tr>
<tr>
<td>COMMENT</td>
<td>注释</td>
<td>字段备注信息。</td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>外键</td>
<td>该字段关联到其他表的主键。默认建立普通索引。</td>
</tr>
</tbody></table>
<h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> [TEMPORARY] <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] student</span><br><span class="line">       (</span><br><span class="line">           id <span class="type">INT</span>(<span class="number">8</span>) <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT<span class="operator">=</span><span class="number">20190001</span>,</span><br><span class="line">           name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">           sex <span class="type">INT</span> COMMENT <span class="string">&#x27;Male 1，Female 0&#x27;</span>,</span><br><span class="line">           access_time <span class="type">DATE</span> <span class="keyword">DEFAULT</span> GETDATE(),</span><br><span class="line">           major_id <span class="type">INT</span> <span class="keyword">FOREIGN</span> KEY <span class="keyword">REFERENCES</span> major(id) </span><br><span class="line">       )ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade</span><br><span class="line">       (</span><br><span class="line">           student_id <span class="type">INT</span>,</span><br><span class="line">           course_id <span class="type">INT</span>,</span><br><span class="line">           grade <span class="type">INT</span>,</span><br><span class="line">           <span class="keyword">PRIMARY</span> KEY (student_id,course_id),</span><br><span class="line">           <span class="keyword">CONSTRAINT</span> fk_grade_student <span class="keyword">FOREIGN</span> KEY (student_id) <span class="keyword">REFERENCES</span> student(id),</span><br><span class="line">           <span class="keyword">CONSTRAINT</span> fk_grade_course <span class="keyword">FOREIGN</span> KEY (course_id) <span class="keyword">REFERENCES</span> course(id)</span><br><span class="line">       );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> [IF <span class="keyword">EXISTS</span>] student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空表数据（直接删除表，再重新创建）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">TRUNCATE</span> [<span class="keyword">TABLE</span>] student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DESC</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表属性</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student ENGINE<span class="operator">=</span>MYISAM;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> RENAME <span class="keyword">TABLE</span> student <span class="keyword">TO</span> new_student;</span><br><span class="line">mysql<span class="operator">&gt;</span> RENAME <span class="keyword">TABLE</span> student <span class="keyword">TO</span> mydb.new_student;      </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复制表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_student <span class="keyword">LIKE</span> student;                  <span class="comment">-- 复制表结构</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_student [<span class="keyword">AS</span>] <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;    <span class="comment">-- 复制表结构和数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查表是否有错误</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CHECK</span> <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [option] ...</span><br><span class="line"><span class="comment">-- 优化表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> OPTIMIZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br><span class="line"><span class="comment">-- 修复表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> REPAIR [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line"><span class="comment">-- 分析表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> ANALYZE [<span class="keyword">LOCAL</span> <span class="operator">|</span> NO_WRITE_TO_BINLOG] <span class="keyword">TABLE</span> tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<h4 id="列操作"><a href="#列操作" class="headerlink" title="列操作"></a>列操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 添加字段</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] age <span class="type">INT</span>;               <span class="comment">-- 默认添加在最后一行</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] age <span class="type">INT</span> AFTER sex;     <span class="comment">-- 添加在指定字段后</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] age <span class="type">INT</span> <span class="keyword">FIRST</span>;         <span class="comment">-- 添加在第一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--修改字段</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student MODIFY [<span class="keyword">COLUMN</span>] id <span class="type">SMALLINT</span>;        <span class="comment">-- 修改字段属性</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student CHANGE [<span class="keyword">COLUMN</span>] id new_id <span class="type">INT</span>;      <span class="comment">-- 修改字段名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除字段</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] age;   </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 编辑主键</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id,age);           </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;                 </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 编辑外键</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> fk_student_class <span class="keyword">FOREIGN</span> KEY(cid) <span class="keyword">REFERENCES</span> class(id);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY fk_student_class;  </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="数据指令"><a href="#数据指令" class="headerlink" title="数据指令"></a>数据指令</h2><h3 id="增删改查-1"><a href="#增删改查-1" class="headerlink" title="增删改查"></a>增删改查</h3><p><strong>插入数据</strong>，如果已有主键值则插入数据失败。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (ID,name,grade)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span>(<span class="number">755</span>,<span class="string">&#x27;王东浩&#x27;</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p><strong>插入并替换数据</strong>，如果已有主键值则先删除再插入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> REPLACE <span class="keyword">INTO</span> student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (ID,name,grade)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VALUES</span>(<span class="number">755</span>,<span class="string">&#x27;王东浩&#x27;</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure>

<p><strong>更新数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;孙鹏&#x27;</span>,grade<span class="operator">=</span><span class="number">60</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">753</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">754</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查询数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> id,name <span class="keyword">FROM</span> student               <span class="comment">-- 按条件查询数据</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id <span class="keyword">BETWEEN</span> <span class="number">753</span> <span class="keyword">and</span> <span class="number">755</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;                    <span class="comment">-- 查询全部数据</span></span><br></pre></td></tr></table></figure>

<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><ul>
<li>DISTINCT 关键字用于对查询结果去重，必须放于所有字段前。只有多个字段全部相等才会被去重。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> DINTINCE age,sex <span class="keyword">FROM</span> student;     <span class="comment">-- 查询数据并去重</span></span><br></pre></td></tr></table></figure>

<ul>
<li>WHERE 语句用于指定 更新/删除/查询 的操作范围，如果不设定范围将对全部数据进行操作。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">!=</span> <span class="number">100</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id [<span class="keyword">NOT</span>] <span class="keyword">BETWEEN</span> <span class="number">30</span> <span class="keyword">AND</span> <span class="number">50</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id [<span class="keyword">NOT</span>] <span class="keyword">IN</span> (<span class="number">30</span>, <span class="number">35</span> ,<span class="number">50</span>);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> grade <span class="keyword">IS</span> [<span class="keyword">NOT</span>] <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>LIKE 语句用于对字符串进行模糊匹配：<code>%</code>代表任意多个字符 <code>_</code>代表一个字符 <code>/</code>代表转义</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Tom%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h3 id="分组排序"><a href="#分组排序" class="headerlink" title="分组排序"></a>分组排序</h3><h4 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h4><table>
<thead>
<tr>
<th>分组函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>个数</td>
</tr>
<tr>
<td>sum</td>
<td>总和</td>
</tr>
<tr>
<td>max</td>
<td>最大值</td>
</tr>
<tr>
<td>min</td>
<td>最小值</td>
</tr>
<tr>
<td>avg</td>
<td>求平均值</td>
</tr>
<tr>
<td>group_concat</td>
<td>组内字符串拼接</td>
</tr>
</tbody></table>
<ol>
<li>GROUP 语句指定数据的分组方式，如果不含则默认把全部数据合并为一条数据。（本质是生成临时表）</li>
<li>AS 关键字为表或者列起别名，可省略。</li>
<li>HAVING 语句对分组后的结果进行筛选。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询班级总数</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> class;                    <span class="comment">-- 全部合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询各年级人数</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> grade, <span class="built_in">SUM</span>(class.student_num) <span class="keyword">AS</span> nums </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> class </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> grade                                 <span class="comment">-- 各班数据按年级合并</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(class.student_num) <span class="operator">&gt;</span> <span class="number">200</span>;           <span class="comment">-- 筛选人数大于 200 的年级</span></span><br></pre></td></tr></table></figure>

<h4 id="数据排序"><a href="#数据排序" class="headerlink" title="数据排序"></a>数据排序</h4><ul>
<li>ORDER 语句指定数据显示顺序，ASC 为升序 / DESC 为降序。</li>
<li>LIMIT 语句对排序后的数据进行筛选，指定起始序号和总数量。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询学生信息</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">DESC</span>, ID <span class="keyword">ASC</span>                   <span class="comment">-- 按成绩降序排列，若相同按学号升序排列</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> LIMIT <span class="number">10</span>,<span class="number">20</span>;                                  <span class="comment">-- 筛选第 11 - 30 名</span></span><br></pre></td></tr></table></figure>


<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h4><ol>
<li>FROM 型：子语句返回一个表，且必须给子查询结果取别名。</li>
<li>WHERE 型：子语句返回一个值，不能用于 UPDATE。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- FROM 型</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tb <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">0</span>) <span class="keyword">AS</span> subfrom </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- WHERE 型</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> tb</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> money <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">max</span>(money) <span class="keyword">FROM</span> tb);</span><br></pre></td></tr></table></figure>


<h4 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h4><ol>
<li>默认为 DISTINCT 形式，不同表查询到的相同数据只展示一个。</li>
<li>设置为 ALL 则不同表查询到的相同结果重复展示。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- DISTINCT 形式</span></span><br><span class="line">mysql<span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&lt;</span> <span class="number">10</span>) </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNION</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ALL 形式</span></span><br><span class="line">mysql<span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student1) </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">UNION</span> <span class="keyword">ALL</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student2);</span><br></pre></td></tr></table></figure>

<h4 id="连表查询"><a href="#连表查询" class="headerlink" title="连表查询"></a>连表查询</h4><ul>
<li><strong>内连接 INNER JOIN</strong>：（默认）未指定连接条件时，自动查找相同字段名匹配连接条件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> s.id,s.name,c.name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student s <span class="keyword">JOIN</span> class c</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> e.cid <span class="operator">=</span> c.id;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student s, class c </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> s.id <span class="operator">=</span> c.id; </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>交叉连接 CROSS JOIN</strong>：未指定连接条件时，视为无连接条件。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> boy <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> girl;                 <span class="comment">-- 显示所有交配可能</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> boy, girl;                               <span class="comment">-- 等价写法</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>外连接 OUTER JOIN</strong>：如果数据不存在，也会出现在连接结果中。<ul>
<li><strong>LEFT JOIN</strong>：左表数据一定显示，没有匹配右表数据用 null 填充。</li>
<li><strong>RIGHT JOIN</strong>：右表数据一定显示，没有匹配左表数据用 null 填充。</li>
<li><strong>FULL JOIN</strong>：两表数据一定显示，没有匹配数据用 null 填充。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> s.id,s.name,c.name                   <span class="comment">-- 显示学生的班级信息</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> class c            <span class="comment">-- 没有班级的学生也会显示</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> s.cid <span class="operator">=</span> c.id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先筛选再连接（效率等价，但如果有大量重复值提前筛选可以提高效率）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> s.id,s.name,c.name    </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> student s <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> DINTINCT id, name <span class="keyword">FROM</span> class) c       </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> s.cid <span class="operator">=</span> c.id;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="高级指令"><a href="#高级指令" class="headerlink" title="高级指令"></a>高级指令</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul>
<li><strong>索引类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th>索引名称</th>
<th>索引类型</th>
<th>字段类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>主索引</td>
<td>主键</td>
<td>字段值不能重复，也不能为空。</td>
</tr>
<tr>
<td>INDEX</td>
<td>普通索引</td>
<td>自定义字段</td>
<td>无，效率低。</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一索引</td>
<td>自定义字段</td>
<td>字段值不能重复，效率高。</td>
</tr>
<tr>
<td>FULLTEXT</td>
<td>文本索引</td>
<td>自定义字段</td>
<td>无，用于文本检索。</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT] INDEX idx_student_age </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> [<span class="keyword">USING</span> BTREE]                                           <span class="comment">-- 指定索引类型，默认 B+ 树</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> student(age);                                        <span class="comment">-- 指定索引属性</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> INDEX [idx_student_age](id,age);   </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [uniq_student_age](age);         </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> FULLTEXE [ft_student_age](age);  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> INDEX idx_student_age <span class="keyword">ON</span> student;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> INDEX idx_student_age;                 </span><br></pre></td></tr></table></figure>


<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p><strong>视图算法</strong></p>
<table>
<thead>
<tr>
<th>算法</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>UNDEFINED</td>
<td>未定义(默认)</td>
<td>MySQL 自主选择相应的算法。</td>
</tr>
<tr>
<td>MERGE</td>
<td>合并</td>
<td>视图的查询语句，与外部查询需要先合并再执行。</td>
</tr>
<tr>
<td>TEMPTABLE</td>
<td>临时表</td>
<td>将视图执行完毕后形成临时表，再做外层查询.</td>
</tr>
</tbody></table>
<p><strong>更新选项</strong></p>
<table>
<thead>
<tr>
<th>算法</th>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CACADED</td>
<td>级联(默认)</td>
<td>满足所有视图条件才能进行数据更新。</td>
</tr>
<tr>
<td>LOCAL</td>
<td>本地</td>
<td>满足本视图条件就能进行数据更新。</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> ALGORITHM <span class="operator">=</span> <span class="keyword">MERGE</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">VIEW</span> view_student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WITH</span> <span class="keyword">LOCAL</span> <span class="keyword">CHECK</span> OPTION;        </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看结构</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除视图</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] view_student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改视图结构（慎用）</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_student</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student);</span><br></pre></td></tr></table></figure>


<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>开启事务后，所有输入的 SQL 语句将被认作一个不可分割的整体，在提交时统一执行。</p>
<p>如果在输入过程中出现问题，可以手动进行回滚。在输入过程中可以设置保存点。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事务开启</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">START</span> TRANSACTION;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="comment">-- 事务提交</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 事务回滚</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 保存点</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SAVEPOINT</span> mypoint;                     <span class="comment">-- 设置保存点</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> <span class="keyword">SAVEPOINT</span> mypoint;         <span class="comment">-- 回滚到保存点</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> mypoint;             <span class="comment">-- 删除保存点</span></span><br></pre></td></tr></table></figure>


<p>InnoDB 存储引擎支持关闭自动提交，强制开启事务：任何操作都必须要 COMMIT 提交后才能持久化数据，否则对其他客户端不可见。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> AUTOCOMMIT <span class="operator">=</span> <span class="number">0</span><span class="operator">|</span><span class="number">1</span>;             <span class="comment">-- 0 表示关闭自动提交，1 表示开启自动提交。</span></span><br></pre></td></tr></table></figure>

<h3 id="锁定"><a href="#锁定" class="headerlink" title="锁定"></a>锁定</h3><p>MySQL 可以手动对表/行锁定，防止其它客户端进行不正当地读取和写入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 锁定</span></span><br><span class="line">mysql<span class="operator">&gt;</span> LOCK TABLES student [<span class="keyword">AS</span> alias];          </span><br><span class="line"><span class="comment">-- 解锁</span></span><br><span class="line">mysql<span class="operator">&gt;</span> UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发程序是与表有关的数据库对象，监听记录的增加、修改、删除。当出现特定事件时，将激活该对象执行 SQL 语句。</p>
<ol>
<li><p>MySQL 数据库只支持<strong>行级触发器</strong>：如果一条 INSERT 语句插入 N 行数据，语句级触发器只执行一次，行级触发器要执行 N 次。</p>
</li>
<li><p>在触发器中，可以使用 <code>OLD</code> 和 <code>NEW</code> 表示该行的新旧数据。删除操作只有 <code>OLD</code>，增加操作只有 <code>NEW</code> 。</p>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看触发器</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TRIGGERS;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> my_trigger </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> BEFORE <span class="keyword">INSERT</span>                    <span class="comment">-- 触发时间 BEFORE/AFTER 触发条件 INSERT/UPDATE/DELETE</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ON</span> student                       <span class="comment">-- 监听表必须是永久性表</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>                     <span class="comment">-- 行级触发器</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student_logs(id,op,op_time，op_id) <span class="keyword">VALUES</span>(<span class="keyword">null</span>,<span class="string">&#x27;insert&#x27;</span>,now(),new.id)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [schema_name.]trigger_name;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>其它</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><hr>
<h2 id="Redis-介绍"><a href="#Redis-介绍" class="headerlink" title="Redis 介绍"></a>Redis 介绍</h2><h3 id="NoSQL-技术"><a href="#NoSQL-技术" class="headerlink" title="NoSQL 技术"></a>NoSQL 技术</h3><p>在实际项目开发中，我们往往需要面对海量用户和高并发的数据请求。MySQL 等传统关系型数据库面临着两大问题：</p>
<ol>
<li>磁盘 IO 速度缓慢，单机读写速度不超过 10000 QPS，当数据库无法及时响应高并发的用户请求，请求积压进而导致数据库瘫痪。</li>
<li>数据关系复杂，扩展性差。不适合大规模集群。</li>
</ol>
<p>因此我们必须引入 NoSQL 技术去解决以上两个问题，以作为关系型数据库的补充。</p>
<h3 id="Redis-数据库"><a href="#Redis-数据库" class="headerlink" title="Redis 数据库"></a>Redis 数据库</h3><p>Redis 是一种<strong>基于内存</strong>的数据库技术。底层采用 C 语言开发，默认端口号 6379。</p>
<ol>
<li>Redis 数据库作为数据缓存，将业务数据直接存储在内存中进行读写，单机读/写速度可达 110000/84000 QPS，可以满足高速响应的需求。</li>
<li>Redis 数据库只负责存储数据，数据之间不具有任何关联，易于扩容和伸缩。</li>
</ol>
<h3 id="Redis-应用场景"><a href="#Redis-应用场景" class="headerlink" title="Redis 应用场景"></a>Redis 应用场景</h3><p>受限于内存的高昂成本，一般我们只使用 Redis 存储高频读写的关键数据。比如：</p>
<ol>
<li><strong>热点数据</strong>：如热点商品信息。</li>
<li><strong>任务队列</strong>：如秒杀队列、抢购队列。</li>
<li><strong>实时更新信息</strong>：如商品排行榜、公交到站信息。</li>
<li><strong>时效性信息</strong>：如手机验证码、session 、 心跳(heartbeat)。</li>
</ol>
<blockquote>
<p>Redis 主要适用于内部系统的高频数据。在线上环境负载极大的情况下，使用 Redis 也不足以满足对数据读写的速度要求。</p>
</blockquote>
<h3 id="Redis-基本使用"><a href="#Redis-基本使用" class="headerlink" title="Redis 基本使用"></a>Redis 基本使用</h3><h4 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h4><p>在控制台输入以下指令安装和使用 Redis：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install redis-server       <span class="comment"># 安装 Redis 数据库（仅限 Ubuntu 可用）</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-server                            <span class="comment"># 启动 Redis 数据库</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-server --port 6380                <span class="comment"># 启动 Redis 数据库，在指定端口</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-server redis-6379.conf            <span class="comment"># 启动 Redis 数据库，使用指定配置文件</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli                               <span class="comment"># 进入 Redis 控制台，在默认端口</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -p 6380                       <span class="comment"># 进入 Redis 控制台，在指定端口</span></span></span><br></pre></td></tr></table></figure>

<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>在 Redis 安装目录下的 <code>redis.conf</code> 文件是 Redis 默认配置文件，启动 Redis 数据库时默认加载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize no                     # 守护线程，打开后启动 Redis 控制台不提示</span><br><span class="line">bind 127.0.0.1                   # 绑定 IP 地址，绑定后只能通过该地址访问 Redis</span><br><span class="line">port 6379                        # 端口号</span><br><span class="line">databases 16                     # 存储区域数量</span><br></pre></td></tr></table></figure>

<h4 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h4><p>Redis 总共支持四个日志级别：debug / verbose / notice / warning ，从前往后日志记录信息逐渐减少。通常情况下开发环境设为 verbose ，生产环境设为 notice 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel verbose                 # 日志级别</span><br><span class="line">logfile 6379.log                 # 日志文件名</span><br></pre></td></tr></table></figure>


<h4 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h4><p>默认使用 RDB 方式持久化数据，相关配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1                            # 自动同步数据条件，900s 内变更 1 个 key 值则持久化</span><br><span class="line">save 300 10                           # 自动同步数据条件，300s 内变更 10 个 key 值则持久化</span><br><span class="line"></span><br><span class="line">rdbcompression yes                    # 是否压缩数据，压缩后节省空间但读取较慢</span><br><span class="line">rdbchecksum yes                       # 是否格式校验（默认开启），校验降低文件损坏风险但读取较慢</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb                   # 保存文件名</span><br><span class="line">dir ./                                # 保存文件位置</span><br></pre></td></tr></table></figure>

<p>可以在配置文件中改用 AOF 方式持久化数据，刷新文件条件有三种类型： always / everysec / no 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly yes                        # 选用 AOF 方式持久化</span><br><span class="line">appendsync everysec                   # 刷新文件条件，每秒更新一次操作日志</span><br></pre></td></tr></table></figure>

<h4 id="容量配置"><a href="#容量配置" class="headerlink" title="容量配置"></a>容量配置</h4><p>对 Redis 数据库占用空间和客户链接做出限制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 100                        # 客户连接数上限，超出后拒绝客户访问，为 0 表示不限制</span><br><span class="line">timeout 300                           # 客户闲置时长，超出后关闭连接，为 0 表示不关闭</span><br><span class="line"></span><br><span class="line">maxmemory 50                          # Redis 最大占用内存比例，为 0 表示全部可用</span><br><span class="line">maxmemory-samples                     # Redis 随机选取数据数量</span><br><span class="line">maxmemery-policy volatile-lru         # Redis 逐出策略</span><br></pre></td></tr></table></figure>

<h4 id="多机配置"><a href="#多机配置" class="headerlink" title="多机配置"></a>多机配置</h4><p>如果我们要设置集群，则需要进行以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cluster enabled yes                        # 开启集群</span><br><span class="line">cluster-config-file nodes.conf             # 集群配置文件</span><br></pre></td></tr></table></figure>

<p>如果我们要设置主从服务器，则需要进行以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主服务器</span><br><span class="line">requirepass 123456                    # 主服务器设置密码（可选）</span><br><span class="line">repl-backlog-size 1mb                 # 缓冲区大小</span><br><span class="line"></span><br><span class="line"># 从服务器</span><br><span class="line">slaveof 127.0.0.1 6379                # 主服务器套接字，设置后自动连接</span><br><span class="line">masterauth 123456                     # 主服务器密码</span><br><span class="line">slave-serve-stale-data no             # 同步数据时是否允许读数据</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="Redis-基础"><a href="#Redis-基础" class="headerlink" title="Redis 基础"></a>Redis 基础</h2><ol>
<li><p>在 Redis 中单个指令都是原子性操作，通过指令操作 Redis 数据时无需担心线程安全问题。</p>
</li>
<li><p>Redis 以 key-value 的形式保存数据：key 值一定为 string 类型，而 value 值支持以下五种基础类型：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>存储形式</th>
</tr>
</thead>
<tbody><tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>hash</td>
<td>哈希表</td>
</tr>
<tr>
<td>list</td>
<td>链表</td>
</tr>
<tr>
<td>set</td>
<td>哈希集</td>
</tr>
<tr>
<td>sorted_set</td>
<td>二叉树集</td>
</tr>
</tbody></table>
<h3 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h3><p>Redis 将数据存储分为多个相互独立的区域，将 Redis 操作局限在自己的存储区域内。通常划分为 16 个（编号 0-15），默认使用编号 0 。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">select 1                         <span class="comment"># 改用 1 号存储区域</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">dbsize                           <span class="comment"># 返回当前区域 key 数量</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">move key 2                       <span class="comment"># 将当前 key 迁移到 2 号存储区域</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">flushdb                          <span class="comment"># 清空当前存储区域</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">flushall                         <span class="comment"># 清空全部存储区域</span></span></span><br></pre></td></tr></table></figure>

<h3 id="key-操作"><a href="#key-操作" class="headerlink" title="key 操作"></a>key 操作</h3><p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del key                            <span class="comment"># 删除 key</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">exists key                         <span class="comment"># 判断是否存在 key</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">type</span> key                           <span class="comment"># 返回 key 对应的 value 类型</span></span>       </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">rename key newkey                  <span class="comment"># 重命名</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">renamenx key newkey                <span class="comment"># 重命名（返回 1），新名称已存在则失败（返回 0）</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">sort</span>                               <span class="comment"># 对 key 排序</span></span></span><br></pre></td></tr></table></figure>

<p><strong>时效性控制</strong></p>
<p>Redis 中可以为 key 设置有效期，key 过期后会由 Redis 执行删除策略回收内存空间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expire key 10                      <span class="comment"># key 10s 内有效</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">expireat key 1355292000            <span class="comment"># key 截至时间戳有效</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">persist key                        <span class="comment"># key 永久有效</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">ttl key                            <span class="comment"># 返回 key 剩余有效时间，若不存在返回 -2 ，永久返回 -1</span></span></span><br></pre></td></tr></table></figure>

<p><strong>查询操作</strong></p>
<p>Redis 支持查询存储区域内含有的 key，且允许使用以下通配符：</p>
<ul>
<li><code>*</code> 表示任意数量字符</li>
<li><code>?</code> 表示任意一个字符</li>
<li><code>[]</code> 表示一个指定字符</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">keys *                             <span class="comment"># 查询所有 key</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">keys user:*                        <span class="comment"># 查询所有 user 的 key</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">keys <span class="built_in">id</span>:75??                       <span class="comment"># 查询 ID 为 7500-7599 的 key</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">keys <span class="built_in">id</span>:7[2345]55                  <span class="comment"># 查询 ID 为 7255/7355/7455/7555 的 key</span></span></span><br></pre></td></tr></table></figure>

<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><h4 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h4><p>Redis 的 string 类型中，key 值对应的存储空间内将保存一个字符串数据，</p>
<p>key 值标准命名格式为 <code>表名:主键名:主键值:字段名</code>，如 <code>user:id:15942348:name - &quot;王东浩&quot;</code>。</p>
<p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"><span class="built_in">set</span> key 10                     <span class="comment"># 设置键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">get key                        <span class="comment"># 获取键值，不存在则返回 nil</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">del key                        <span class="comment"># 删除键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">strlen key                     <span class="comment"># 获取价值的字符串长度</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">append key 0                   <span class="comment"># 在键值尾部追加</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mset key1 10 key2 100          <span class="comment"># 设置多个数据</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">mget key1 key2                 <span class="comment"># 获取多个数据</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">setex key 10 1                 <span class="comment"># 设置键值对，10s 后自动删除</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">psetex key 10 1                <span class="comment"># 设置键值对，10ms 后自动删除</span></span></span><br></pre></td></tr></table></figure>

<p><strong>数据操作</strong></p>
<p>如果字符串为合法数字，可以当作数字处理。但数值不能超过 shell 中的 long 类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">incr key                       <span class="comment"># 键值加一</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">decr key                       <span class="comment"># 键值减一</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">incrby key 10                  <span class="comment"># 键值加十</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">decrby key 10                  <span class="comment"># 键值减十</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">incrbyfloat key -1.5           <span class="comment"># 键值加 -1.5</span></span></span><br></pre></td></tr></table></figure>


<h4 id="hash-类型"><a href="#hash-类型" class="headerlink" title="hash 类型"></a>hash 类型</h4><p>hash 类型中，key 值对应的存储空间内可以保存多个键值对(field-value)：field 和 value 都必须是字符串类型。当键值对较少时存储空间内采用数组存储，当键值对较多时采用哈希存储。</p>
<p>十分适合存储对象，每个键值对记录对象的一个属性。</p>
<p><img src="hash.png" alt="hash"></p>
<p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hset key field 10               <span class="comment"># 设置/更新键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hsetnx key field 10             <span class="comment"># 如果键值不存在则设置键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hget key field                  <span class="comment"># 获取键值</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hgetall key                     <span class="comment"># 获取全部键值</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hdel key field                  <span class="comment"># 删除键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hlen key                        <span class="comment"># 获取键值对数量</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hexists key field               <span class="comment"># 判断是否存在字段（返回 1 或 0）</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hmset key field1 1 field2 2     <span class="comment"># 设置/修改多个键值对</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hmget key field1 field2         <span class="comment"># 获取多个键值对</span></span></span><br></pre></td></tr></table></figure>

<p><strong>扩展操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hkeys key                       <span class="comment"># 返回 key 对应的所有 field</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hvals key                       <span class="comment"># 返回 key 对应的所有 value</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hincrby key field 1             <span class="comment"># 键值加一</span></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">hdecrby key field 1             <span class="comment"># 键值减一</span></span></span><br></pre></td></tr></table></figure>

<h4 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h4><p>list 类型中，key 值对应的存储空间内可以保存多个字符串数据，采用双向链表实现。具有索引的概念，但还是更适合从链表两侧操作。字符串总容量不能超过 2 的 32 次方。</p>
<p>十分适合存储有序信息，比如粉丝列表。</p>
<p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush list 1                    # 链表左侧插入数据，返回下标</span><br><span class="line">rpush list 2                    # 链表右侧插入数据，返回下标</span><br><span class="line">lpop list                       # 获取并删除最左侧数据</span><br><span class="line">rpop list                       # 获取并删除最右侧数据</span><br><span class="line">blpop list 10                   # 获取并删除最左侧数据，不存在则至多等待 10 s</span><br><span class="line">lrem list 3 x                   # 从左侧开始，删除三个为 x 的数据</span><br><span class="line"></span><br><span class="line">lrange list 0 2                 # 返回左侧前3个数据</span><br><span class="line">lrange list 0 -1                # 返回全部数据（常用）</span><br><span class="line">lindex list 0                   # 返回指定位置数据</span><br><span class="line">llen list                       # 返回字符串个数</span><br></pre></td></tr></table></figure>

<h4 id="set-类型"><a href="#set-类型" class="headerlink" title="set 类型"></a>set 类型</h4><p>set 类型中，key 值对应的存储空间内可以保存多个字符串数据，采用哈希存储实现。随机查询效率比 list 类型更高。字符串总容量不能超过 2 的 32 次方。</p>
<p>十分适合存储集合类信息，比如用户感兴趣的话题、用户权限。</p>
<p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sadd set member                  # 添加数据（可以是多个）</span><br><span class="line">srem set member                  # 删除数据（可以是多个）</span><br><span class="line">smembers set                     # 展示全部数据  </span><br><span class="line"></span><br><span class="line">scard set                        # 返回数据个数</span><br><span class="line">sismember set                    # 判断是否含有数据</span><br><span class="line"></span><br><span class="line">srandmember set 5                # 随机从集合中选取 5 个数据</span><br><span class="line">spop set                         # 返回并删除一个随机数据</span><br></pre></td></tr></table></figure>

<p><strong>扩展操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sinter set1 set2                   # 交</span><br><span class="line">sunion set1 set2                   # 并</span><br><span class="line">sdiff set1 set2                    # 差</span><br><span class="line">sinterstore newset set1 set2       # 交且存入新集合</span><br><span class="line">sunionstore newset set1 set2       # 并且存入新集合</span><br><span class="line">sdiffstore newset set1 set2        # 差且存入新集合</span><br><span class="line"></span><br><span class="line">smove oldset newset 5              # 数据从旧集合迁移到新集合</span><br></pre></td></tr></table></figure>

<h4 id="sorted-set-类型"><a href="#sorted-set-类型" class="headerlink" title="sorted_set 类型"></a>sorted_set 类型</h4><p>如果我们需要数据查询效率较高且有序，则可以使用 sorted_set 类型。底层和 set 结构相同采用哈希存储（value 值仍不可重复），但在 key-value 存储结构后添加 score 属性为数据排序，默认从小到大。score 是数字且可以使用小数，但如果使用小数浮点类型可能会出现精度丢失。</p>
<p>可以用来存储排行榜等有序数据集合，还可以用于存储时效性或者带有权重的任务队列，用当前时间或者权重作为 score 。</p>
<p><strong>基本操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zadd set score1 member             # 添加数据且标记序号（可以是多个）</span><br></pre></td></tr></table></figure>

<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><p>此外，Redis 还提供了 Bitmaps、 HyberLogLog、GEO 三种高级数据类型，用来适配特定的应用场景。</p>
<h4 id="Bitmaps-类型"><a href="#Bitmaps-类型" class="headerlink" title="Bitmaps 类型"></a>Bitmaps 类型</h4><p>Bitmaps 类型中用作存储布尔值：每个 key 对应若干字节数据（字节数 = 最大编号 / 8），每字节可以存储 8 个 boolean 值。</p>
<p>如果 Redis 要存储大量 boolean 值，使用 Bitmaps 类型可以显著节省内存空间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setbit bits 0 1                  # 将 0 位置为 1(true)</span><br><span class="line">getbit bits 0                    # 取 0 位的值</span><br></pre></td></tr></table></figure>

<h4 id="HyperLogLog-类型"><a href="#HyperLogLog-类型" class="headerlink" title="HyperLogLog 类型"></a>HyperLogLog 类型</h4><p>HyperLogLog 类型用作数据统计，只记录数量不保存数据，且当数据量巨大时存在误差！</p>
<p>使用 HyperLogLog 类型可以显著节省内存空间，每个 key 仅占用 12k 内存标记基数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setbit bits 0 1                  # 将 0 位置为 1(true)</span><br><span class="line">getbit bits 0                    # 取 0 位的值</span><br></pre></td></tr></table></figure>

<h4 id="GEO-类型"><a href="#GEO-类型" class="headerlink" title="GEO 类型"></a>GEO 类型</h4><p>GEO 类型用作地理位置计算，根据经纬度。</p>
<hr>
<h2 id="Redis-高级"><a href="#Redis-高级" class="headerlink" title="Redis 高级"></a>Redis 高级</h2><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>Redis 使用内存存储，一旦断电可能会导致数据丢失。因此需要将数据保存到永久性存储介质中，防止数据意外丢失。</p>
<p><em>如果 Redis 负责为数据库高热度数据访问加速或者一些其他业务（数据库中有重复数据），那么没必要为 Redis 数据持久化。</em></p>
<p>Redis 持久化有以下两种方式：</p>
<h4 id="数据快照-RDB"><a href="#数据快照-RDB" class="headerlink" title="数据快照 RDB"></a>数据快照 RDB</h4><p><strong>定时将全部数据存入文件</strong>。存储速度慢但是恢复数据的速度很快，如果保存不及时仍会丢失少量数据。</p>
<p>数据以二进制形式默认存储在 <code>安装目录/data/dump.rgb</code> 文件。如果 Redis 数据库被关闭，下次重启时会从该文件读取数据。</p>
<p><strong>手动存储</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save                      # 数据存入文件（会阻塞 Redis 数据库，导致其他指令无法执行）</span><br><span class="line">bgsave                    # 数据存入文件（Redis 数据库调创建单独进程完成指令）</span><br><span class="line"></span><br><span class="line">debug reload              # 重启 Redis，且关闭时将数据存入文件</span><br><span class="line">shutrown save             # 关闭 Redis，且关闭时将数据存入文件</span><br></pre></td></tr></table></figure>

<p><strong>修改配置</strong></p>
<p>在 <code>安装目录/conf/redis-6379.conf</code> 配置文件内可以修改默认配置：</p>
<ul>
<li>如果操作系统内安装了多个 Redis 数据库（使用不同的端口），必须通过修改存储文件名加以区分。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir data2                            # 修改存储路径（默认 data） </span><br><span class="line">dbfilename dump-6379.rgb             # 修改存储文件名（默认 dump.rgb）</span><br><span class="line">rdbcompression no                    # 关闭数据压缩（默认开启），读取文件加快但文件会变大</span><br><span class="line">rdbchecksum no                       # 关闭格式校验（默认开启），读取文件加快但存在文件损坏风险</span><br><span class="line">stop-writes-on-bgsave-error no       # 后台存储出现错误不停止（默认停止）</span><br></pre></td></tr></table></figure>

<ul>
<li>通过修改配置文件，可以让 Redis 数据库可以自动调用 bgsave 指令更新 RDB 文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">save 100 10                          # 自动存储（100s 内发生 10 个 key 数据变化时触发）</span><br></pre></td></tr></table></figure>


<h4 id="日志记录-AOF"><a href="#日志记录-AOF" class="headerlink" title="日志记录 AOF"></a>日志记录 AOF</h4><p><strong>将对数据的操作过程存入文件</strong>。这种方式刷新更频繁因此丢失数据概率更低，但恢复数据的速度比 RDB 方式更慢，占用存储空间也更大。</p>
<p>数据以二进制形式默认存储在 <code>安装目录/data/appendonly.aof</code> 文件。如果 Redis 数据库被关闭，下次重启时会根据该文件恢复数据。</p>
<p><strong>文件重写</strong></p>
<p>随着命令不断写入 AOF ，AOF 文件会越来越大，占用内存增多、恢复数据也会变慢。因此 Redis 需要对 AOF 文件进行重写，合并指令记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rewriteaof                          # 重写 AOF 文件（会阻塞 Redis 数据库，导致其他指令无法执行）</span><br><span class="line">bgrewriteaof                        # 重写 AOF 文件（Redis 数据库调创建单独进程完成指令）                        </span><br></pre></td></tr></table></figure>


<p><strong>修改配置</strong></p>
<p>AOF 不是默认持久化方式，需要在 <code>安装目录/conf/redis-6379.conf</code> 配置文件内修改默认配置：</p>
<ul>
<li>必须通过配置文件开启并配置 AOF 存储。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes                        # 选用 AOF 方式持久化</span><br><span class="line"></span><br><span class="line">appendsync always                     # 每次操作刷新文件：非常频繁，损耗性能</span><br><span class="line">appendsync everysec                   # 每秒刷新文件（默认）</span><br><span class="line">appendsync no                         # 手动刷新文件</span><br></pre></td></tr></table></figure>

<ul>
<li>修改路径和文件名的操作和 RDB 方法类似。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dir data2                             # 修改存储路径（默认 data） </span><br><span class="line">dbfilename appendonly-6379.aof        # 修改存储文件名（默认 appendonly.aof）</span><br></pre></td></tr></table></figure>

<ul>
<li>通过修改配置文件，可以让 Redis 数据库自动调用 bgrewriteaof 指令重写 AOF 文件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">略，之后补充</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>假如我们通过多个操作执行一次购物，如果在这个过程中还执行了其他操作，可能导致我们的购物过程出现意想不到的错误。</p>
<p>因此我们引入事务的概念，将多个操作看作一个不可分割的整体，统一执行而不会被其他操作打断。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">multi                     # 开启事务，之后的命令不再立刻执行、而是进入任务队列</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入事务内的命令</span></span><br><span class="line"></span><br><span class="line">exec                      # 执行事务，执行任务队列里的命令</span><br><span class="line">discard                   # 取消事务，清空任务队列</span><br></pre></td></tr></table></figure>

<ol>
<li>如果事务中包含语法错误（不能识别的命令），所有的命令都不会执行。</li>
<li>如果事务中包含无法执行的命令，仅有出错的命令将不会被执行，其他被执行的命令需要开发者自行回滚。</li>
</ol>
<h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><p>在事务准备的过程中，如果执行的其他操作导致触发事务的条件发生了变化，这个时候就不应该继续执行事务。</p>
<p>我们引入了锁的概念来监视特定 key，在执行事务前如果其 value 发生了变化则终止事务执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch key1 key2            # 监视 key，书写在 multi 命令前</span><br><span class="line">unwatch                    # 取消监视 key，书写在 multi 命令前</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在之后执行事务</span></span><br></pre></td></tr></table></figure>

<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>如果 key 值变化极为频繁，那么使用普通锁会导致事务一直被终止。我们引入了分布式锁的概念，在加锁期间不允许其他进程对该值修改。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setnx lock-num 1               # 对 key(num) 加公共锁，其他线程不能对其进行操作。成功则返回 1，若已有锁导致失败返回 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入命令或者事务</span></span><br><span class="line"></span><br><span class="line">del lock-num                   # 对 key(num) 解公共锁</span><br></pre></td></tr></table></figure>

<p>分布式锁如果长期不被释放，就会出现死锁，导致其他操作无法继续执行。我们可以对分布式锁计时。<strong>计时分布式锁常用于多部署平台统一竞争锁。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">expire lock-num 10                # 对 key(num) 加公共锁，10s 后自动释放</span><br><span class="line">pexpire lock-num 10               # 对 key(num) 加公共锁，10ms 后自动释放</span><br></pre></td></tr></table></figure>

<h3 id="删除策略"><a href="#删除策略" class="headerlink" title="删除策略"></a>删除策略</h3><p>Redis 中每个存储区域除了存储 key-value 值，还会开辟额外的存储空间 expires 记录每个 key-value 的存储地址以及过期时间。如果 key 过期或被删除指令删除，那么 Redis 要执行删除策略清理内存空间。</p>
<p>Redis 删除策略有以下三种方式，主要使用惰性删除和定期删除两种方式。</p>
<ol>
<li><strong>定时删除</strong></li>
</ol>
<p>key 过期后，存储 key-value 的内存地址立即被清空。</p>
<p>节省内存资源，但可能抢占处在繁忙状态的 CPU。</p>
<ol start="2">
<li><strong>惰性删除</strong></li>
</ol>
<p>key 过期后不做任何处理。访问 key 时才检查是否过期，如果过期存储该 key-value 的内存地址才被清空。</p>
<p>节省 CPU 资源，但过期键值对可能大量占用内存。</p>
<ol start="3">
<li><strong>定期删除</strong></li>
</ol>
<p>对于 16 个存储区域的 expires 进行轮询，对选中的 expires 随机选择 W 个 key 进行检查，如果 key 过期就进行删除。</p>
<ul>
<li>如果过期 key 超过 25%，那么重复检查该 expires 存储区域。</li>
<li>如果过期 key 少于 25%，那么按顺序检查下一个 expires 存储区域。</li>
</ul>
<h3 id="逐出策略"><a href="#逐出策略" class="headerlink" title="逐出策略"></a>逐出策略</h3><p>如果 Redis 使用内存空间前会检查内存容量。如果已被占满，那么 Redis 要执行逐出策略删除部分数据，以清理内存空间执行指令。</p>
<p>在选取删除数据时 Redis 并不会扫描全库数据，而是随机选取部分数据检测并从中删除：以节省 CPU 性能。</p>
<p>响应配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">maxmemory 50                            # Redis 最大占用内存比例，默认为 0（全部可用）</span><br><span class="line">maxmemory-samples                       # Redis 随机选取数据数量</span><br><span class="line">maxmemery-policy volatile-lru           # Redis 逐出策略</span><br></pre></td></tr></table></figure>

<p>Redis 逐出策略有以下三种方式，在配置文件中配置即可。</p>
<ol>
<li><strong>检查会过期数据</strong></li>
</ol>
<ul>
<li><code>volatile-lru</code> ：（推荐）挑选最久未使用的数据淘汰。</li>
<li><code>volatile-lfu</code> ：挑选最近一段时间使用频率最低的数据淘汰。</li>
<li><code>volatile-ttl</code> ：挑选将要过期的数据淘汰。</li>
<li><code>volatile-random</code> ：随机挑选数据淘汰。</li>
</ul>
<ol start="2">
<li><strong>检查全部数据</strong></li>
</ol>
<ul>
<li><code>allkeys-lru</code> ：挑选最久未使用的数据淘汰。</li>
<li><code>allkeys-lfu</code> ：挑选最近一段时间使用频率最低的数据淘汰。</li>
<li><code>allkeys-random</code> ：随机挑选数据淘汰。</li>
</ul>
<ol start="3">
<li><strong>不逐出数据</strong></li>
</ol>
<ul>
<li><code>no-enviction</code> ：（默认）抛出错误 Out Of Memery。</li>
</ul>
<hr>
<h2 id="Redis-多机"><a href="#Redis-多机" class="headerlink" title="Redis 多机"></a>Redis 多机</h2><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>当数据量过大时，单个 Redis 数据库就无法存放。我们需要多个 Redis 数据库组成集群(cluster)，去分别<strong>存放不同的数据</strong>。</p>
<ol>
<li><p>key-value 数据进行存入时，会根据 key 的哈希值对 16384 取模，放入相应的槽(slot)存放。这 16384 个槽会分发给各个存储空间。</p>
</li>
<li><p>各个存储空间之间会相互通信，并记录所有编号的槽都存储在哪个存储空间：保证最多访问 Redis 两次可以命中。</p>
</li>
</ol>
<p><strong>配置文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster enabled yes                            # 开启集群</span><br><span class="line">cluster-config-file nodes-6379.conf            # 集群配置文件（默认为 nodes.conf）</span><br></pre></td></tr></table></figure>

<p><strong>集群指令</strong></p>
<ul>
<li><p>通过 <code>redis-cli</code> 打开 Redis 集群中的数据库，输入指令去插入不属于这个存储空间的键值，会返回错误。</p>
</li>
<li><p>通过 <code>redis-cli -c</code> 打开 Redis 集群中的数据库，会自动将插入数据指令转发到相应的存储空间。</p>
</li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>如果数据只交给一个 Redis 服务器处理，那么可能面临两大问题：</p>
<ol>
<li>服务器同时处理过多读写操作，超过服务器负载。</li>
<li>一旦服务器宕机，就会导致服务异常中断。</li>
</ol>
<p>为了避免这两个问题，我们必须引入多个 Redis 服务器来保存相同数据，并采用主从复制结构：一个主服务器 Master 对应多个从服务器 Slave 。</p>
<ol>
<li><strong>读写分离</strong>：Master 负责写入数据；Slave 则会自动同步数据，并负责读取数据。起到均衡负载的作用。</li>
<li><strong>数据冗余</strong>：即使某个 Slave 故障，由于其他 Slave 已保存了这些数据，并不会导致服务中断。 </li>
</ol>
<h4 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h4><ul>
<li><p>主从之间使用<strong>心跳</strong>建立连接。 Slave 每秒 ping 一次，汇报自己的偏移量、获取最新的指令。Master 默认每 10s ping 一次 Slave， 检查 slave 是否在线：如果 Slave 多数掉线或者高延迟，Master 停止写和数据同步功能，保障数据稳定性。</p>
</li>
<li><p>在分布式系统里还会部署多个 Redis 服务器作为<strong>哨兵</strong>（除端口号外完全相同），不提供数据服务，只负责监控主从机制的运行：如果发现 Master 宕机，哨兵将通知所有机器，使 Master 下线并开启投票机制选用一个 Slave 担任 Master 。</p>
</li>
</ul>
<h4 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h4><p>Master 和 Slave 通过以下过程建立连接。</p>
<p><img src="/pic/%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="x"></p>
<p>相比于输入指令，我们一般直接修改 conf 文件夹内的配置文件，由机器自动建立连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Master</span> </span><br><span class="line">requirepass 123456                # 连接主服务器需要密码（可选）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Slave</span></span><br><span class="line">slaveof 127.0.0.1 6379            # 根据套接字自动连接主服务器</span><br><span class="line">masterauth 123456                 # 主服务器密码</span><br></pre></td></tr></table></figure>


<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>Slave 会定期复制 Master 的持久化文件，以保证数据同步。</p>
<p><img src="/pic/%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE.png" alt="x"></p>
<p><strong>复制缓冲区</strong>：一个先入先出队列，用来存储 AOF 形式指令。由偏移量记录当前执行到的位置。</p>
<ul>
<li>如果开启 AOF ，在创建时就会开启复制缓冲区。（偏移量记录自己执行到的位置）</li>
<li>如果使用 RDB ，在成为 Master 时会开启复制缓冲区。（Master 可以含有多个偏移量，记录不同 Slave 读取到的位置。）</li>
</ul>
<p><em>如果 Slave 过多，数据同步也会导致 Master 负载过高。因此 Slave 也可以兼职 Master，向下级 Slave 提供服务。但层次太多会导致数据延迟，慎用。</em></p>
<ol>
<li>数据同步阶段应避免流量高峰期，防止影响业务正常执行；也不要多个从服务器同时同步数据。</li>
<li>缓冲区应该足够大，否则一旦发生数据溢出会反复进行全量复制。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Master</span></span><br><span class="line">repl-backlog-size 2mb                 # 修改缓冲区大小（默认 1mb）</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Slave</span></span><br><span class="line">slave-serve-stale-data no             # 不允许同步数据时读数据</span><br></pre></td></tr></table></figure>

<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>服务器每次启动都会随机生成一个运行 ID（40 位 16 进制字符） ，Master 和 Slave 之间正是依靠 Master 的运行 ID 相互识别。</p>
<p><img src="/pic/%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD.png" alt="x"></p>
<hr>
<h2 id="Redis-潜在问题"><a href="#Redis-潜在问题" class="headerlink" title="Redis 潜在问题"></a>Redis 潜在问题</h2><h3 id="缓存故障"><a href="#缓存故障" class="headerlink" title="缓存故障"></a>缓存故障</h3><p>Redis 缓存技术常用于高并发情况下，有效减轻服务器和数据库负载。如果 Redis 出现问题导致无法均衡负载，就可能导致服务崩溃。</p>
<ol>
<li><strong>缓存预热</strong></li>
</ol>
<p>当系统刚启动时，<strong>由于 Redis 尚未保存数据导致无法命中</strong>，数据库被频繁请求数据，由于过载导致数据库崩溃。</p>
<p>数据库崩溃后， Redis 和应用服务器无法获取数据，请求积压会进一步导致 Redis 和服务器崩溃。</p>
<ol start="2">
<li><strong>缓存雪崩</strong></li>
</ol>
<p>当流量激增时，<strong>如果 Redis 大量 key 过期导致无法命中</strong>，数据库被频繁请求数据，由于过载导致数据库崩溃。</p>
<p>数据库崩溃后， Redis 和应用服务器无法获取数据，请求积压会进一步导致 Redis 和服务器崩溃。</p>
<ol start="3">
<li><strong>缓存击穿</strong></li>
</ol>
<p>当流量激增时，<strong>如果 Redis 某个极高热度的 key 过期导致无法命中</strong>，数据库被频繁请求数据，由于过载导致数据库崩溃。</p>
<p>数据库崩溃后， Redis 和应用服务器无法获取数据，请求积压会进一步导致 Redis 和服务器崩溃。</p>
<ol start="4">
<li><strong>缓存穿透</strong></li>
</ol>
<p>当流量激增时，<strong>如果 Redis 收到大量非法访问导致无法命中</strong>，数据库被频繁请求数据，由于过载导致数据库崩溃。</p>
<p>数据库崩溃后， Redis 和应用服务器无法获取数据，请求积压会进一步导致 Redis 和服务器崩溃。</p>
<h3 id="一致性问题"><a href="#一致性问题" class="headerlink" title="一致性问题"></a>一致性问题</h3><p>如果在缓存中存储数据库数据备份，以提高查询效率，就一定会出现一致性问题，导致脏读。比如数据库中数据从 1 更新到 10 ，但缓存还未更新时读取，就会读取到 1。这个问题难以避免。 </p>
<ol>
<li>缓存就是缓存，必须要设过期时间。</li>
<li>实时性要求比较高的（比如充值），直接读数据库。</li>
<li>数据库并发高需要分库分表。</li>
</ol>
<hr>
<h2 id="Redis-客户端"><a href="#Redis-客户端" class="headerlink" title="Redis 客户端"></a>Redis 客户端</h2><p>我们在实际使用 Redis 时往往要通过 Redis 客户端，以便在程序中直接操作 Redis 。常使用的 Redis 客户端有 Jedis、 以及功能更为高级的 Redisson、Lettuce 等。</p>
<h3 id="RedisTemplate-类"><a href="#RedisTemplate-类" class="headerlink" title="RedisTemplate 类"></a>RedisTemplate 类</h3><p>Spring Boot 提供了 RedisTemplate 工具类直接对 Redis 进行操作，也提供了 StringRedisTemplate 类继承 RedisTemplate 类，两者方法完全一致。</p>
<ul>
<li><code>RedisTemplate</code> 类：存储数据时序列化成字节数组保存，在 Redis 中数据为字节码。读取数据时自动转化为对象。</li>
<li><code>StringRedisTemplate</code> 类：存储数据直接以字符串形式保存，在 Redis 中数据直接可读。只适用于字符串类型的数据。</li>
</ul>
<p>由于两种序列化方法不同导致的数据存储形式差异，两个类之间不能对另一方存储的 Redis 数据进行操作。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 直接对 key 操作 */</span></span><br><span class="line">redisTemplate.delete(<span class="string">&quot;key&quot;</span>);                                             <span class="comment">// 删除 key</span></span><br><span class="line">redisTemplate.delete(collection);                                        <span class="comment">// 批量删除 key</span></span><br><span class="line">redisTemplate.expire(<span class="string">&quot;key&quot;</span>,<span class="number">10</span>,TimeUnit.MINUTES);                         <span class="comment">// 设置 key 失效时间</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> redisTemplate.getExpire(<span class="string">&quot;key&quot;</span>);                            <span class="comment">// 获取 key 失效时间</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> redisTemplate.hasKey(<span class="string">&quot;key&quot;</span>);                              <span class="comment">// 判断 key 是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作字符串 */</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);                         <span class="comment">// 设置键值对 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)redisTemplate.opsForValue().get(<span class="string">&quot;key&quot;</span>);             <span class="comment">// 获取键值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 操作 hash */</span></span><br><span class="line">redisTemplate.opsForHash().put(<span class="string">&quot;HashKey&quot;</span>, <span class="string">&quot;SmallKey&quot;</span>, <span class="string">&quot;HashValue&quot;</span>);                  <span class="comment">// 设置键值对</span></span><br><span class="line">redisTemplate.boundHashOps(<span class="string">&quot;HashKey&quot;</span>).putAll(hashMap);                               <span class="comment">// 批量设置键值对</span></span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) redisTemplate.opsForHash().get(<span class="string">&quot;HashKey&quot;</span>, <span class="string">&quot;SmallKey&quot;</span>);       <span class="comment">// 获取键值</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">entries</span> <span class="operator">=</span> redisTemplate.opsForHash().entries(<span class="string">&quot;HashKey&quot;</span>);                         <span class="comment">// 获取全部键值对</span></span><br><span class="line">redisTemplate.boundHashOps(<span class="string">&quot;HashKey&quot;</span>).delete(<span class="string">&quot;SmallKey&quot;</span>);                            <span class="comment">// 删除键值对</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">isEmpty</span> <span class="operator">=</span> redisTemplate.boundHashOps(<span class="string">&quot;HashKey&quot;</span>).hasKey(<span class="string">&quot;SmallKey&quot;</span>);          <span class="comment">// 是否含有键值对</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redisTemplate.opsForList();　　 <span class="comment">// 操作 list</span></span><br><span class="line">redisTemplate.opsForSet();　　  <span class="comment">// 操作 set</span></span><br><span class="line">redisTemplate.opsForZSet();　 　<span class="comment">// 操作有序 set</span></span><br></pre></td></tr></table></figure>




<h3 id="Jedis-客户端"><a href="#Jedis-客户端" class="headerlink" title="Jedis 客户端"></a>Jedis 客户端</h3><p>Jedis 基于 Java 实现，是 shell 程序连接 Redis 数据库最常使用的工具。提供了比较全面的 Redis 命令的支持。</p>
<ul>
<li>Jedis 使用阻塞 I/O，且其方法调用都是同步的，程序流需要等到 sockets 处理完 I/O 才能执行。</li>
<li>Jedis 采取直连模式，在多个线程间共享一个 Jedis 实例线程不安全，多线程操作 Redis 必须要使用多个 Jedis 实例。</li>
</ul>
<ol>
<li><strong>导入依赖</strong></li>
</ol>
<p>Spring Boot 2.x 版本 Redis 默认导入了 lettuce，需要排除才能使用 Redis .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li><strong>基本使用</strong></li>
</ol>
<p>使用引入的 Jedis 类即可连接 Redis 数据库并进行操作。操作名取自 Redis 指令，如果出现问题则会抛出 JedisDataException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisTest</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 连接 Redis</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);    </span><br><span class="line">        <span class="comment">// 对 Redis 操作（直接使用 Redis 指令）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;MrJoker&quot;</span>);                  </span><br><span class="line">            System.out.print(jedis.get(<span class="string">&quot;name&quot;</span>));  </span><br><span class="line">        &#125; <span class="keyword">catch</span>(JedisDataException e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;error&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭 Redis 连接</span></span><br><span class="line">            jedis.close();    </span><br><span class="line">        &#125;                                          </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际开发中，创建多个 Redis 连接会非常复杂且难以管理，Jedis 提供了 JedisPool 类作为 Redis 连接池来管理 Redis 连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jedisTest</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">50</span>);                 <span class="comment">// 最大空闲数</span></span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">100</span>);               <span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">20000</span>);        <span class="comment">// 最大等待毫秒数   </span></span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig, <span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="comment">// 从连接池中获取单个连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> pool.getResource();</span><br><span class="line">        <span class="comment">// 如果需要密码</span></span><br><span class="line">        <span class="comment">//jedis.auth(&quot;password&quot;);                                 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Spring Boot 集成</strong></li>
</ol>
<p>Spring Boot 中，我们无需自行创建 Redis 连接，只需要在配置文件中配置好参数。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># REDIS配置</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<p>Spring Boot 提供默认的 RedisTemplate 工具类根据配置文件自动连接 Redis，自动加载后可以直接调用其中的方法去操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;我没有三颗心脏&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 调用工具类方法</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user_1&quot;</span>, user);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user_1&quot;</span>);</span><br><span class="line">        System.out.println(user1.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RedisTemplate 类常用操作</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.delete(key);                                   <span class="comment">// 删除 key</span></span><br><span class="line">redisTemplate.delete(keys);                                  <span class="comment">// 批量删除 key</span></span><br><span class="line">redisTemplate.expire(key,time,TimeUnit.MINUTES);             <span class="comment">// 设置 key 失效时间</span></span><br><span class="line"><span class="type">Long</span> <span class="variable">expire</span> <span class="operator">=</span> redisTemplate.getExpire(key);                  <span class="comment">// 获取 key 失效时间</span></span><br></pre></td></tr></table></figure>

<h3 id="Lettuce-客户端"><a href="#Lettuce-客户端" class="headerlink" title="Lettuce 客户端"></a>Lettuce 客户端</h3><p>更加高级的 Redis 客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。</p>
<ul>
<li>基于 Netty 框架的事件驱动的通信层，其方法调用是异步的。不用浪费线程等待网络或磁盘 I/O。</li>
<li>Lettuce 的 API 是线程安全的，所以可以操作单个 Lettuce 连接来完成各种操作。</li>
</ul>
<ol>
<li><strong>导入依赖</strong></li>
</ol>
<p>在 spring boot 2.x 版本，为 Redis 默认导入了 Lettuce 。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis 默认导入 Lettuce --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 Spring Boot 版本过低，也可以自行导入 Lettuce. Redis 版本至少需要 2.6 .</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单独导入 Lettuce --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>基本使用</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LettuceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSetGet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册连接信息</span></span><br><span class="line">        <span class="type">RedisURI</span> <span class="variable">redisUri</span> <span class="operator">=</span> RedisURI.builder()                    </span><br><span class="line">                .withHost(<span class="string">&quot;localhost&quot;</span>)</span><br><span class="line">                .withPort(<span class="number">6379</span>)</span><br><span class="line">                .withTimeout(Duration.of(<span class="number">10</span>, ChronoUnit.SECONDS))</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 创建 Redis 客户端</span></span><br><span class="line">        <span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(redisUri);   </span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        StatefulRedisConnection&lt;String, String&gt; connection = redisClient.connect();     </span><br><span class="line">        <span class="comment">// 创建同步命令</span></span><br><span class="line">        RedisCommands&lt;String, String&gt; redisCommands = connection.sync();                </span><br><span class="line">        <span class="type">SetArgs</span> <span class="variable">setArgs</span> <span class="operator">=</span> SetArgs.Builder.nx().ex(<span class="number">5</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> redisCommands.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;throwable&quot;</span>, setArgs);</span><br><span class="line">        Assertions.assertThat(result).isEqualToIgnoringCase(<span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        result = redisCommands.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        Assertions.assertThat(result).isEqualTo(<span class="string">&quot;throwable&quot;</span>);</span><br><span class="line">        <span class="comment">/******************** 其他操作 **********************/</span></span><br><span class="line">        connection.close();                     <span class="comment">// 关闭连接</span></span><br><span class="line">        redisClient.shutdown();                 <span class="comment">// 关闭客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lettuce 主要提供三种API：同步（sync）<code>RedisCommands</code>、异步（async）<code>RedisAsyncCommands</code>、反应式（reactive）<code>RedisReactiveCommands</code>。</p>
<ol start="3">
<li><strong>Spring Boot 集成</strong></li>
</ol>
<p>同样在配置文件中配置好参数。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 连接池最大连接数(使用负值表示没有限制) 默认为8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间(使用负值表示没有限制) 默认为-1</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接 默认为8</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接 默认为 0</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<p>我们同样可以使用 Spring Boot 提供默认的 RedisTemplate 工具类根据配置文件自动连接 Redis。但默认情况下的模板只支持 <code>RedisTemplate&lt;String,String&gt;</code> 存入字符串，因此我们往往需要自定义 RedisTemplate 设置序列化器，以方便操作实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Serializable&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// key 采用 String 的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// value 采用 jackson 的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// hash 采用 String/jackson 的序列化方式</span></span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成后即可用自定义的 RedisTemplate 工具类对 Redis 进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Serializable&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:1&quot;</span>;</span><br><span class="line">        redisTemplate.opsForValue().set(key, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;pjmike&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Lettuce<pre><code>  https://www.cnblogs.com/throwable/p/11601538.html
  https://juejin.im/post/6844903681087930375
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL3</title>
    <url>/2023/05/14/%E5%85%B6%E5%AE%83/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MySQL-优化"><a href="#MySQL-优化" class="headerlink" title="MySQL 优化"></a>MySQL 优化</h1><hr>
<h2 id="分表设计"><a href="#分表设计" class="headerlink" title="分表设计"></a>分表设计</h2><ol>
<li>MySQL 数据库限制每个表最多存储 4096 列，并且每一行数据大小不能超过 65535 字节。</li>
<li>数据量到达百万级以上时，会导致修改表结构、备份、恢复都有非常大的困难。</li>
<li>数据量越大，装载进内存缓冲池时所占用的内存也就越大，缓冲池无法一次性装载时就会频繁进行磁盘 IO ，大大降低查询速率。</li>
</ol>
<p>因此当表数据量过大时，就要进行分表操作：</p>
<ul>
<li>水平分表：数据项分开存储。</li>
<li>垂直分表：按字段拆分。</li>
</ul>
<h3 id="分表原则"><a href="#分表原则" class="headerlink" title="分表原则"></a>分表原则</h3><ol>
<li><p>经常一起使用的数据放到一个表中，避免更多的关联操作。</p>
</li>
<li><p>尽量做到冷热数据分离，减小表的宽度，减少磁盘 IO，保证热数据的内存缓存命中率（表越宽，）；更有效的利用缓存，，避免读入无用的冷数据；</p>
</li>
</ol>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>对表进行逻辑拆分的准则。范式级别越高，存储数据冗余越小，但相应表之间的关系也越复杂导致难以维护。一般使用第三范式。</p>
<ul>
<li><p><strong>1NF</strong> 第一范式 关系数据库一定符合条件</p>
</li>
<li><p><strong>2NF</strong> 第二范式 不能产生部分依赖（非主键字段不能被主键中部分字段唯一确定）</p>
</li>
<li><p><strong>3NF</strong> 第三范式 不能存在传递依赖（非主键字段不能被其它非主键字段唯一确定）</p>
</li>
</ul>
<hr>
<h2 id="语句设计"><a href="#语句设计" class="headerlink" title="语句设计"></a>语句设计</h2><h3 id="语句查询"><a href="#语句查询" class="headerlink" title="语句查询"></a>语句查询</h3><ul>
<li><strong>查询语句执行次数</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询数据库各类型语句执行次数</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> [SESSION] STATUS;                      <span class="comment">-- 当前连接</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS;                         <span class="comment">-- 数据库开启后</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> SESSION STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_insert%&#x27;</span>;     <span class="comment">-- 查询插入语句执行次数</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;    <span class="comment">-- Innodb 专用，查询影响行数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查询当前执行语句</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> PROCESSLIST;            <span class="comment">-- 查看数据库所有连接信息，包含正在执行的 SQL 语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> PROFILES;                           <span class="comment">-- 查看当前连接执行的所有指令：ID 和 执行时间</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> PROFILE <span class="keyword">FOR</span> QUERY <span class="number">5</span>;                <span class="comment">-- 显示第 5 条指令执行的具体信息                </span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> PROFILE CPU <span class="keyword">FOR</span> QUERY <span class="number">5</span>;            <span class="comment">-- 显示第 5 条指令各步骤的执行时间</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>解释语句执行方式</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> EXPLAIN 具体语句;                 <span class="comment">-- 解释语句执行的状况（重要）</span></span><br></pre></td></tr></table></figure>

<h3 id="语句优化"><a href="#语句优化" class="headerlink" title="语句优化"></a>语句优化</h3><ol>
<li>fileSort 排序，没有索引时利用文件系统排序，效率低。</li>
<li>index 排序，如果通过索引能直接返回数据，效率高。（只能返回有索引的字段）</li>
</ol>
<p>对于 fileSort 排序，增大排序区大小满足排序需求，可以提高排序效率。</p>
<p>对语句的优化，主要就是对于索引的运用。</p>
<ol>
<li><p>避免使用子查询，可以把子查询优化为 join 操作。子查询不能利用索引。</p>
</li>
<li><p>对应同一列进行 or 判断时，使用 in 代替 or。in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
</li>
</ol>
<p>分组时，默认先排序后分组。会生成临时表。</p>
<ol>
<li>通过 ORDER BY null 不排序直接分组。</li>
<li>上索引，有索引不临时。</li>
</ol>
<h4 id="LIMIT-分页查询"><a href="#LIMIT-分页查询" class="headerlink" title="LIMIT 分页查询"></a>LIMIT 分页查询</h4><p>使用连表查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>;        # 浪费时间，排序 <span class="number">2000000</span> 条后筛选</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student s, (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> student <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">2000000</span>, <span class="number">10</span>) t <span class="keyword">WHERE</span> s.id <span class="operator">=</span> t.id;</span><br></pre></td></tr></table></figure>


<h2 id="优化方式"><a href="#优化方式" class="headerlink" title="优化方式"></a>优化方式</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><p>注意：txt文件各个字段间，要用一个”table”键的距离隔开。一行只写一条数据。批量执行文本中的 SQL 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -&gt;load data infile &#x27;E:/student.txt&#x27; into table student;</span><br></pre></td></tr></table></figure>


<ol>
<li>按主键顺序插入更高效！生成有序 txt 更好。</li>
<li>关闭唯一性校验：<code>SET UNIQUE CHECK = 0</code> ，导入完成后记得开启。</li>
<li>事务提交，手动提交事务：<code>SET AUTOCOMMIt = 0</code> ，导入完成后记得开启。</li>
</ol>
<hr>
<h2 id="批量执行"><a href="#批量执行" class="headerlink" title="批量执行"></a>批量执行</h2><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>1<br>mysqldump -uroot -pMyPassword databaseName tableName1 tableName2 &gt; /home/foo.sql<br>mysqldump -u 用户名 -p 数据库名 数据表名 &gt; 导出的文件名和路径 </p>
<p>导出整个数据库</p>
<p>1<br>mysqldump -u root -p databaseName &gt; /home/test.sql   (输入后会让你输入进入MySQL的密码)<br>mysql导出数据库一个表，包括表结构和数据<br>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名和路径</p>
<p>1<br>mysqldump -u root -p databaseName tableName1 &gt; /home/table1.sql<br>如果需要导出数据中多张表的结构及数据时，表名用空格隔开</p>
<p>1<br>mysqldump -u root -p databaseName tableName01 tableName02 &gt; /home/table.sql<br>仅导出数据库结构</p>
<p>1<br>mysqldump -uroot -pPassWord -d databaseName &gt; /home/database.sql<br>仅导出表结构</p>
<p>1<br>mysqldump -uroot -pPassWord -d databaseName tableName &gt; /home/table.sql<br>将语句查询出来的结果导出为.txt文件<br>1<br>mysql -uroot -pPassword database1 -e “select * from table1” &gt; /home/data.txt
　　</p>
<p>数据导入<br>常用source 命令<br>进入mysql数据库控制台，mysql -u root -p<br>mysql&gt;use 数据库<br>使用source命令，后面参数为脚本文件(.sql) </p>
<p>1<br>mysql&gt;source /home/table.sql</p>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>将大批量、经常重复执行的 SQL 语句集合预存储在数据库里，外部程序可以直接调用，减少了不必要的网络通信代价。</p>
<hr>
<h2 id="SQL-安全"><a href="#SQL-安全" class="headerlink" title="SQL 安全"></a>SQL 安全</h2><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>服务器向数据库发送的 SQL 语句往往包含用户输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 登录验证</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27; 用户输入1 &#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27; 用户输入2 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果攻击者在用户输入中插入 <code>&#39;</code>、<code>or</code>、<code>#</code> ，就可以改变 SQL 语句的功能。达到想要的目的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 返回 alice 用户信息，登录 alice 账号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27; alice&#x27;</span># <span class="string">&#x27; and password = &#x27;</span> 用户输入<span class="number">2</span> <span class="string">&#x27;;</span></span><br><span class="line"><span class="string">-- 返回全部用户信息，通常会默认登录首个账号（管理员）</span></span><br><span class="line"><span class="string">SELECT * FROM users WHERE id = &#x27;</span> <span class="string">&#x27; or 1# &#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27; 用户输入2 &#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27; &#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;1 &#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27; 用户输入2 &#x27;</span>;     <span class="comment">-- AND 优先级高，先执行 AND 再执行 OR</span></span><br><span class="line"> <span class="comment">-- 直接删库</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> users;#<span class="string">&#x27; &#x27;</span> <span class="keyword">and</span> password <span class="operator">=</span> <span class="string">&#x27; 用户输入2 &#x27;</span>;</span><br></pre></td></tr></table></figure>


<p>在执行攻击时，攻击者可能需要知道数据库表信息，譬如表名，列名等。</p>
<ol>
<li>通过错误信息发现（输入错误语句获取）：在进行开发的时候尽量不要把出错信息打印到页面上，使用专门的错误页。</li>
<li>通过盲注发现：</li>
</ol>
<p>比如在用户输入中插入以下字符（如果表名首字母 ASCII 大于 97 则休眠 5s），就可以根据数据返回时间判断数据库表信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27; alice&#x27;</span> <span class="keyword">and</span> if((<span class="keyword">select</span> ascii(substr((<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span> database() limit <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)))<span class="operator">&gt;</span><span class="number">97</span>,sleep(<span class="number">5</span>),<span class="number">1</span>) # <span class="string">&#x27; and password = &#x27;</span> 用户输入<span class="number">2</span> <span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>


<h3 id="SQL-注入防御"><a href="#SQL-注入防御" class="headerlink" title="SQL 注入防御"></a>SQL 注入防御</h3><p>(prepare_statement) 为避免 SQL 注入攻击，新版本后端语言(PHP/Java) 都支持对输入 SQL 语句预处理：会自动检查用户输入并对单引号用<code>\</code>做强制转义， MySQL 数据库收到转义后的单引号也会用 setString 方法做转义处理。</p>
<p>学习网站开发的人就再也不用担心sql注入的威胁了。</p>
<hr>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>InnoDB 用一块内存区做缓存池，既缓存数据也缓存索引。</p>
<p>linux mysql 配置文件 user-my.cnf</p>
<p>innodb_buffer_pool_size = 512M  （默认128m）</p>
<p>innodb_log_buffer_size  日志缓存大小，过于小会频繁写入磁盘</p>
<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><hr>
]]></content>
      <categories>
        <category>其它</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><hr>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="简单分类"><a href="#简单分类" class="headerlink" title="简单分类"></a>简单分类</h3><ol>
<li><strong>Windows</strong>： 微软公司的操作系统。</li>
<li><strong>Mac</strong>： 苹果公司的类 Unix 操作系统。</li>
<li><strong>Linux</strong>： 基于 Linux 内核的类 Unix 操作系统总称，如 Ubuntu 和 CentOS 。</li>
</ol>
<p><em>Unix 是最早的多用户、多任务操作系统。</em></p>
<hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、输入输出设备、普通文件或是目录都被看作是一个文件。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p><strong>Linux 支持 5 种文件类型 ：</strong></p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td>存储信息和数据</td>
<td>代码、可执行文件、图片</td>
</tr>
<tr>
<td>目录文件</td>
<td>管理文件和子目录</td>
<td>文件夹</td>
</tr>
<tr>
<td>链接文件</td>
<td>不同目录下文件共享</td>
<td>对于每个符号链接，都由系统创建链接文件指向具体位置</td>
</tr>
<tr>
<td>设备文件</td>
<td>访问硬件设备</td>
<td>键盘、鼠标</td>
</tr>
<tr>
<td>命名管道</td>
<td>进程之间的通信</td>
<td></td>
</tr>
</tbody></table>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录 <strong>/root</strong>：</p>
<p><strong>常见子目录说明：</strong></p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong>  存放系统管理和配置文件；</li>
<li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li>
<li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong>  超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong>  存放二进制可执行文件，只有 root 才能访问。通常存放系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li>
<li><strong>/dev：</strong> 用于存放设备文件；</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong>  存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong>   存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong>  这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>Linux命令大全：<a href="http://man.linuxde.net/">http://man.linuxde.net/</a></p>
<h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul>
<li><strong><code>cd usr</code>：</strong>   切换到该目录下usr目录  </li>
<li><strong><code>cd ..（或cd../）</code>：</strong>  切换到上一层目录 </li>
<li><strong><code>cd /</code>：</strong>   切换到系统根目录  </li>
<li><strong><code>cd ~</code>：</strong>   切换到用户主目录 </li>
<li><strong><code>cd -</code>：</strong>   切换到上一个操作所在目录</li>
</ul>
<h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><ol>
<li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p>
</li>
<li><p>**<code>ls或者ll</code>**（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p>
</li>
<li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p>
<p> 示例：</p>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li>
<li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li>
<li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; </code></li>
</ul>
</li>
<li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p>
<p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行  重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p>
</li>
<li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong>  移动目录的位置—剪切（改）</p>
<p> 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
</li>
<li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝 </p>
<p> 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不  用写-r递归</p>
</li>
<li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p>
<p> 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，  无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p>
</li>
</ol>
<h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ol>
<li><p><strong><code>touch 文件名称</code>:</strong>  文件的创建（增）</p>
</li>
<li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p>
<ul>
<li><strong><code>cat</code>：</strong> 查看显示文件内容</li>
<li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li>
<li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li>
<li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，  会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 </p>
</li>
<li><p><strong><code>vim 文件</code>：</strong>  修改文件的内容（改）</p>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p>
<p> vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件  ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p>
</li>
<li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p>
<p> 同目录删除：熟记 <code>rm -rf</code> 文件 即可</p>
</li>
</ol>
<h3 id="文件压缩命令"><a href="#文件压缩命令" class="headerlink" title="文件压缩命令"></a>文件压缩命令</h3><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：**<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>**<br>其中：</p>
<p>  z：调用gzip压缩命令进行压缩</p>
<p>  c：打包文件</p>
<p>  v：显示运行过程</p>
<p>  f：指定文件名</p>
<p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code>**</p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：tar [-xvf] 压缩文件</p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C代表指定解压的位置）</p>
<h3 id="操作权限命令"><a href="#操作权限命令" class="headerlink" title="操作权限命令"></a>操作权限命令</h3><p> 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong><code>ls -l</code></strong> 命令我们可以  查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/1646955be781daaa?w=589&h=228&f=png&s=16360"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16469565b6951791?w=489&h=209&f=png&s=39791"></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是window中的快捷方式）</li>
</ul>
<p><strong>Linux中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r也可以用数字4表示</li>
<li>w：代表权限是可写，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p> 对文件和目录而言，读写执行表示不同的意义。</p>
<p> 对于文件：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以使用cat查看文件的内容</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以修改文件的内容</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p> 对于目录：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以查看目录下列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以使用cd进入目录</td>
</tr>
</tbody></table>
<p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong><br><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><p><strong>所有者</strong></p>
<p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名  文件名来修改文件的所有者 。</p>
</li>
<li><p><strong>文件所在组</strong></p>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp  组名  文件名来修改文件所在的组。 </p>
</li>
<li><p><strong>其它组</strong></p>
<p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 </p>
</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件/目录的权限。</p>
</blockquote>
<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/164697447dc6ecac?w=525&h=246&f=png&s=12362"></p>
<p>上述示例还可以使用数字表示：</p>
<p>chmod 764 aaa.txt</p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本zookeeper</li>
<li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code> chkconfig --add  zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>:  清除用户密码</li>
</ul>
<p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>
<p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<p><strong>用户组</strong></p>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<p><strong>Linux系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**<code>ps aux|grep redis</code>** （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
</li>
<li><p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping </li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><p><strong>net-tools 和 iproute2 ：</strong><br>  <code>net-tools</code>起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持<code>iproute2</code>。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux">如何在Linux中使用IP命令和示例</a></p>
</li>
<li><p><strong><code>shutdown</code>：</strong>  <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li><p><strong><code>reboot</code>：</strong>  <strong><code>reboot</code>：</strong>  重开机。**<code>reboot -w</code>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><hr>
<h2 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h2><p>将应用层的报文封装到传输层中，使用 TCP 或者 UDP 协议建立两个主机进程之间的端对端通信，</p>
<p>传输层会自动对上层数据进行分用和复用：不同的应用层报文可封装到同一个传输层报文中传输，到达后再拆分报文交付给应用层中的各个进程。通信双方根据套接字（IP 地址 + 端口号）相互识别。</p>
<hr>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p><strong>UDP 提供不可靠但高效的、无连接的服务</strong>：</p>
<ol>
<li><p>在传送数据之前不需要建立连接，远地主机在收到 UDP 报文后也不需要给出任何确认（只检测报文检验和，出现错误直接丢弃）。</p>
</li>
<li><p>一般用于即时通信，如语音、视频、直播等场景。</p>
</li>
</ol>
<hr>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p><strong>TCP 提供可靠的、面向连接的服务</strong>：</p>
<ol>
<li><p>在传送数据之前必须先建立连接，数据传送结束后要释放连接。传输过程中会校验数据并返回确认，保证可靠性。</p>
</li>
<li><p>一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
</li>
</ol>
<h3 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h3><h4 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h4><p>建立 TCP 协议采用了三次握手策略：SYN 是 TCP/IP 建立连接时使用的握手信号，接收者到后以 ACK 信号响应（序号加一）。</p>
<ol>
<li>客户端向服务端 发送带有 SYN 标志的数据包（客户端请求连接）</li>
<li>服务端向客户端 发送带有 SYN/ACK 标志的数据包（客户端可以正常发送消息）</li>
<li>客户端向服务端 发送带有带有 ACK 标志的数据包（服务端可以正常发送消息，连接建立）</li>
</ol>
<h4 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h4><p>断开 TCP 连接采用了四次挥手策略：FIN 是 TCP/IP 断开连接时使用的终止信号，接收者到后以 ACK 信号响应（序号加一）。</p>
<ol>
<li>客户端向服务端 发送带有 FIN 标志的数据包（客户端请求终止）</li>
<li>服务器向客户端 发送带有 ACK 标志的数据包（客户端不再发送消息，连接半关闭）</li>
<li>服务器向客户端 发送带有 FIN 标志的数据包（服务端请求终止）</li>
<li>客户端向服务端 发送带有 ACK 标志的数据包（服务端不再发送消息，连接关闭）</li>
</ol>
<h3 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h3><h4 id="编号和校验和"><a href="#编号和校验和" class="headerlink" title="编号和校验和"></a>编号和校验和</h4><ul>
<li><strong>编号</strong></li>
</ul>
<p>发送方将应用报文分割成 TCP 报文段后，会为每一个报文段进行编号。由接收方对数据包进行排序，再把有序数据传送给应用层。</p>
<p>如果收到重复报文段，直接丢弃。</p>
<ul>
<li><strong>校验和</strong></li>
</ul>
<p>发送方会计算 TCP 报文段全部数据的检验和，并保存在报文段首部。由接收方对数据包数据进行检验。</p>
<p>如果收到错误报文段，丢弃报文段，并返回错误消息等待重发。</p>
<blockquote>
<p>IP 协议校验和只校验首部， TCP 协议校验全部数据。</p>
</blockquote>
<p><strong>ARQ 协议</strong></p>
<p>（自动重传请求）发送方发送报文段后，会等待接收方 ACK。如果接收到错误消息或等待超时，将重发这个报文段。用来实现可靠传输。</p>
<p>现在一般使用连续 ARQ 协议：维持一个发送窗口，可以连续发送出去多个报文段而不需要等待对方确认。接收方对按序到达的最后一个报文段发送确认，即表明之前的所有报文段都已经正确收到。提高信道利用率。</p>
<p><em>如果发送方连续发送了 5 条消息，其中 3 号消息丢失。接收方只会对前两个消息发送确认。发送方必须对后三条消息全部重传。</em></p>
<h4 id="流量控制和阻塞控制"><a href="#流量控制和阻塞控制" class="headerlink" title="流量控制和阻塞控制"></a>流量控制和阻塞控制</h4><ul>
<li><p><strong>流量控制</strong>：减少数据发送，防止接收方过载导致数据无法处理。</p>
</li>
<li><p><strong>拥塞控制</strong>： 减少数据发送，防止网络阻塞导致数据无法到达。</p>
</li>
</ul>
<p>发送方允许连续发送的分组上限受以上两个因素制约，即 <code>发送窗口 = min (接收窗口, 阻塞窗口)</code>。</p>
<ol>
<li><p>接收窗口大小由 接收方返回的确认报文中的窗口字段设定。</p>
</li>
<li><p>拥塞窗口大小根据网络的拥塞程度动态变化，TCP 拥塞窗口变化采取了慢开始、拥塞避免、快重传 和 快恢复 四种策略。</p>
</li>
</ol>
<hr>
<h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket在建立网络连接时使用。连接成功时应用程序两端都会产生一个Socket实例指向对方，完成所需的会话。</p>
<p><strong>服务器端</strong></p>
<ol>
<li>创建ServerSocket对象，绑定监听端口监听客户端请求。</li>
<li>接收客户端请求，创建Socket与该客户建立专线连接（多线程）。</li>
<li>双方通过输入输出流进行对话。</li>
<li>关闭流和套接字，继续等待新的连接。</li>
</ol>
<p><strong>客户端</strong></p>
<ol>
<li>创建Socket对象，指明需要连接的服务器地址和端口号。</li>
<li>连接建立后，通过输出流向服务器发送请求信息。</li>
<li>双方通过输入输出流进行对话。</li>
<li>关闭流和套接字。</li>
</ol>
<p><strong>创建Socket对象</strong></p>
<p><code>ServerSocket server = new ServerSocket(55533);</code></p>
<p>创建ServerSocket对象，并指定服务器端接口</p>
<p><code>Socket socket = new Socket(127.0.0.1, 55533);</code></p>
<p>创建Socket对象，并指明对方主机和接口</p>
<p><strong>监听端口</strong></p>
<p><code>Socket socket = server.accept();</code></p>
<p>ServerSocket接收请求，并且返回一个客户端的Socket对象实例。</p>
<p>Accept方法用于产生“阻塞”（由循环产生），使程序运行停在这个地方，直到一个会话产生。</p>
<p><strong>进行对话</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开输出流</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line"><span class="comment">//输出信息（字节流）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">out.write(message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">out.write(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"><span class="comment">//关闭输出流</span></span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>

<p>输出流输出信息，另一端输入流将得到输入。失败则抛出<code>IOException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打开输入流（转化为字节流被缓冲流读取）</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//输入信息(接收到end字符则结束)</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">while</span> ((str = in.readLine()) != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;end&quot;</span>.equals(str)) &#123;</span><br><span class="line">  message.append(str);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;get message: &quot;</span> + message);</span><br><span class="line"><span class="comment">//关闭输入流</span></span><br><span class="line">in.close(); <span class="comment">//socket.shutdownOutput();</span></span><br></pre></td></tr></table></figure>

<p>输入流输入信息，得到另一端输出流信息。失败则抛出<code>IOException</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketClient</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//与本地服务器端建立连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(host, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制台输入并向服务器端输出</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in, <span class="string">&quot;UTF-8&quot;</span>));      </span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(socket.getOutputStream()));         </span><br><span class="line">    <span class="keyword">while</span> (str != <span class="string">&quot;end&quot;</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bufferedReader.readLine();</span><br><span class="line">      bufferedWriter.write(str + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      bufferedWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    outputStream.close();</span><br><span class="line">    socket.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 监听指定的端口</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环等待请求</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="comment">//建立连接</span></span><br><span class="line">      <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> server.accept();</span><br><span class="line">      <span class="comment">//从socket中获取输入流并读取</span></span><br><span class="line">      <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">      String str;，</span><br><span class="line">      <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get message from client:&quot;</span> + str);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭连接</span></span><br><span class="line">      inputStream.close();</span><br><span class="line">      socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1&gt; 多线程</strong></p>
<p>每有一个Socket请求的时候，就创建一个线程来处理它。（通常交给线程池管理，保证线程的复用）</p>
<p>能够循环处理多个Socket请求，否则一个请求的处理耗时，后面的请求将被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务器端（线程池管理）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 监听指定的端口</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">55533</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//循环等待请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">            <span class="comment">//分配线程</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//从socket中获取输入流并读取</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(socket.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                    String str;</span><br><span class="line">                    <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;get message from client:&quot;</span> + str);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            executorService.submit(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2&gt; 规范流输入输出长度</strong></p>
<p>在实际应用中，socket发送的数据并不是按行发送。我们就不会每次发送数据，都用“\n”标识区分是否发送完毕。</p>
<p>在实际应用中，我们通过是采用数据长度+类型+数据的方式来告知一次流输入完成，方便进行后续操作。</p>
<p><a href="https://blog.csdn.net/qq_33865313/article/details/79363640">https://blog.csdn.net/qq_33865313/article/details/79363640</a></p>
<p><a href="https://www.cnblogs.com/huanzi-qch/p/9889521.html">https://www.cnblogs.com/huanzi-qch/p/9889521.html</a></p>
<p>Socket的消息推送机制中，用的都是 Ajax 轮询。在特定的时间间隔由客户端自动发出请求，将服务器的消息主动拉回来（服务器启动一个线程去监听与此客户端的通信），这种方式是非常消耗资源的，因为它本质还是http请求，而且显得非常笨拙：服务端不能主动向客户端推送数据。</p>
<p>####WebSocket类</p>
<p><code>import javax.websocket.*;</code></p>
<p>WebSocket 在浏览器和服务器完成一个握手的动作，在建立连接之后，服务器可以主动传送数据给客户端，客户端也可以随时向服务器发送数据。多客户端、涉及有界面的聊天建议使用websocket（嵌入到了浏览器的内核中）。</p>
<p><a href="https://www.cnblogs.com/interdrp/p/7903736.html">https://www.cnblogs.com/interdrp/p/7903736.html</a></p>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统理论</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><hr>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>操作系统(Operation System) 是负责管理计算机硬件与软件资源的软件程序，同时为用户提供一个与系统交互的操作界面。</p>
<ul>
<li><strong>内核</strong>：能操作硬件，用于提供系统服务。比如文件管理、虚拟内存、设备 I/O 等。</li>
<li><strong>外壳</strong>：围绕内核，为用户提供服务的应用程序。</li>
</ul>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>出于安全考虑，计算机不允许操作系统外的其它软件执行特权指令：</p>
<ol>
<li>执行用户程序时 CPU 工作在用户态(user mode)</li>
<li>执行操作系统时 CPU 工作在系统态(kernel mode)</li>
</ol>
<p>用户程序如果想实现以下功能，就必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<ul>
<li>设备管理：设备的启动、请求和释放。</li>
<li>进程管理：进程的状态切换、通信。</li>
<li>内存管理：内存的分配回收、获取作业占用内存区大小及地址。</li>
<li>文件管理：文件的读写、创建及删除。</li>
</ul>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>用户态向核心态的切换由硬件实现，可通过中断或异常触发。</p>
<ul>
<li>中断（外中断）：接收到外部中断指令、时间片结束等方式触发。中断原因和当前程序无关。</li>
<li>异常（内中断）：当前程序执行出错，如地址越界、算术溢出、虚存缺页等触发。也可以被陷入指令触发。</li>
</ul>
<hr>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><ul>
<li>Cache</li>
<li>主存</li>
<li>辅存</li>
</ul>
<h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><p>CPU 可以对内存直接读写数据，但不能直接对外部设备（如磁盘）读写数据。</p>
<p>进程进行一次作业时，必须将要使用的磁盘数据全部置换到内存中供 CPU 使用。直到作业结束，才允许释放内存空间。</p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>我们将内存空间分为固定大小的页，磁盘分为大小相同的块。进程调用连续数据块时，会分散置换到内存的各个空闲页中被 CPU 使用。</p>
<p>这样不连续的存储方式，可以显著提高内存利用率。如果为每个进程分配连续的内存空间，当内存空间大小发生动态变化时，会产生大量内存碎片。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>负责查找进程在内存中分散存储的内存页。每个进程拥有一个页表，映射进程页的逻辑地址和物理地址。便于查找。</p>
<ul>
<li><strong>多级页表</strong></li>
</ul>
<p>页表也存储在内存页中。当进程使用大量存储空间时，页表也会占用多个内存页，导致查询效率降低。</p>
<p>因此我们为页表建立页表，建立层次结构。方便快速查询到页表项。通过虚拟内存技术把部分二级页表置换到磁盘中，也可以节省内存空间。</p>
<ul>
<li><strong>TLB（快表）</strong> </li>
</ul>
<p>使用 Cache 存储，负责映射最近使用的内存页逻辑地址和物理地址。对高频数据的访问可以不经过内存，加速查找。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><hr>
<h2 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h2><p>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p><strong>Linux 支持 5 种文件类型 ：</strong></p>
<table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td>存储信息和数据</td>
<td>代码、可执行文件、图片</td>
</tr>
<tr>
<td>目录文件</td>
<td>管理文件和子目录</td>
<td>文件夹</td>
</tr>
<tr>
<td>链接文件</td>
<td>不同目录下文件共享</td>
<td>对于每个符号链接，都由系统创建链接文件指向具体位置</td>
</tr>
<tr>
<td>设备文件</td>
<td>访问硬件设备</td>
<td>键盘、鼠标</td>
</tr>
<tr>
<td>命名管道</td>
<td>进程之间的通信</td>
<td></td>
</tr>
</tbody></table>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录 <strong>/root</strong>：</p>
<p><strong>常见子目录说明：</strong></p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong>  存放系统管理和配置文件；</li>
<li><strong>/home：</strong>  存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li>
<li><strong>/proc：</strong>  虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong>  超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong>  存放二进制可执行文件，只有 root 才能访问。通常存放系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li>
<li><strong>/dev：</strong> 用于存放设备文件；</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong>  存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong>   存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong>  这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li>
</ul>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>Linux命令大全：<a href="http://man.linuxde.net/">http://man.linuxde.net/</a></p>
<h3 id="目录切换命令"><a href="#目录切换命令" class="headerlink" title="目录切换命令"></a>目录切换命令</h3><ul>
<li><strong><code>cd usr</code>：</strong>   切换到该目录下usr目录  </li>
<li><strong><code>cd ..（或cd../）</code>：</strong>  切换到上一层目录 </li>
<li><strong><code>cd /</code>：</strong>   切换到系统根目录  </li>
<li><strong><code>cd ~</code>：</strong>   切换到用户主目录 </li>
<li><strong><code>cd -</code>：</strong>   切换到上一个操作所在目录</li>
</ul>
<h3 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h3><ol>
<li><p><strong><code>mkdir 目录名称</code>：</strong> 增加目录</p>
</li>
<li><p>**<code>ls或者ll</code>**（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</p>
</li>
<li><p><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）</p>
<p> 示例：</p>
<ul>
<li>列出当前目录及子目录下所有文件和文件夹: <code>find .</code></li>
<li>在<code>/home</code>目录下查找以.txt结尾的文件名:<code>find /home -name &quot;*.txt&quot;</code></li>
<li>同上，但忽略大小写: <code>find /home -iname &quot;*.txt&quot;</code></li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:<code>find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)</code>或<code>find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; </code></li>
</ul>
</li>
<li><p><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）</p>
<p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行  重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p>
</li>
<li><p><strong><code>mv 目录名称 目录的新位置</code>：</strong>  移动目录的位置—剪切（改）</p>
<p> 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
</li>
<li><p><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r代表递归拷贝 </p>
<p> 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不  用写-r递归</p>
</li>
<li><p><strong><code>rm [-rf] 目录</code>:</strong> 删除目录（删）</p>
<p> 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆，  无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包</p>
</li>
</ol>
<h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ol>
<li><p><strong><code>touch 文件名称</code>:</strong>  文件的创建（增）</p>
</li>
<li><p><strong><code>cat/more/less/tail 文件名称</code></strong> 文件的查看（查）</p>
<ul>
<li><strong><code>cat</code>：</strong> 查看显示文件内容</li>
<li><strong><code>more</code>：</strong> 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li>
<li><strong><code>less</code>：</strong> 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li>
<li><strong><code>tail-10</code> ：</strong> 查看文件的后10行，Ctrl+C结束</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件，  会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 </p>
</li>
<li><p><strong><code>vim 文件</code>：</strong>  修改文件的内容（改）</p>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<p><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></p>
<p> vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件  ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p>
</li>
<li><p><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）</p>
<p> 同目录删除：熟记 <code>rm -rf</code> 文件 即可</p>
</li>
</ol>
<h3 id="文件压缩命令"><a href="#文件压缩命令" class="headerlink" title="文件压缩命令"></a>文件压缩命令</h3><p><strong>1）打包并压缩文件：</strong></p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。<br>命令：**<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>**<br>其中：</p>
<p>  z：调用gzip压缩命令进行压缩</p>
<p>  c：打包文件</p>
<p>  v：显示运行过程</p>
<p>  f：指定文件名</p>
<p>比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：**<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code>或：<code>tar -zcvf test.tar.gz       /test/</code>**</p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：tar [-xvf] 压缩文件</p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：**<code>tar -xvf test.tar.gz</code>**</p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:**<code>tar -xvf test.tar.gz -C /usr</code>**（- C代表指定解压的位置）</p>
<h3 id="操作权限命令"><a href="#操作权限命令" class="headerlink" title="操作权限命令"></a>操作权限命令</h3><p> 操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong><code>ls -l</code></strong> 命令我们可以  查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/1646955be781daaa?w=589&h=228&f=png&s=16360"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/16469565b6951791?w=489&h=209&f=png&s=39791"></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是window中的快捷方式）</li>
</ul>
<p><strong>Linux中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r也可以用数字4表示</li>
<li>w：代表权限是可写，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p> 对文件和目录而言，读写执行表示不同的意义。</p>
<p> 对于文件：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以使用cat查看文件的内容</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以修改文件的内容</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p> 对于目录：</p>
<table>
<thead>
<tr>
<th align="left">权限名称</th>
<th align="right">可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td align="left">r</td>
<td align="right">可以查看目录下列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td align="left">x</td>
<td align="right">可以使用cd进入目录</td>
</tr>
</tbody></table>
<p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong><br><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><p><strong>所有者</strong></p>
<p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名  文件名来修改文件的所有者 。</p>
</li>
<li><p><strong>文件所在组</strong></p>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp  组名  文件名来修改文件所在的组。 </p>
</li>
<li><p><strong>其它组</strong></p>
<p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 </p>
</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件/目录的权限。</p>
</blockquote>
<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，<br>其他用户只有读的权限</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/5/164697447dc6ecac?w=525&h=246&f=png&s=12362"></p>
<p>上述示例还可以使用数字表示：</p>
<p>chmod 764 aaa.txt</p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本zookeeper</li>
<li>为新建的脚本zookeeper添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把zookeeper这个脚本添加到开机启动项里面，命令是：<code> chkconfig --add  zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>:  清除用户密码</li>
</ul>
<p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>
<p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<p><strong>用户组</strong></p>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<p><strong>Linux系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li><p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，–color代表高亮显示</p>
</li>
<li><p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：**<code>ps aux|grep redis</code>** （查看包括redis字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
</li>
<li><p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用ps查找进程，然后用kill杀掉</p>
</li>
<li><p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping </li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><p><strong>net-tools 和 iproute2 ：</strong><br>  <code>net-tools</code>起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持<code>iproute2</code>。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux">如何在Linux中使用IP命令和示例</a></p>
</li>
<li><p><strong><code>shutdown</code>：</strong>  <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 &quot;System will shutdown after 5 minutes&quot;</code>：指定5分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li><p><strong><code>reboot</code>：</strong>  <strong><code>reboot</code>：</strong>  重开机。**<code>reboot -w</code>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><hr>
<h2 id="应用层功能"><a href="#应用层功能" class="headerlink" title="应用层功能"></a>应用层功能</h2><p>在应用进程间传输报文，实现特定类型的数据交互，去执行特定的功能。</p>
<hr>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>（超文本传输协议）负责发布和接收 HTML 页面和其他 Web 资源，即 Web 通信。底层通信通过 TCP 协议实现，默认端口号 80 。</p>
<h3 id="资源定位"><a href="#资源定位" class="headerlink" title="资源定位"></a>资源定位</h3><p>HTTP 协议通过 <strong>URL</strong> 来访问资源。URL 即 WEB 内容访问标识符，是一种具体的 URI。不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<p>通用格式为：<code>协议://IP地址或域名:端口号/文件路径?参数</code> ，如 <a href="http://localhost:443/student?id=10&amp;name=mrjoker">http://localhost:443/student?id=10&amp;name=mrjoker</a></p>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><ul>
<li><strong>HTTP/1.0</strong> </li>
</ul>
<p>默认使用短连接：访问页面时，客户端和服务器之间每次 HTTP 操作都会单独使用一次 TCP 连接，传输完毕后自动关闭。</p>
<p>客户端和服务器之间都会建立多个 HTTP 会话，开销较大。</p>
<ul>
<li><strong>HTTP/1.1</strong> </li>
</ul>
<p>默认使用长连接：访问页面时，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，直到 HTML 页面调用的所有 web 资源传输完毕。</p>
<p>长连接会在 HTTP 响应头标注：<code>Connection:keep-alive</code>  </p>
<p>但 HTTP/1.1 是串行化处理所有 web 资源请求。一旦有请求无法正常加载，后续请求就会被阻塞。</p>
<ul>
<li><strong>HTTP/2</strong> </li>
</ul>
<p>增加了多路复用功能：让所有数据流共用同一个连接。接收到客户端 HTTP 请求后，服务器会一次性把所需要的 web 资源打包发送。</p>
<ol>
<li>即使有请求无法正常加载，也不会影响处理其它 web 资源请求。</li>
<li>TCP 连接在刚开始发送数据时会限制连接的最大速度，集中发送能更有效地利用 TCP 连接。</li>
</ol>
<h3 id="请求类型"><a href="#请求类型" class="headerlink" title="请求类型"></a>请求类型</h3><p>HTTP 请求有以下四种常用类型：</p>
<ul>
<li><p><strong>GET</strong>：请求服务器数据，请求参数直接附在 URL 上（不够安全，仅适用于简单公开数据的请求和提交）</p>
</li>
<li><p><strong>POST</strong>：向服务器提交数据，数据以表单形式提交（内容长度无上限，且不会被浏览器记录）</p>
</li>
<li><p><strong>PUT</strong>：修改服务器数据（慎用）</p>
</li>
<li><p><strong>DELETE</strong>：删除服务器数据（慎用）</p>
</li>
</ul>
<p>除此之外 HTTP 协议在正式通信前还可能发出 <strong>OPTION</strong> 请求：先询问服务器当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p>
<h3 id="主机识别"><a href="#主机识别" class="headerlink" title="主机识别"></a>主机识别</h3><p>HTTP 协议是无状态协议，本身不保存请求和响应之间的通信状态。</p>
<p>也就是说通信过后服务器将无法相互识别客户端，因此我们必须引入其他方式让服务器记录客户端的信息。</p>
<h4 id="Session-amp-Cookie"><a href="#Session-amp-Cookie" class="headerlink" title="Session &amp; Cookie"></a>Session &amp; Cookie</h4><p>负责记录对方主机信息，在 HTTP 通信中相互识别。cookie 保存在客户端，session 保存在服务器端。</p>
<ol>
<li><p>客户端初次访问服务器时，服务端会自动创建 session 用来标识用户。然后在响应头 Set-Cookie 项向客户端返回 session ID。</p>
</li>
<li><p>客户端再次访问服务器时，会在请求头 Cookie 项向服务器发送 session ID，服务器根据 ID 查询 Session 就可以识别用户。</p>
</li>
</ol>
<p><em>用户和通信的详细信息通常记录在 session 中，cookie 中只保存 session ID ，以避免信息泄露。如果客户端 cookie 被禁用，就需要利用 URL 重写把 session ID 直接附加在 URL 路径上。</em></p>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>token 和 session ID 功能相同，都用来在 HTTP 通信中识别用户，过期刷新：</p>
<ul>
<li>session ID 由服务器随机生成，保存在服务器 session 中。再次访问时只需要直接比对，就可以确认客户端身份。</li>
<li>token 由服务器根据用户 ID 和时间戳经过特定算法生成，服务器不保存。再次访问时服务器需要重新计算并比对，才可以确认客户端身份。</li>
</ul>
<p><em>cookie 本身不安全，浏览器中 token 除放在 cookie 外，还可以放到 localStorage 中存储。浏览器发送请求时会自动携带 session ID，但发送 token 需要手动在代码中设置。由于浏览器加载 image 标签中的地址也会发送 session ID，因此使用 token 可以有效防止 CSRF 攻击。</em></p>
<p>localStorage和sessionStorage的区别;<br>localStorage生命周期是永久，除非用户手动清除，否则这些信息将永远存在。<br>sessionStorage生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，数据也就被清空了。</p>
<hr>
<h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="HTTPS 协议"></a>HTTPS 协议</h2><p>由于 HTTP 协议使用明文在互联网传送数据，易被不法分子监听和截获。我们又引入了 HTTPS 协议取而代之，默认端口 443。</p>
<p>HTTPS 协议在应用层下方增加了 SSL 层，使用 TLS 协议来加密和解密数据包，这样在互联网上传送的数据将经过加密。</p>
<h3 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h3><ol>
<li><p>建立连接后的数据交互采用<strong>对称加密</strong>：加密密钥和解密密钥相同。</p>
</li>
<li><p>建立连接时协商密钥采用<strong>非对称加密</strong>：加密密钥和解密密钥不同，两个密钥互相能解密对方的加密内容。</p>
<p>服务器会公开一个非对称加密密钥（公钥），并保留一个非对称加密码密钥（私钥）。</p>
</li>
</ol>
<h3 id="证书认证"><a href="#证书认证" class="headerlink" title="证书认证"></a>证书认证</h3><p>服务器公钥由数字认证机构 CA 统一认证。CA 会用自己的私钥加密服务器公钥和相应信息，生成数字证书。在客户端向 CA 查询时将证书发送给客户端核对。</p>
<p>CA 根证书（包含公钥）存储在用户的浏览器中，访问网址时会自动比对服务器公钥。</p>
<ol>
<li>客户端向服务器发送信息：请求连接，说明自己支持的加密算法，并给出随机数 A。</li>
<li>服务器向客户端发送信息：同意连接请求，确认合适的加密算法，并给出数字证书和随机数 B。</li>
<li>客户端向 CA 核对数字证书，确认有效后得到服务器公钥。</li>
</ol>
<h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><ol start="4">
<li>客户端向服务器发送公钥加密信息：给出随机数 C。</li>
<li>服务器通过私钥解密信息，对信息 Hash 得到数字签名；然后向客户端发送私钥加密信息：返回数字签名。</li>
<li>客户端通过公钥解密信息，核对数字签名，确认服务器收到随机数 C。</li>
</ol>
<p>之后双方就可以按照约定的对称加密方法，使用三个随机数生成的密钥进行数据交互。</p>
<hr>
<h2 id="HTTP-通信"><a href="#HTTP-通信" class="headerlink" title="HTTP 通信"></a>HTTP 通信</h2><p>Java 程序执行 HTTP 通信的类定义在 java.net 包内，使用时需进行导入。</p>
<p><strong>基本通信方式</strong>：创建连接对象 》设置连接参数和请求属性 》建立连接并发送请求 》读取响应内容 》关闭连接</p>
<h3 id="创建连接对象"><a href="#创建连接对象" class="headerlink" title="创建连接对象"></a>创建连接对象</h3><ul>
<li><p><strong>URL 类</strong>：标记定向资源所在位置，如果格式错误则抛出 <code>IOException</code>。</p>
</li>
<li><p><strong>URLConnection 类</strong>：读取和写入 URL 类定向的资源，在 HTTP 协议中常用 HttpURLConnection 子类。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">myUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="type">HttpURLConnection</span> <span class="variable">myCon</span> <span class="operator">=</span> (HttpURLConnection)myUrl.openConnetcion();</span><br></pre></td></tr></table></figure>

<h3 id="配置连接"><a href="#配置连接" class="headerlink" title="配置连接"></a>配置连接</h3><p><strong>设置请求参数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.setRequestMethod(<span class="string">&quot;POST&quot;</span>);         <span class="comment">// 设置连接方法（默认使用GET）</span></span><br><span class="line"></span><br><span class="line">myCon.setDoInput(<span class="literal">true</span>);                 <span class="comment">// 允许进行字符流输入: myCon.getInputStream().read();</span></span><br><span class="line">myCon.setDoOutput(<span class="literal">true</span>);                <span class="comment">// 允许进行字符流输出: myCon.getOutputStream().write();</span></span><br><span class="line"></span><br><span class="line">myCon.setRequestMethod(<span class="number">1000</span>);           <span class="comment">// 设置最长建立连接时间，若超时则抛出 SocketTimeoutException</span></span><br><span class="line">myCon.setRequestMethod(<span class="number">1000</span>);           <span class="comment">// 设置最长数据读取时间，若超时则抛出 SocketTimeoutException</span></span><br></pre></td></tr></table></figure>

<p><strong>设置请求属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置版本</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;version&quot;</span>, <span class="string">&quot;1.2.3&quot;</span>);            </span><br><span class="line"><span class="comment">// 设置浏览器类型（常用于爬虫伪装）</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible;  Windows NT 5.1;SV1)&quot;</span>);</span><br><span class="line"><span class="comment">// 设置发送文本类型</span></span><br><span class="line">myCon.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="连接并发送请求"><a href="#连接并发送请求" class="headerlink" title="连接并发送请求"></a>连接并发送请求</h3><ul>
<li><strong>connect 方法</strong>：建立连接并发送请求.</li>
<li><strong>getOutputStream 方法</strong>：关闭输出流时自动建立连接并发送输出流请求.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.connect();</span><br><span class="line"></span><br><span class="line"><span class="type">OutputStreamWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(myCon.getOutputStream());</span><br><span class="line">out.write(str);                  </span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>


<h3 id="获取响应数据"><a href="#获取响应数据" class="headerlink" title="获取响应数据"></a>获取响应数据</h3><p><strong>获取响应头信息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.getResponseCode();        <span class="comment">// 获取响应码（200为连接成功，404为未找到）</span></span><br><span class="line">myCon.getHeaderField();         <span class="comment">// 获取响应头字段</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>获取响应内容</strong></p>
<ul>
<li><strong>getContent 方法</strong>：获取响应内容。</li>
<li><strong>getInputStream 方法</strong>：输入流获取响应内容，响应表明发送了错误则抛出 <code>IOException</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.getContent(); </span><br><span class="line"></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(myCon.getInputStream()));</span><br><span class="line"><span class="keyword">while</span> ((str = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myCon.disconnect();</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="HTTP-通信用例"><a href="#HTTP-通信用例" class="headerlink" title="HTTP 通信用例"></a>HTTP 通信用例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 网络爬虫</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebCrawler</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getHttpJson</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//配置URL</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">myUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://static-data.eol.cn/www/school/&quot;</span>+ i + <span class="string">&quot;/info.json&quot;</span>);</span><br><span class="line">            <span class="comment">//配置连接</span></span><br><span class="line">            <span class="type">HttpURLConnection</span> <span class="variable">myCon</span> <span class="operator">=</span> (HttpURLConnection) myUrl.openConnection();</span><br><span class="line">            myCon.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)&quot;</span>);</span><br><span class="line">            myCon.setConnectTimeout(<span class="number">10000</span>);</span><br><span class="line">            myCon.setReadTimeout(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//建立连接</span></span><br><span class="line">            myCon.connect();</span><br><span class="line">            <span class="comment">//如果连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (myCon.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据读取成功，数据内容：&quot;</span>);</span><br><span class="line">                <span class="comment">//读取返回数据</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> myCon.getInputStream();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> in.available();</span><br><span class="line">                <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[cnt];</span><br><span class="line">                in.read(b);</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b);</span><br><span class="line">                <span class="comment">//输出返回数据</span></span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据读取失败，代码：&quot;</span> + myCon.getResponseCode());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;URL错误，无法查找到资源。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SocketTimeoutException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ID&quot;</span> + i + <span class="string">&quot;的数据访问连接超时。&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;发送的请求存在错误，资源拒绝访问。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>理论基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><hr>
<h2 id="网络层功能"><a href="#网络层功能" class="headerlink" title="网络层功能"></a>网络层功能</h2><p>以路由器为中继系统连接不同结构的网络，统一使用 IP 协议进行相互通信。</p>
<p>传输层报文在网络层将被封装成 IP 数据报进行分组转发，路由器将根据 IP 地址选择转发路由。</p>
<hr>
<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由器通过查询路由表选择转发路由，当路由信息发生变化时，就需要路由器根绝路由选择协议动态更新路由表。</p>
<p>为方便选择转发路由，我们将互联网分为多个自治系统，在自治系统内可包含多个局域网。一个自治系统内所有网络一般都属于同一个行政单位，全部路由器在自治系统内都是联通的。</p>
<h3 id="域间路由"><a href="#域间路由" class="headerlink" title="域间路由"></a>域间路由</h3><p>负责在自治系统之间选择路由传递 IP 数据报。</p>
<ul>
<li><strong>BGP 协议</strong></li>
</ul>
<p>应用层协议，基于 TCP 实现。只负责选择一条尽可能好的路径，将 IP 数据报传达到目标自治系统内。</p>
<h3 id="域内路由"><a href="#域内路由" class="headerlink" title="域内路由"></a>域内路由</h3><p>负责在自治系统内选择路由传递 IP 数据报。</p>
<ul>
<li><strong>RIP 协议</strong></li>
</ul>
<p>应用层协议，基于 UDP 实现。相邻路由器之间会定时交换全部路由表信息。路由器会根据到达目的地址的最少跳数（经过路由器数量）来选择最短路由，更新自己的路由表信息。</p>
<p>使用简单方便。但最大跳数只支持 15（16 表示不可达），不适用于大型互联网。且会出现 “坏消息传得慢” 现象。</p>
<ul>
<li><strong>OSPF 协议</strong></li>
</ul>
<p>网络层协议，使用 IP 数据报传输。</p>
<ol>
<li>相邻路由器之间会定时交互以确保对方可达（问候分组）。</li>
<li>路由器刚开始工作时，会和相邻路由器交换路由信息（数据库描述分组），缺少数据时向相邻路由器索要（链路状态请求分组）。</li>
<li>当链路状态发生变化时，路由器会向区域内的全部路由器发送路由表信息（链路状态更新分组），路由器收到后返回确认（链路状态确认分组）。</li>
</ol>
<hr>
<h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><p>IP 协议是网络层的核心协议，负责定义 IP 数据报的数据格式和传输规则。IP 协议无连接且不可靠。目前主要使用的 IP 协议版本为 IPv4 。</p>
<h3 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h3><p>IP 数据报由首部和数据两部分组成。</p>
<p><img src="/pic/%E5%88%86%E7%BB%84.png" alt="分组"></p>
<p>首部长度为 20 + 4N 字节，含有以下字段：</p>
<ul>
<li><strong>版本</strong>：4</li>
<li><strong>首部长度</strong> ：(4 bit) 单位 4B ，首部最大长度为 60 字节。</li>
<li><strong>总长度</strong>：(16 bit) 单位 1B ，IP 数据报最大长度为 65535 字节。 </li>
<li><strong>标识</strong>：(16 bit) 分片后的 IP 数据报使用同一个标识，以便组装。</li>
<li><strong>标志</strong>：(3 bit) 标志是否允许分片，以及是否是第一个分片。</li>
<li><strong>片偏移</strong>：(13 bit) 单位 8B ，标识分组分片后的偏移量，以便组装。</li>
<li><strong>首部校验和</strong>：(16 bit) </li>
<li><strong>生存时间 TTL</strong>：(8 bit) IP 数据报剩余寿命，每次转发后自减。</li>
<li><strong>协议</strong>：(8 bit) 使用的上层协议，即数据报到达后交付者。1/ICMP 2/IGMP 6/TCP 17/UDP</li>
<li><strong>源地址</strong>：(32 bit)</li>
<li><strong>目的地址</strong>：(32 bit)</li>
</ul>
<p>为什么分片：IP 数据报最大 65535 字节，但以太网帧限制为 1500 字节。</p>
<h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>在 IPv4 协议使用 32bit 的 IP 地址标识主机。IP 地址由网络号和主机号两部分组成，分为以下几种类型：</p>
<ul>
<li>**A 类地址 (1-126)**：8bit 网络号 + 24bit 主机号</li>
<li>**B 类地址 (128-191)**：16bit 网络号 + 16bit 主机号</li>
<li>**C 类地址 (192-223)**：24bit 网络号 + 8bit 主机号</li>
<li>**D 类地址 (224-239)**：多播地址</li>
</ul>
<h4 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h4><ul>
<li><code>0.0.0.0</code> 和 <code>127.0.0.0</code> 表示当前主机</li>
<li><code>255.255.255.255</code> 表示当前网络的广播地址 </li>
<li>主机号全为 0 表示 指定网络本身： 例如 <code>202.98.174.0</code> </li>
<li>主机号全为 1 表示 指定网络的广播地址：例如 <code>202.98.174.255</code> </li>
</ul>
<h4 id="子网编码"><a href="#子网编码" class="headerlink" title="子网编码"></a>子网编码</h4><p>为节省 IP 地址，IP 协议对网络内部进行了再划分，使一个网络号内部可以存储多个子网。IP 地址实际由网络号、子网号和主机号三部分组成。</p>
<p>在传输 IP 地址时，我们同样会发送 32bit 的子网掩码（前面全为 1 后面全为 0）来区分子网和主机。例如 IP 地址 <code>136.34.5.56</code> 的子网掩码为 <code>255.255.255.0</code> ，那么子网号就是 <code>136.34.5.0</code>.</p>
<h4 id="网址转换-NAT"><a href="#网址转换-NAT" class="headerlink" title="网址转换 NAT"></a>网址转换 NAT</h4><p>为节省 IP 地址，IP 协议允许专用网络内部采用私有 IP 地址标识主机，整个专用网络共享一个公用 IP 地址。</p>
<p>多个本地主机在公网共用一个 IP 地址，必须通过端口号来相互区分。公网 IP 地址/端口号和私有 IP 地址/端口号的对应关系保存在负责连接内外网的 NAT 路由器中，在转发 IP 数据报时会自动读取传输层报文并进行 NAT 转换：</p>
<ul>
<li>SNAT 本地主机向公网发送请求时，NAT 路由器转发时会修改源地址和端口号，切换为公有。</li>
<li>DNAT 公网向本地主机发送请求时，NAT 路由器转发时会修改目的地址和端口号，切换为私有。</li>
</ul>
<p>为此 IP 协议划分出了专用的私有地址供专用网络内部使用，在公网中指向私有地址的 IP 数据报不会被转发。</p>
<ul>
<li>**A 类私有地址 (10)**：例如 <code>10.98.174.0</code> </li>
<li>**B 类私有地址 (172.16-172.31)**：例如 <code>172.16.0.1</code> </li>
<li>**C 类私有地址 (192.168)**：例如 <code>192.168.0.1</code> </li>
</ul>
<h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>最新版本的 IP 协议 IPv6 可以从根本上解决 IP 地址短缺问题，改用 128 bit 的全新 IP 地址标识主机。</p>
<h3 id="辅助协议"><a href="#辅助协议" class="headerlink" title="辅助协议"></a>辅助协议</h3><h4 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h4><p>网络层协议，负责映射 IP 地址和 MAC 地址。</p>
<p>主机会维护一个映射表记录同网络各主机 IP 地址和 MAC 地址的映射关系，通过查询映射表在网路内部转发 IP 分组。如果未记录则在局域网内部广播 ARP 请求，由目的主机返回其 IP 地址和 MAC 地址的映射关系。</p>
<h4 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h4><p>基于 UDP 的传输层协议，为网络中的主机分配 IP 地址。</p>
<ol>
<li>主机启动时在网络内部广播 DHCP 发现消息：申请分配 IP 地址。</li>
<li>网络内部的 DHCP 服务器接收到消息后广播 DHCP 提供消息：提供可分配的 IP 地址。</li>
<li>主机接收到消息后广播广播 DHCP 请求消息：接受 IP 地址。</li>
<li>网络内部的 DHCP 服务器接收到消息后广播 DHCP 确认消息：分配 IP 地址。</li>
</ol>
<h4 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h4><p>网络层协议，负责报告差错和异常情况，也可以用于询问(ping 指令)。</p>
<p>当 IP 数据报传输出现异常时，会生成 ICMP 报文封装为 IP 数据报发回源主机报告异常情况。</p>
<ol>
<li>数据分片后，只会对第一个分片的 IP 数据报报告差错。</li>
<li>封装 ICMP 报文的 IP 数据报出错后不会报告差错，防止 ICMP 报文泛滥。</li>
<li>组播 IP 数据报出现异常不会报告差错。</li>
</ol>
<p><em>策略可以有效防止 Smurf 攻击：攻击者在网络散播错误源地址的 Ping 请求，导致大量机器向源地址返回 ping 回复使源地址主机瘫痪。</em></p>
<p>ICMP 报文的前 32 bit 信息是固定的，为 类型/编号/数据校验和。</p>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>网络接口层</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h1><hr>
<h2 id="网络接口层功能"><a href="#网络接口层功能" class="headerlink" title="网络接口层功能"></a>网络接口层功能</h2><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>将网络层交下来的 IP 数据报组装成帧，根据 MAC 地址建立网络中两个相邻节点间的点对点传输。</p>
<p>同时也会对传输帧进行基本的差错检测。如果发现差错数据链路层会直接丢弃出错的帧，以避免继续传输浪费网络资源。部分算法也可以对帧进行简单的纠错。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>屏蔽具体传输设备的差异，实现相邻计算机节点之间比特流的透明传送。</p>
<hr>
<h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>在局域网内，通常使用广播通信。可能会出现多个主机信号争用广播信道的情况。</p>
<h3 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h3><p>将广播信道按时间或空间划分，分配给多个信号使用。</p>
<ul>
<li><strong>频分复用</strong></li>
</ul>
<p>将物理信道的总带宽分割成多个子信道通信。如果通过光纤传输则叫做波分复用。</p>
<ul>
<li><strong>时分复用</strong></li>
</ul>
<p>将物理信道分割成多个时间片，轮流分配给多个信号使用。</p>
<ul>
<li><strong>码分复用</strong></li>
</ul>
<p>依靠编码将信号混合，既共享了时间又共享了空间。</p>
<h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><ul>
<li><strong>CSMA/CD 协议</strong></li>
</ul>
<p>先听后发，边听边发。冲突停发，随机重发。</p>
<p>适用于网络状态良好的有线网络</p>
<ul>
<li><strong>CSMA/CA 协议</strong></li>
</ul>
<p>发前广播，避免碰撞。</p>
<p>适用于网络状态不佳的无线网络</p>
<h3 id="轮询访问"><a href="#轮询访问" class="headerlink" title="轮询访问"></a>轮询访问</h3><ul>
<li>令牌传递协议</li>
</ul>
<p>环形网络，交替传递令牌。持有令牌的主机才被允许在信道上传递信号。</p>
<p>适用于负载非常高的网络信道。</p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>理论基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><hr>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>在 ISO/OSI 和 TCP/IP 体系结构中，计算机网络被划分为多个层次。每层执行自己的功能，由下层向上层提供接口。</p>
<p><img src="/pic/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.jpg" alt="体系结构"></p>
<hr>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>在特定的应用进程间传输报文实现数据交互，来完成特定的网络应用。</p>
<h4 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h4><p>在应用层使用的协议类型多种多样，不同的协议执行不同的功能。最常使用的协议如下：</p>
<ul>
<li><p><strong>域名系统 DNS</strong>：将域名和 IP 地址相互映射，使用户能够通过域名访问互联网。</p>
</li>
<li><p><strong>超文本传输协议 HTTP</strong>：发布和接收 HTML 页面，使用户能够通过浏览器浏览网页，默认端口 80。</p>
</li>
<li><p><strong>电子邮件协议 SMTP</strong>：发布和接收邮件。</p>
</li>
</ul>
<hr>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>将应用层的报文封装到传输层中，根据套接字（IP 地址 + 端口）建立两个主机进程之间的端对端通信。</p>
<p>传输层会自动对上层数据进行分用和复用：不同的应用层报文可封装到同一个传输层报文中传输，到达后再拆分报文交付给应用层中的各个进程。</p>
<h4 id="TCP-amp-UDP-协议"><a href="#TCP-amp-UDP-协议" class="headerlink" title="TCP &amp; UDP 协议"></a>TCP &amp; UDP 协议</h4><p>传输层主要使用 TCP 和 UDP 两种协议，两者区别如下：</p>
<ul>
<li><strong>TCP 提供可靠的、面向连接的服务</strong>。</li>
</ul>
<ol>
<li><p>在传送数据之前必须先建立连接，数据传送结束后要释放连接。接收方收到 TCP 报文会校验数据并返回确认，发送方可以根据情况控制发送速度。</p>
</li>
<li><p>一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
</li>
</ol>
<ul>
<li><strong>UDP 提供不可靠但高效的、无连接的服务</strong>。</li>
</ul>
<ol>
<li><p>在传送数据之前不需要建立连接。接收方收到 UDP 报文后只核对报文检验和，如果出现错误直接丢弃，不需要返回任何确认。</p>
</li>
<li><p>一般用于即时通信，如语音、视频、直播等场景。</p>
</li>
</ol>
<hr>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>把传输层的报文分组封装成 IP 数据报，根据 IP 地址在网络中选择合适的路由进行传输。</p>
<h4 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h4><p>是网络层的核心协议。目前主要使用版本为 IPv4，使用 32bit 的 IP 地址标识主机。  </p>
<hr>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>将网络层交下来的 IP 数据报组装成帧，根据 MAC 地址建立网络中两个相邻节点间的点对点传输。</p>
<p>同时也会对传输帧进行基本的差错检测。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错）</p>
<hr>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</p>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>对类的实例化过程进行抽象，将软件模块中对象的创建和对象的使用分离。</p>
<ul>
<li>单例模式： 全局只有一个对象。</li>
<li>工厂模式： 由对象工厂负责生成对象。</li>
<li>建造者模式： 组装复杂的实例。</li>
<li>原型模式： 通过复制生成实例。</li>
</ul>
<hr>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。省略创建多个对象所花费的时间和内存空间。</p>
<p><strong>单例模式类的两大特征</strong></p>
<ol>
<li>构造函数必须为 private ，确保单例不会在系统中的其他代码内被实例化。</li>
<li>实例成员变量和初始化方法必须为 static 。</li>
</ol>
<h3 id="饿汉方式"><a href="#饿汉方式" class="headerlink" title="饿汉方式"></a>饿汉方式</h3><p>在类装载时，立即创建单例对象。</p>
<p><em>如果一直未被使用，内存空间被浪费；但每次调用时不需要判断，可以节省运行时间。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在后方定义功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类实现。 <em>更简洁，自动支持序列化机制，防止多次实例化。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="comment">// 在后方定义功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时直接使用 Singleton.INSTANCE 对象即可。</p>
<h3 id="懒汉方式"><a href="#懒汉方式" class="headerlink" title="懒汉方式"></a>懒汉方式</h3><p>在第一次被使用时，创建单例对象。</p>
<p>synchronized 关键字实现，加同步锁后再新建对象，保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">      <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">	      <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">	          singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">	      &#125;  </span><br><span class="line">	      <span class="keyword">return</span> singleton;  </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 在后方定义功能</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>双重锁结构实现，先判断实例对象是否存在，如果不存在不再需要加锁，大大提高了效率。</p>
<p>volatile 关键字用于防止指令重排序。创建对象的过程可能发生重排序，在未给初始化对象赋初值的情况下，就为设置实例对象指向刚分配的内存地址。其他线程在此时可能会通过!=null判断读取到未赋初值的内存空间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;    </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在后方定义功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>static 内部类实现。 <em>和枚举类原理类似，防止多次实例化。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 在后方定义功能 </span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在基类中定义创建对象的一个接口，让子类决定实例化哪个类。工厂方法让一个类的实例化延迟到子类中进行。</p>
<p>除了解耦合，把对象的创建和使用的过程分开。工厂模式批量生产对象，还能有效降低代码重复，在业务逻辑发生变化时降低维护成本。 在开源框架中的使用很多，比如 Spring 框架中通过 getBean 方法获取 Bean 。</p>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>提供一个统一的工厂类，由用户调用其 static 方法来创建对象。可以根据用户输入参数来返回相应的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Shape circle = ShapeFactory.getShape(&quot;CIRCLE&quot;);</code></p>
<p>如果我们新增产品类的话，就需要修改工厂类中的 getShape 方法。这个弊端可以通过反射机制改善。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getShape</span><span class="params">(Class&lt;? extends Shape&gt; c)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Circle circle = (Circle) ShapeFactory2.getClass(factory_pattern.Circle.class);</code></p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法模式是简单工厂的仅一步深化。在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 专用工厂类，还可以有其他工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>工厂方法模式中专用工厂类只生产单一产品。如果需要生产相互是有关系或有依赖的整套产品，就使用抽象工厂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">produceGun</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> Bullet <span class="title function_">produceBullet</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AKFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Gun <span class="title function_">produceGun</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bullet <span class="title function_">produceBullet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AK_Bullet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>如果要要创建大量相同或相似对象，使用构造函数会比较复杂且耗时耗资源。原型模式用一个已经创建的实例作为原型，通过复制该原型对象来创建新对象。生成对象就很高效。</p>
<p>原型模式的克隆分为浅克隆和深克隆。</p>
<ul>
<li><p>浅克隆 复制的变量和原变量的值相同，复制的引用仍指向原有的对象。</p>
</li>
<li><p>深克隆 复制的变量和原变量的值相同，复制的引用将指向被复制的新对象。</p>
</li>
</ul>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>由于 Java 提供了对象的 clone 方法，所以用 Java 实现原型模式很简单。</p>
<p>在 java 中自定义类必须实现 Cloneable 接口，并重写 Object 类中的 clone 方法.否则会抛出 CloneNotSupportedException 异常。调用 Object 类的 clone 方法失败时会把异常抛出，应当写在 try-catch 语句中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写克隆方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;obj1==obj2?&quot;</span>+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p>通过重写 clone 方法去实现深克隆十分麻烦， 因此引出了另外一种方式：序列化实现深克隆。</p>
<p>在Java语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p>
<hr>
<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p>
<ol>
<li>各个具体的建造者相互独立，有利于系统的扩展。</li>
<li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li>
</ol>
<p>其缺点如下：<br>产品的组成部分必须相同，这限制了其使用范围。<br>如果产品的内部变化复杂，该模式会增加很多的建造者类。</p>
<p>建造者（Builder）模式的主要结构，其相关类的代码如下。</p>
<h3 id="产品角色"><a href="#产品角色" class="headerlink" title="产品角色"></a>产品角色</h3><p>拆分成多个组成部件的复杂对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartA</span><span class="params">(String partA)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartB</span><span class="params">(String partB)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPartC</span><span class="params">(String partC)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;show Product&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h3><p>(2) 抽象建造者：包含创建产品各个子部件的抽象方法。<br>abstract class Builder<br>{<br>    //创建产品对象<br>    protected Product product=new Product();<br>    public abstract void buildPartA();<br>    public abstract void buildPartB();<br>    public abstract void buildPartC();<br>    //返回产品对象<br>    public Product getResult()<br>    {<br>        return product;<br>    }<br>}</p>
<p>(3) 具体建造者：实现了抽象建造者接口。<br>public class ConcreteBuilder extends Builder<br>{<br>    public void buildPartA()<br>    {<br>        product.setPartA(“建造 PartA”);<br>    }<br>    public void buildPartB()<br>    {<br>        product.setPartA(“建造 PartB”);<br>    }<br>    public void buildPartC()<br>    {<br>        product.setPartA(“建造 PartC”);<br>    }<br>}</p>
<h3 id="指挥者"><a href="#指挥者" class="headerlink" title="指挥者"></a>指挥者</h3><p>调用建造者中的方法完成复杂对象的创建。</p>
<p>class Director<br>{<br>    private Builder builder;<br>    public Director(Builder builder)<br>    {<br>        this.builder=builder;<br>    }<br>    //产品构建与组装方法<br>    public Product construct()<br>    {<br>        builder.buildPartA();<br>        builder.buildPartB();<br>        builder.buildPartC();<br>        return builder.getResult();<br>    }<br>}</p>
<p>(5) 客户类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 建造者</span></span><br><span class="line">        Builder builder=<span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>();</span><br><span class="line">        <span class="comment">// 指挥者控制建造者</span></span><br><span class="line">        Director director=<span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="comment">// 指挥者建造产品</span></span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        <span class="comment">// 使用产品</span></span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>理论基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>结构型模式</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F%20/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>描述类或对象的布局结构。分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>对象结构型模式耦合度更低，普遍使用对象型结构模式。</p>
<ul>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
</ul>
<hr>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>客户通过访问代理对象，来执行实际对象的方法。</p>
<ol>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。如虚拟硬盘。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。如访问时临时加载的模糊图片。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
</ol>
<p>设计代理以前真实主题必须事先存在，不太灵活。动态代理模式可以解决以上问题，如 SpringAOP。</p>
<hr>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。分为类结构型模式和对象结构型模式两种。</p>
<p>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。<br>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。<br>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adaptee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">specificRequest</span><span class="params">()</span></span><br><span class="line">    &#123;       </span><br><span class="line">        System.out.println(<span class="string">&quot;适配者中的业务代码被调用！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">Adaptee</span> <span class="keyword">implements</span> <span class="title class_">Target</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。<br>扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。<br>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。<br>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</p>
]]></content>
      <categories>
        <category>理论基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式</title>
    <url>/2023/05/14/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>理论基础</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>yan</tag>
        <tag>理论基础</tag>
      </tags>
  </entry>
</search>
